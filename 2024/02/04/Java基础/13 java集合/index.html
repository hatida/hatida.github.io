<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>13 Java 数据结构 | HatidaBlog</title>
  <meta name="keywords" content=" java , 集合 ">
  <meta name="description" content="13 Java 数据结构 | HatidaBlog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="第4章 检索数据4.5 检索不同的行DISTINCT关键字：此关键字指示MySQL只返回不同的值。  不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。 相当于将distinct后面的列放在一起作为条件  4.6 限制结果-limit关键">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql必知必会">
<meta property="og:url" content="http://example.com/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html">
<meta property="og:site_name" content="HatidaBlog">
<meta property="og:description" content="第4章 检索数据4.5 检索不同的行DISTINCT关键字：此关键字指示MySQL只返回不同的值。  不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。 相当于将distinct后面的列放在一起作为条件  4.6 限制结果-limit关键">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/kilomi/pic-bed/raw/master/img/202402050101323.png">
<meta property="article:published_time" content="2024-02-04T17:00:28.000Z">
<meta property="article:modified_time" content="2024-02-04T17:01:13.136Z">
<meta property="article:author" content="hatida">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/kilomi/pic-bed/raw/master/img/202402050101323.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>hatida</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/hatida"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(19)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="编程语言">
            <i class="fold iconfont icon-right"></i>
            编程语言
            <small>(17)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="编程语言&lt;---&gt;java">
            
            java
            <small>(17)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">
<input type="hidden" id="yelog_site_word_count" value="137.6k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>查找</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多线程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>反射</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>集合</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>类</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>枚举</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面向对象</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数组</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>网络</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>项目</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>异常</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>正则表达式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>注解</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>字符串</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>GUI</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jdbc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mysql</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="All 数据库 "
           href="/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="mysql必知必会">mysql必知必会</span>
            <span class="post-date" title="2024-02-05 01:00:28">2024/02/05</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"
           data-tag="java,枚举,注解"
           data-author="" >
            <span class="post-title" title="10 枚举和注解">10 枚举和注解</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/11%20%E5%BC%82%E5%B8%B8%EF%BC%88Exception%EF%BC%89/"
           data-tag="java,异常"
           data-author="" >
            <span class="post-title" title="11 异常（Exception）">11 异常（Exception）</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/21%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"
           data-tag="java,反射"
           data-author="" >
            <span class="post-title" title="21 反射">21 反射</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag="java,正则表达式"
           data-author="" >
            <span class="post-title" title="25 正则表达式">25 正则表达式</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/5%20%E6%95%B0%E7%BB%84/"
           data-tag="java,数组,排序,查找"
           data-author="" >
            <span class="post-title" title="5 数组、排序和查找">5 数组、排序和查找</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3String/"
           data-tag="java,字符串,jvm"
           data-author="" >
            <span class="post-title" title="String深入理解">String深入理解</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
           data-tag="java,网络"
           data-author="" >
            <span class="post-title" title="19 网络编程">19 网络编程</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/17%20IO%E6%B5%81/"
           data-tag="java,IO"
           data-author="" >
            <span class="post-title" title="17 IO流">17 IO流</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E4%B8%AD%E7%BA%A7)/"
           data-tag="java,面向对象"
           data-author="" >
            <span class="post-title" title="7 面向对象编程（中级）">7 面向对象编程（中级）</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E9%AB%98%E7%BA%A7)/"
           data-tag="java,类"
           data-author="" >
            <span class="post-title" title="9.1 类变量和类方法">9.1 类变量和类方法</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="12 常用类">12 常用类</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="16 多线程">16 多线程</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/23%20JDBC/"
           data-tag="java,jdbc,数据库"
           data-author="" >
            <span class="post-title" title="23 JDBC 和数据库连接池">23 JDBC 和数据库连接池</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E5%9F%BA%E7%A1%80)/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="6.面向对象编程（基础）">6.面向对象编程（基础）</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"
           data-tag="java,GUI"
           data-author="" >
            <span class="post-title" title="15 图形界面设计">15 图形界面设计</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/13%20java%E9%9B%86%E5%90%88/"
           data-tag="java,集合"
           data-author="" >
            <span class="post-title" title="13 Java 数据结构">13 Java 数据结构</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 编程语言 java "
           href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/24%20%E6%BB%A1%E6%B1%89%E6%A5%BC%E9%A1%B9%E7%9B%AE/"
           data-tag="java,项目"
           data-author="" >
            <span class="post-title" title="24 项目：满汉楼">24 项目：满汉楼</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 数据库 "
           href="/2024/02/04/mysql/mysql/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="mysql">mysql</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Java基础/13 java集合" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">13 Java 数据结构</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a> > 
            
            <a  data-rel="编程语言&lt;---&gt;java">java</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">java</a>
            
            <a class="color3">集合</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-02-05 01:19:20'>2024-02-04 16:17</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:13.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">13 Java 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.1 集合的框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.2 单列集合接口 Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.2.1 迭代器 Iterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.3 有序集合接口 List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.3.1 可变数组 ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">ArrayList 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.3.2 可变数组 Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">Vector 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.3.3 链表 LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#LinkedList 的源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#ArrayList 和 LinkedList 的比较：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.3.4 稀疏数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.3.5 栈 Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#13.3.5.1 栈模拟计算器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.3.6 跳表 SkipList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.4 队列接口 Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.4.1 优先级队列 PriorityQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.4.2 阻塞队列接口 BlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.4.3 双端队列接口 Deque</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.5 双列集合接口 Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#Map 接口遍历元素：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;迭代器完成遍历&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;13.5.1 散列表 HashMap&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#HashMap 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;13.5.2 散列表 Hashtable&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#Hashtable 与 HashMap 的比较：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;Entry、Node和Map.Entry&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">重写hashCode和equal方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.5.3 红黑树 TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#TreeMap 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.5.4 Properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.6 无序集合接口 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.6.1 HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#HashSet 的源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.6.2 LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">#LinkedHashSet 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">13.6.3 TreeSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.7 集合的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.8 工具类 Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">常用方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">13.9 JUnit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">本章作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;1.试分析HashSet和TreeSet分别是如何实现去重的&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">在TreeSet传入一个对象(自定义的对象)时，如果它没有实现Comparable接口，那么当treeset.add(对象)的时候会抛出ClassCastException的异常。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">HashSet的元素不能重复</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="13-java-数据结构">13 Java 数据结构</span></h1><blockquote>
<p>数据结构分为两种：线性结构、非线性结构</p>
</blockquote>
<p><strong>线性结构：</strong></p>
<ul>
<li><p>最常用的数据结构。数据元素间存在一对一线性关系。</p>
</li>
<li><p>线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构</p>
<p>  顺序存储结构中元素存储在连续的内存空间中。</p>
<p>  链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息</p>
</li>
<li><p>常见的线性结构有：数组、队列、链表、栈等</p>
</li>
</ul>
<p><strong>非线性结构：</strong></p>
<ul>
<li>非线性结构包括：二维数组、多维数组、广义表、树结构、图结构</li>
</ul>
<h2><span id="131-集合的框架体系">13.1 集合的框架体系</span></h2><blockquote>
<p>Java 提供了一系列集合容器，以方便程序员动态保存元素。并提供了一系列方便的操作对象的方法。</p>
<p>Java 集合主要分为两组：单列集合（Collection）、双列集合（Map）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190227211326757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhcnRvb25f,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310081718593.webp" alt="集合体系图_13.1"></p>
<p><em>（集合体系图_13.1）</em></p>
<ul>
<li><p><strong>Collection 接口</strong>（单列集合）：可以存放多个元素。每个元素可以是 Object</p>
<p>  Collection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</p>
</li>
<li><p><strong>Map 接口</strong>（双列集合）：用于保存具有映射关系的数据：key - value（双列元素）</p>
<p>  key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复</p>
<p>  key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</p>
</li>
</ul>
<h2><span id="132-单列集合接口-collection">13.2 单列集合接口 Collection</span></h2><pre><code class="java">public interface Collection&lt;E&gt; extends Lterable&lt;E&gt;
</code></pre>
<blockquote>
<p>Collection 实现子类可以存放多个元素。每个元素可以是 Object</p>
<p>有些 Collection 实现子类能存放重复的元素，有些不能</p>
<p>有些 Collection 实现子类是有序的（List） ，有些不是（Set）</p>
<p>Collection 接口没有直接的实现子类，都是通过其子接口实现的</p>
</blockquote>
<h3><span id="常用方法">常用方法：</span></h3><ul>
<li><p><code>add</code>：添加单个元素</p>
<pre><code class="java">ArrayList list = new ArrayList();
list.add(&quot;哈哈啊&quot;);
list.add(10);				// 相当于List.add(new Integer(10));
list.add(true);				// 同上
</code></pre>
</li>
<li><p><code>remove</code>：删除单个元素</p>
<pre><code class="java">list.remove(0)				// 删除编号 0 的元素。上例中会删除 &quot;哈哈啊&quot;
list.remove((Integer)10);	// 删除上例的 10 要这样写
</code></pre>
</li>
<li><p><code>contains</code>：检查元素是否存在</p>
</li>
<li><p><code>size</code>：获取元素个数</p>
</li>
<li><p><code>isEmpty</code>：判断是否为空</p>
</li>
<li><p><code>clear</code>：清空</p>
</li>
<li><p><code>addAll</code>：添加多个元素</p>
<pre><code class="java">ArrayList list2 = new ArrayList();
list2.add(111);
list2.add(&quot;idea&quot;);
list.addAll(list2);			// 这里可以输入所有实现了 Collection 接口的集合
</code></pre>
</li>
<li><p><code>containsAll</code>：检查多个元素是否存在</p>
<pre><code class="java">list.contaionsAll(list2);	// 同上，放一个实现了 Collection 接口的集合
</code></pre>
</li>
<li><p><code>removeAll</code>：删除多个元素</p>
<pre><code class="java">list.removeAll(list2);		// 同上
</code></pre>
</li>
<li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p>
</li>
</ul>
<h3><span id="1321-迭代器-iterator">13.2.1 迭代器 Iterator</span></h3><blockquote>
<p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p>
<p>Collection 继承的 Iterable 接口中，提供了 <code>iterator()</code> 方法，会返回一个新的迭代器。</p>
<p>Iterator 对象仅用于遍历集合，本身不存放元素</p>
<p>IDEA 中，迭代器 while 循环的模板快捷键：<code>itit</code></p>
</blockquote>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li>
<li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li>
</ul>
<p><strong>用迭代器遍历元素：</strong></p>
<pre><code class="java">Collection&lt;Object&gt; c = new LinkedList&lt;&gt;();
Iterator&lt;Object&gt; iterator = c.iterator();		// [1]
while (iterator.hasNext())&#123;						// [2]
    Object obj = iterator.next();				// [3]引用泛型后可以直接指定Object类型为其他，不用再向下转型了。
    System.out.println(obj);
&#125;
</code></pre>
<ol>
<li><p>获取迭代器</p>
</li>
<li><p>判断有无下一元素</p>
</li>
<li><p>将迭代器后移，并返回那个后移位置上的元素</p>
<p> while 循环结束后，指针指向最后元素的位置。再次 <code>next()</code> 会报错。如果需要再使用，需要重置迭代器。</p>
<pre><code class="java">iterator = list.iterator();				// 重置了迭代器
</code></pre>
</li>
</ol>
<p><strong>for each（增强 for 循环）：</strong></p>
<blockquote>
<p>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素</p>
<p>IDEA 中，增强 for 循环的模板快捷键：<code>I</code></p>
</blockquote>
<pre><code class="java">for (Object o : list)&#123;
    ...
&#125;
</code></pre>
<ul>
<li>for each 可在 Collection 集合中使用。</li>
<li>for each 的底层在本质上也是 <code>Iterator</code>。可以理解为简化版本的迭代器遍历。</li>
</ul>
<h2><span id="133-有序集合接口-list">13.3 有序集合接口 List</span></h2><pre><code class="java">public interface List&lt;E&gt; extends Collection&lt;E&gt;
</code></pre>
<blockquote>
<p>List 是 Collection 接口的子类接口</p>
<p>List 是有序（添加顺序和取出顺序一致）的，可重复的</p>
<p>List 中的每个元素都有其对应的顺序索引（从 0 开始编号）</p>
<p>List遍历时除了可以采用同Collection的增强for循环和迭代器iterator外，还可以利用自己的get()方法来进行普通for循环遍历。</p>
</blockquote>
<h3><span id="常用方法">常用方法：</span></h3><ul>
<li><p><code>add(int, obj)</code>：在 int 位置插入 obj 元素。返回 true</p>
<p>  <code>add(obj)</code>：在末尾插入 obj。返回 true</p>
<pre><code class="java">list.add(111);
list.add(0, 110);						// 在第 1 个位置插入数字 110
</code></pre>
<p>  <code>addElement(obj)</code>：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截</p>
</li>
<li><p><code>addAll(int, collection)</code>：在 int 位置插入 collection 中的所有元素</p>
</li>
<li><p><code>get(int)</code>：返回 int 位置的元素</p>
</li>
<li><p><code>indexOf(obj)</code>：返回 obj 首次出现时的位置</p>
</li>
<li><p><code>lastIndexOf(obj)</code>：返回 obj 最后一次出现时的位置</p>
</li>
<li><p><code>remove(int)</code>：移除 int 位置的元素，并返回那个被移除的元素</p>
</li>
<li><p><code>set(int, obj)</code>：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标</p>
<p>  <code>setElement(obj, int)</code>：设置 int 位置的元素为 obj。无返回值</p>
</li>
<li><p><code>subList(int1, int2)</code>：返回 [int1, int2) 范围的元素构成的子集合</p>
</li>
</ul>
<h3><span id="1331-可变数组-arraylist">13.3.1 可变数组 ArrayList</span></h3><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<blockquote>
<p>ArrayList 是 List 的实现子类。其底层由数组来实现存储。</p>
<p>ArrayList 可以存放 null</p>
</blockquote>
<h4><span id="arraylist-的源码">ArrayList 的源码：</span></h4><ol>
<li>ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组</li>
</ol>
<pre><code class="java">transient Object[] elementData;
</code></pre>
<ol start="2">
<li>创建 ArrayList 对象时，如果使用无参构造器，则 elementData[] 初始容量为 0</li>
</ol>
<pre><code class="java">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;

public ArrayList() &#123;
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&#125;
</code></pre>
<ol start="3">
<li>如果使用指定大小构造器，则初始容量为指定大小。</li>
</ol>
<pre><code class="java">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;

public ArrayList(int initialCapacity) &#123;
    if (initialCapacity &gt; 0) &#123;
        this.elementData = new Object[initialCapacity];
    &#125; else if (initialCapacity == 0) &#123;
    /* 这个场合，与默认构造器的不同之处在于
        扩容时，该 0 容量变为 1，而默认构造器会变为 10 */
        this.elementData = EMPTY_ELEMENTDATA;
    &#125; else &#123;
        throw new IllegalArgumentException(...);
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>扩容的场合：</li>
</ol>
<pre><code class="java">如果是 **无参构造器生成的初始 0 长度的 elementData**，则将其容量置为 10。

否则容量扩容为 1.5 倍。

/* 扩容方法，传入的参数 minCapacity 是容器现有元素数量 + 1 的值
    如果是无参构造器生成的默认数组，此时传入固定值 10 */
private void grow(int minCapacity) &#123;
    int oldCapacity = elementData.length;
    /* 计算新的容量（旧容量的 1.5 倍）
        此处 &gt;&gt; 为位运算符，等同于 newC = oldC + oldC / 2; */
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    /* 这里如果原容量是特殊值（1 或 0），容量会变为那个 minCapacity 的值 */
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<h3><span id="1332-可变数组-vector">13.3.2 可变数组 Vector</span></h3><pre><code class="java">public class Vector&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<blockquote>
<p>Vector 是 List 的实现子类。其底层由数组来实现存储</p>
<p>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。</p>
<p>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList。</p>
</blockquote>
<h4><span id="vector-的源码">Vector 的源码：</span></h4><ol>
<li>底层维护了一个 Object 类型的数组 elementData。用以存放元素</li>
</ol>
<pre><code class="java">protected Object[] elementData;
</code></pre>
<ol start="2">
<li>使用无参构造器创建对象时，默认大小是 10</li>
</ol>
<pre><code class="java">使用有参构造器的场合，默认是那个指定大小（initialCapaticy）

也能在构造器中指定那个扩容的增长速度（capacityIncrement）


public Vector() &#123;
    this(10);
&#125;

public Vector(int initialCapacity) &#123;
    this(initialCapacity, 0);
&#125;

public Vector(int initialCapacity, int capacityIncrement) &#123;
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(...);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
&#125;
</code></pre>
<ol start="3">
<li>扩容的场合，容量变成 2 倍</li>
</ol>
<pre><code class="java">使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值


private void grow(int minCapacity) &#123;
    int oldCapacity = elementData.length;
    /* 计算新的容量（按照指定的增速扩容）
        那个指定无效或未指定时，容量变为 2 倍 */
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<h3><span id="1333-链表-linkedlist">13.3.3 链表 LinkedList</span></h3><pre><code class="java">public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre>
<blockquote>
<p>在 Java 中，LinkedList 是 List 的实现子类，底层以链表形式存储元素，&#x3D;&#x3D;[数据结构中，Stack，ArrayDeque、LinkedList都可以作为栈使用,建议不要使用ArrayDeque和Stack作为栈来使用，而是使用LinkedList](D:\TyporaMarkdown\图解算法数据结构.md#### 性能选项)&#x3D;&#x3D;</p>
<p>链表是一种<strong>非线性结构</strong>：其以节点方式存储，节点间在内存上的位置不连续。</p>
<p>链表是有序的列表。单向链表每个节点包含 data 域和 next 域。那些 next 域指向下一节点的位置。</p>
<p>双向链表在单向链表的基础上，每个节点加入 prev 区域以指示其前方节点。这样，就能实现双向查找。双向链表可以不依靠辅助节点而实现自我删除。</p>
<p><strong>LinkedList 底层实现了 双向链表 和 双端队列 特点。</strong>在 Java 中，LinkedList 也实现了 Deque 接口。</p>
<p>LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。</p>
</blockquote>
<h4><span id="常用方法">#常用方法：</span></h4><ul>
<li><p><code>void addLast(E e)</code>：尾插一个新的元素</p>
<p>  LinkedList 的 add 方法即调用该方法</p>
</li>
<li><p><code>void addFirst(E e)</code>：头插一个新的元素</p>
</li>
<li><p><code>E removeLast()</code>：移除并返回尾部元素。为空时报错</p>
<p>  <code>E poll()</code>：移除并返回尾部元素。为空时返回 null</p>
<p>  <code>E removeFirst()</code>：移除并返回头部元素。为空时报错</p>
</li>
<li><p><code>E getLast()</code>：<u>仅返回尾部元素</u>。为空时报错</p>
<p>  <code>E peek()</code>：返回尾部元素。为空时返回 null</p>
<p>  <code>E element()</code>：返回头部元素。为空时返回 null</p>
<p>  <code>E getFirst()</code></p>
</li>
</ul>
<h4><span id="linkedlist-的源码">#LinkedList 的源码</span></h4><ol>
<li><p>LinkedList 只有默认构造器和一个拷贝构造器</p>
<pre><code class="java">public LinkedList() &#123;
&#125;

public LinkedList(Collection&lt;? extends E&gt; c) &#123;
    this();
    addAll(c);
&#125;
</code></pre>
</li>
<li><p>LinkedList 底层维护了一个 &#x3D;&#x3D;双向链表&#x3D;&#x3D;</p>
<p> 两个属性 first、last 分别指向 首节点 和 尾节点</p>
<p> 每个节点（Node 对象），里面又维护了 prev、next、item 属性。</p>
<p> 其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。</p>
<pre><code class="java">transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;

private static class Node&lt;E&gt; &#123;
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
        this.item = element;
        this.next = next;
        this.prev = prev;
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>LinkedList 不需要扩容</strong>。其增删元素时只要改变节点的指向即可。</p>
<p> 也因此，其添加、删除元素效率比数组更高</p>
</li>
</ol>
<h4><span id="arraylist-和-linkedlist-的比较">#ArrayList 和 LinkedList 的比较：</span></h4><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删效率</th>
<th>改查效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>低（数组扩容）</td>
<td>高</td>
</tr>
<tr>
<td><code>LinkedList</code></td>
<td>双向链表</td>
<td>高（链表追加）</td>
<td>低</td>
</tr>
</tbody></table>
<p>应该根据实际情况来选择使用的集合：</p>
<ul>
<li>如果改查操作多，选择 ArrayList。一般来说，在程序中，80% - 90% 都是查询。大部分情况下，选择 ArrayList。</li>
<li>如果增删操作多，选择 LinkedList</li>
</ul>
<h3><span id="1334-稀疏数组">13.3.4 稀疏数组</span></h3><blockquote>
<p>二维数组的很多值是默认值 0，因此记录了很多没有意义的数据。因此，可以使用稀疏数组。</p>
</blockquote>
<p>稀疏数组的处理方法：</p>
<ol>
<li>记录数组共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序规模</li>
</ol>
<p><strong>二维数组转换为稀疏数组：</strong></p>
<p>下面用 ArrayList 模拟一个稀疏数组。</p>
<p>二维数组：</p>
<pre><code class="java">int[][] map = &#123;&#123;0, 2, 0, 0, 0, 0 ,0 , 0&#125;,
              &#123;0, 0, 3, 0, 0, 0, 0, -1&#125;,
              &#123;15, 0, 0, 0, 0, 4, 0, 0&#125;,
              &#123;0, 2, 0, 0, 0, 0, 0, 0&#125;,
              &#123;0, 0, 0, 0, 0, 0, 0, 0&#125;,
              &#123;0, 0, 0, 0, 0, 0, 0, 1&#125;,
              &#123;0, 0, 0, 0, 0, 0, 0, 0&#125;&#125;;
</code></pre>
<p>遍历原始的二维数组，得到有效数据的个数 sum，并将二维数组的有效数据存入稀疏数组</p>
<pre><code class="java">List&lt;int[]&gt; sparseArray = new ArrayList();

sparseArray.add(new int[]&#123;map.length, map[0].length, 0&#125;);	//

for (int y = 0; y &lt; map.length; y++) &#123;
    for (int x = 0; x &lt; map[0].length; x++) &#123;
        if (map[y][x] != 0) &#123;
            sparseArray.add(new int[]&#123;y, x, map[y][x]&#125;);
            sparseArray.get(0)[2]++;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>稀疏数组转化为二维数组：</strong></p>
<p>读取稀疏数组的每一行，按照其第一行数据，创建原始的二维数组。</p>
<p>读取后几行数据，将值赋给二维数组</p>
<h3><span id="1335-栈-stack">13.3.5 栈 Stack</span></h3><pre><code class="java">public class Stack&lt;E&gt; extends Vector&lt;E&gt;
</code></pre>
<blockquote>
<p>Stack 是 Vector 的子类。以数组模拟了栈的数据结构。</p>
<p>栈是一个先入后出的有序列表。其元素之插入删除只能在该线性表的同一端进行。</p>
<p>其允许增删的一端称为栈顶，另一端即为栈底。</p>
<p>最先放入的元素位于栈底，最后放入的元素位于栈顶。</p>
<p>放入元素称为入栈（push），取出元素称为出栈（pop）</p>
</blockquote>
<p><strong>栈的应用场景：</strong></p>
<ul>
<li>子程序的调用</li>
<li>处理递归调用</li>
<li>表达式的转换与求值</li>
<li>二叉树的遍历</li>
<li>图形的深度优先搜索法</li>
</ul>
<h4><span id="常用方法">#常用方法：</span></h4><ul>
<li><p><code>E push(E item)</code>：将元素 item 压入栈。返回值是 item 自己</p>
</li>
<li><p><code>E pop()</code>：让栈顶元素出栈</p>
</li>
<li><p><code>E peek()</code>：仅获取栈顶元素</p>
</li>
<li><p><code>int search(Object o)</code>：查找该元素最后出现的位置。</p>
<p>  栈底为 1，栈顶为 size()，不存在返回 -1</p>
</li>
</ul>
<h4><span id="13351-栈模拟计算器">#13.3.5.1 栈模拟计算器</span></h4><blockquote>
<p>使用栈结构完成对计算器的实现</p>
</blockquote>
<p>要进行计算，需要获得表达式。</p>
<p>表达式分为三种：</p>
<ul>
<li><p><strong>中缀表达式：</strong></p>
<p>  中缀表达式即生活中常见的运算表达式。比如：(3 + 4) * 5 - 6</p>
<p>  中缀表达式是人最熟悉的。但是对于计算机来说却不好操作。因此，计算时常将其转化为其他表达式进行操作。</p>
</li>
<li><p><strong>前缀表达式：</strong></p>
<p>  前缀表达式（波兰表达式）是一种没有括号的表达式。其将运算符写在前面，操作数写在后面</p>
<blockquote>
<p>(3 + 4) * 5 - 6 的前缀表达式为： + 3 * 4 - 5 6</p>
<p>(1 + 2) * (3 + 4) 的前缀表达式为：* + 1 2 + 3 4</p>
</blockquote>
<p>  前缀表达式的计算机求值：</p>
<ul>
<li>从<strong>右</strong>向<strong>左</strong>扫描表达式</li>
<li>将数字压入堆栈</li>
<li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li>
<li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li>
</ul>
</li>
<li><p><strong>后缀表达式：</strong></p>
<p>  后缀表达式（逆波兰表达式）与前缀表达式相似。但其运算符位于操作数之后</p>
<blockquote>
<p>(3 + 4) * 5 - 6 的后缀表达式为： 3 4 + 5 * 6 -</p>
<p>(1 + 2) * (3 + 4) 的后缀表达式为：1 2 + 3 4 + *</p>
</blockquote>
<p>  后缀表达式的计算机求值：</p>
<ul>
<li>从<strong>左</strong>向<strong>右</strong>扫描表达式</li>
<li>将数字压入堆栈</li>
<li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li>
<li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li>
</ul>
</li>
</ul>
<p>对于人类来说，中缀表达式最为熟悉。但对于计算机来说，前缀、后缀表达式更容易识别。</p>
<p>我们可以将中缀表达式转化为后缀表达式，再进行运算。</p>
<p><strong>中缀表达式转换为后缀表达式：</strong></p>
<ol>
<li><p>初始化两个栈：运算符栈 operator_stack、表达式栈 formula_stack</p>
</li>
<li><p>从左到右扫描中缀表达式</p>
</li>
<li><p>遇到操作数时，将其压入表达式栈 formula_stack</p>
</li>
<li><p>遇到运算符时，比较其与 operator_stack 栈顶运算符的优先级。</p>
<ul>
<li>operator_stack 为空，或栈顶为 <code>(</code> 的场合，让运算符入栈</li>
<li>优先级高于栈顶运算符的场合，让其入栈</li>
<li>优先级低于或等于栈顶运算符的场合，将那个堆顶运算符弹出并压入 formula_stack。之后，重复该步骤。</li>
</ul>
</li>
<li><p>遇到括号时：</p>
<ul>
<li>遇到 <code>(</code> 时，压入 operator_stack</li>
<li>遇到 <code>)</code> 时，直到遇到 <code>(</code> 前，依次弹出 operator_stack 堆顶的运算符，并压入 formula_stack。之后将这一对括号丢弃。</li>
</ul>
</li>
<li><p>到达表达式最右边时，依次弹出 operator_stack 堆顶的运算符，压入 formula_stack。</p>
</li>
<li><p>此时，formula_stack 即为后缀表达式。</p>
<p> 使用 Java 的 toArray 方法将其转为数组。或将其依次弹出，并逆序输出。</p>
</li>
</ol>
<p><strong>计算器的实现：</strong></p>
<pre><code class="java">class Calculator &#123;
    private static final Map&lt;Character, Integer&gt; priority = new HashMap&lt;&gt;();

    static &#123;
        priority.put(&#39;+&#39;, 1);
        priority.put(&#39;-&#39;, 1);
        priority.put(&#39;*&#39;, 2);
        priority.put(&#39;/&#39;, 2);
        priority.put(&#39;×&#39;, 2);
        priority.put(&#39;÷&#39;, 2);
        priority.put(&#39;(&#39;, -100);
        priority.put(&#39;)&#39;, -10);
    &#125;

    public static double calculate(String formula) &#123;
        String[] ss = formula.split(&quot; &quot;);
        Stack&lt;String&gt; operator_stack = new Stack&lt;&gt;();
        Stack&lt;String&gt; formula_stack = new Stack&lt;&gt;();
        for (String s : ss) &#123;
            if (s.matches(&quot;\\d+([.]\\d+)?&quot;)) &#123;
                formula_stack.push(s);
                continue;
            &#125; else if (operator_stack.empty() || s.equals(&quot;(&quot;)) &#123;
                operator_stack.push(s);
                continue;
            &#125;
            String temp = operator_stack.peek();
            while (priority.get(s.charAt(0)) &lt;= priority.get(temp.charAt(0))) &#123;
                formula_stack.push(operator_stack.pop());
                if (operator_stack.empty()) break;
                temp = operator_stack.peek();
            &#125;
            if (s.equals(&quot;)&quot;)) &#123;
                operator_stack.pop();
            &#125; else operator_stack.push(s);

        &#125;
        while (!operator_stack.empty()) &#123;
            formula_stack.push(operator_stack.pop());
        &#125;
        return anti_Poland(String.join(&quot; &quot;, formula_stack.toArray(new String[]&#123;&#125;)));
    &#125;

    private static double anti_Poland(String formula) &#123;
        String[] ss = formula.split(&quot; &quot;);
        Stack&lt;Double&gt; ns = new Stack&lt;&gt;();
        for (String s : ss) &#123;
            try &#123;
                double num = Double.parseDouble(s);
                ns.push(num);
            &#125; catch (Exception e) &#123;
                switch (s) &#123;
                    case &quot;+&quot;:
                        ns.push(ns.pop() + ns.pop());
                        break;
                    case &quot;*&quot;:
                    case &quot;×&quot;:
                        ns.push(ns.pop() * ns.pop());
                        break;
                    case &quot;/&quot;:
                    case &quot;÷&quot;:
                        ns.push(1 / ns.pop() * ns.pop());
                        break;
                    case &quot;-&quot;:
                        ns.push(-ns.pop() + ns.pop());
                        break;
                    default:
                        throw new RuntimeException(&quot;Illegal operator&quot;);
                &#125;
            &#125;
        &#125;
        return ns.pop();
    &#125;
&#125;
</code></pre>
<h3><span id="1336-跳表-skiplist">13.3.6 跳表 SkipList</span></h3><p>跳表是一种特殊的链表。普通的链表虽然添加、删除节点的速度很快（O(1)），但是要查找节点却很慢（O(n)）。跳表是一个多层次的链表，其在链表的基础上增加了多级索引，实现了 O(㏒n) 的查找速度。</p>
<p>[![img](<a target="_blank" rel="noopener" href="https://i-melody.github.io/img/Java_InputImage/13_3_6">https://i-melody.github.io/img/Java_InputImage/13_3_6</a> 跳表图.webp)](<a target="_blank" rel="noopener" href="https://i-melody.github.io/img/Java_InputImage/13_3_6">https://i-melody.github.io/img/Java_InputImage/13_3_6</a> 跳表图.webp)</p>
<p><em>（13_3_6 跳表图）</em></p>
<p>跳表将原本数据层的数据按照一定间隔抽取节点形成索引层，之后再从索引层抽取节点形成第二级索引，以此类推形成多层索引。</p>
<p>跳表的查询速度得到了优化，但占用空间更大。本质上是一种空间换时间的做法。</p>
<p><strong>查询</strong></p>
<p>从最稀疏的索引层（最上层）开始，确定那个待查找数据所在的范围，逐层向下并确定范围，直至数据层。</p>
<p><strong>增删</strong></p>
<p>删除元素时，如果那个元素是索引元素，那些索引也会被删除。同时，如果只向数据层中增加元素，可能使索引间隔过大，从而降低查找效率。如果在增加元素时还能保持索引数量的动态平衡，就能防止跳表退化，保持跳表效率。</p>
<p>跳表给出的解决方案是：在增加元素时产生一个随机值，让这个随机值决定该新节点是否成为索引节点，以及成为几级索引节点。</p>
<p><strong>实现跳表</strong></p>
<pre><code class="java">class Skiplist &#123;
    private final int level;					// 该跳表的合计层数，包括数据层和索引层
    private final Random seed;					// 随机数种子
    private final Node root;					// 链表开头
    private final Node end;						// 链表结尾

    private static class Node &#123;					// 链表节点类
        int val;				// 值
        int count;				// 储存的值的数量
        Node[] next;			// 指向的下一节点
        Node[] prev;			// 指向的上一节点
                                // 需要指出的是：next 和 prev 的长度指示了节点所在的最高层级
                                // 长度为 1 时仅处在数据层，2 时也位于一级索引，以此类推
                                // 也就是说，next 和 prev 里，下标 0 的位置位于数据层，1 位于一级索引层

        /* 三个参数是：值 val，节点的层级 rand，节点储存值的数量 count */
        Node(int val, int rand, int count) &#123;
            this.val = val;
            this.count = count;
            next = new Node[rand];
            prev = new Node[rand];
        &#125;
    &#125;

    /* 构造器 */
    public Skiplist() &#123;
        this(4);
    &#125;
    
    /* 有参构造器。输入的值是索引层数量。该值至少应为 1 */
    public Skiplist(int level) &#123;
        if (level &lt; 1 || level &gt; 30)
            throw new RuntimeException(level == 0 ?
                    &quot;Why not choose a LinkedList?&quot; :
                    &quot;SkipList level out of range: given &quot; + level + &quot; out of range [1, 30]&quot;);
        this.level = level + 1;
        this.seed = new Random(System.currentTimeMillis());
        root = new Node(Integer.MIN_VALUE, this.level, 0);
        end = new Node(Integer.MAX_VALUE, this.level, 0);
        for (int n = 0; n &lt; this.level; n++) &#123;
            root.next[n] = end;
            end.prev[n] = root;
        &#125;
    &#125;
    
    /* 查询一个值是否存在 */
    public boolean search(int target) &#123;
        Node find = position(target);
        return find.val == target &amp;&amp; find.count &gt; 0;
    &#125;
    
    /* 搜索一个值的位置。不存在时会返回数据层中前一个节点的位置 */
    private Node position(int target) &#123;
        Node see = root;
        while (true) &#123;
            if (see.val == target) return see;
            for (int n = see.next.length - 1; ; n--) &#123;
                if (n &lt; 0) return see;
                else if (see.next[n].val &lt;= target) &#123;
                    see = see.next[n];
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
    
    /* 添加一个值 */
    public void add(int num) &#123;
        Node pos = position(num);
        if (pos.val == num) &#123;		// 如果这个节点已经建立，就仅使该节点计数增加
            pos.count++;
            return;
        &#125;
        int rand = 1 + level - Integer.toBinaryString(seed.nextInt(1 &lt;&lt; level)).length();
                    // level 的值等于总层数。seed 是一个随机数种子，nextInt(int n) 方法返回 [0, n) 的数值
                    // Integer.toBinaryString(int n) 方法是将一个数字转化成二进制表示的字符串
                    // seed.nextInt(1 &lt;&lt; level) 保证了返回值的二进制长度在 [1, level] 之间，并且概率合意
        Node add = new Node(num, rand, 1);
        for (int t = 0; t &lt; rand; ) &#123;			// 将新节点添加到链表中。
            for (; t &lt; pos.next.length &amp;&amp; t &lt; rand; t++) &#123;
                Node next = pos.next[t];
                add.next[t] = next;
                next.prev[t] = add;
                pos.next[t] = add;
                add.prev[t] = pos;
            &#125;
            pos = pos.prev[pos.prev.length - 1];
        &#125;
    &#125;
    
    /* 删除节点（的值） */
    public boolean erase(int num) &#123;
        Node pos = position(num);
        if (pos.val == num &amp;&amp; pos.count &gt; 0) &#123;
            pos.count--;
            return true;
        &#125; else return false;
    &#125;
&#125;
</code></pre>
<h2><span id="134-队列接口-queue">13.4 队列接口 Queue</span></h2><pre><code class="java">public interface Queue&lt;E&gt; extends Collection&lt;E&gt;
</code></pre>
<blockquote>
<p>Queue 是 Collection 的子接口</p>
<p>Queue 的实现子类都是队列式集合。队列是一个有序列表，可以用数组或链表来实现</p>
<p>队列遵循先入先出的原则。队列中元素是以添加顺序取出的。</p>
<p>向队列中增加元素称为<strong>入列</strong>（push），取出元素称为<strong>出列</strong>（pop）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://i-melody.github.io/img/Java_InputImage/%E9%98%9F%E5%88%97%E5%9B%BE_13.4.webp"><img src="https://i-melody.github.io/img/Java_InputImage/%E9%98%9F%E5%88%97%E5%9B%BE_13.4.webp" alt="img"></a></p>
<h3><span id="常用方法">常用方法：</span></h3><ul>
<li><p><code>add(E e)</code>：添加元素。队列满的场合抛出异常</p>
<p>  <code>put(E e)</code>：添加元素。队列满的场合可能阻塞</p>
<p>  <code>boolean offer(E e)</code>：添加元素。队列满的场合返回 false</p>
</li>
<li><p><code>E remove()</code>：移除并返回队列头部元素。队列空的场合抛出异常</p>
<p>  <code>E poll()</code>：移除并返回队列头部元素</p>
<p>  <code>E take()</code>：移除并返回队列头部元素。队列空的场合可能阻塞</p>
</li>
<li><p><code>E peek()</code>：仅返回队列头部元素。为空时返回 null</p>
<p>  <code>E element()</code>：仅返回队列头部元素。为空时抛出异常</p>
</li>
</ul>
<h3><span id="1341-优先级队列-priorityqueue">13.4.1 优先级队列 PriorityQueue</span></h3><pre><code class="java">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements java.io.Serializable
</code></pre>
<blockquote>
<p>PriorityQueue 是一个无界优先级队列。底层以数组储存元素。</p>
<p>无界队列：即没有范围限制的队列。</p>
<p>PriorityQueue 不允许 null 元素，也不允许不可比较的元素。</p>
<p>PriorityQueue 中的元素以自然顺序，或传入的比较器决定的顺序排序。其中的最小元素位于队头，最大元素位于队尾。</p>
<p>以迭代器遍历时，会按照原本的放入顺序获取元素。PriorityQueue 的源码：</p>
</blockquote>
<ol>
<li><p>底层维护了一个 Object 类型的数组 queue。用以存放元素</p>
<p> 另维护了一个比较器 comparator，用以比较元素</p>
<pre><code class="java">transient Object[] queue;
private final Comparator&lt;? super E&gt; comparator;
</code></pre>
</li>
<li><p>默认构造器初始容量为 11，比较器为 null</p>
</li>
</ol>
<pre><code class="java">也能指定初始容量，或传入比较器
public PriorityQueue() &#123;
    this(DEFAULT_INITIAL_CAPACITY, null);
&#125;

public PriorityQueue(int initialCapacity) &#123;
    this(initialCapacity, null);
&#125;

public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123;
    this(DEFAULT_INITIAL_CAPACITY, comparator);
&#125;

public PriorityQueue(int initialCapacity,
                     Comparator&lt;? super E&gt; comparator) &#123;
    if (initialCapacity &lt; 1)
        throw new IllegalArgumentException();
    this.queue = new Object[initialCapacity];
    this.comparator = comparator;
&#125;
</code></pre>
<ol start="3">
<li><p>放入时依靠比较器 comparator 进行排序。</p>
<p> 那个比较器为 null 的场合，每次放入元素会按元素自身的自然顺序进行排序。</p>
<p> 不能排序的场合会抛出异常。</p>
</li>
<li><p>扩容时，容量小于 64 的场合容量变为 2 倍 + 2。否则那个容量变为 1.5 倍</p>
<pre><code class="java">private void grow(int minCapacity) &#123;
        int oldCapacity = queue.length;
        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?
                                         (oldCapacity + 2) :
                                         (oldCapacity &gt;&gt; 1));
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        queue = Arrays.copyOf(queue, newCapacity);
    &#125;
</code></pre>
</li>
</ol>
<h3><span id="1342-阻塞队列接口-blockingqueue">13.4.2 阻塞队列接口 BlockingQueue</span></h3><pre><code class="java">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;
</code></pre>
<blockquote>
<p>BlockingQueue 是一个接口，其实现子类都是阻塞队列。</p>
<p>阻塞队列：</p>
<ul>
<li>元素入列时，那个队列已满的场合，会进行等待。直到有元素出列后，元素数量未超过队列总数时，解除阻塞状态，进而继续入列。</li>
<li>元素出列时，如果队列为空，则会进行等待。直到有元素入列时，解除阻塞状态，进而继续出列。</li>
<li>阻塞队列能防止容器溢出。只要是阻塞队列，就是线程安全的队列。</li>
<li>阻塞队列不接受 null 元素</li>
</ul>
</blockquote>
<p><strong>常用方法</strong></p>
<p>实际上，其常用方法能分为几类</p>
<table>
<thead>
<tr>
<th>队列为空&#x2F;满时…</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>等待</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>删除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>take(time, unit)</td>
</tr>
<tr>
<td>查找</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>BlockingQueue 的常用实现子类</strong></p>
<ul>
<li>ArrayBlockingQueue：底层以数组存放元素的有界阻塞队列</li>
<li>LinkedBlockingQueue：底层以链表存放元素的可选边界的阻塞队列</li>
<li>PriorityBlockingQueue：优先级阻塞队列，与 PriorityQueue 排序方式相同</li>
</ul>
<h3><span id="1343-双端队列接口-deque">13.4.3 双端队列接口 Deque</span></h3><pre><code class="java">public interface Deque&lt;E&gt; extends Queue&lt;E&gt;
</code></pre>
<blockquote>
<p>Deque 是 Queue 的子接口。</p>
<p>Deque 的实现子类都是双端队列。双端队列的两端都可以添加、删除。可见，Deque 双端队列既有队列的特性，又有栈的特性。</p>
</blockquote>
<p><strong>常用方法</strong></p>
<p>Deque 接口同样提供了一系列方法</p>
<table>
<thead>
<tr>
<th>操作的是…</th>
<th>头元素</th>
<th>尾元素</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>队列为空&#x2F;满时…</td>
<td>抛出异常</td>
<td>特殊值</td>
<td>抛出异常</td>
<td>特殊值</td>
</tr>
<tr>
<td>插入</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>odderLast(e)</td>
</tr>
<tr>
<td>删除</td>
<td>removeFirst(e)</td>
<td>pollFirst(e)</td>
<td>removeLast(e)</td>
<td>pollLast(e)</td>
</tr>
<tr>
<td>查找</td>
<td>getFirst(e)</td>
<td>peekFirst(e)</td>
<td>getLast(e)</td>
<td>peekLast(e)</td>
</tr>
</tbody></table>
<p><strong>Deque 的常用实现子类</strong></p>
<ul>
<li>LinkedList：双向链表。在 Java 中，LinkedList 也实现了 Deque 接口。</li>
<li>ArrayDeque：基于数组实现的双端队列。</li>
<li>LinkedBlockingDeque：以双向链表实现的，双端阻塞队列。该类事实上也继承了 BlockingQueue 接口。</li>
</ul>
<h2><span id="135-双列集合接口-map">13.5 双列集合接口 Map</span></h2><pre><code class="java">public interface Map&lt;K,V&gt;
</code></pre>
<p><strong>以下关于 Map 接口的描述，适用于 JDK 8 的环境</strong></p>
<blockquote>
<p>Map 与 Collection 并列存在，用于保存具有映射关系的数据：key - value（双列元素）</p>
<p>Map 的 key 和 value 可以是任何类型的引用数据类型，也能存入 null。</p>
<p>Map 的 key 不允许重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value。</p>
<p>一组 k - v 会被封装到一个 Entry 对象中。Entry 是一个内部接口。Map 的实现子类中都包含一个实现这个接口的内部类。</p>
<pre><code class="java">interface Entry&lt;K,V&gt; &#123;
    K getKey();
    V getValue();
    ...
&#125;
</code></pre>
<p>如果添加相同的 key，会覆盖原先的 key -value。等同于修改（key 不会替换，value 会被替换）</p>
</blockquote>
<h4><span id="常用方法">#常用方法：</span></h4><ul>
<li><p><code>put()</code>：添加。已存在的场合，实行替换。（key 不替换，value 替换）</p>
</li>
<li><p><code>remove()</code>：根据键删除映射关系</p>
</li>
<li><p><code>get()</code>：根据键获取值</p>
</li>
<li><p><code>size()</code>：元素个数</p>
</li>
<li><p><code>isEmpty()</code>：判断个数是否为 0</p>
</li>
<li><p><code>clear()</code>：清空</p>
</li>
<li><p><code>containsKey()</code>：查找键是否存在</p>
</li>
<li><p><code>Set&lt;K&gt; keySet()</code>：获取所有 键 构成的集合</p>
<p>  <code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取所有 Entry 构成的集合</p>
<p>  <code>Collection&lt;V&gt; values()</code>：获取所有 值 构成的集合</p>
</li>
</ul>
<h4><span id="map-接口遍历元素">#Map 接口遍历元素：</span></h4><blockquote>
<p>Set接收单独获取key，Collection接收单独获取value，Set&lt;Map.Entry&lt;K,V&gt;&gt;获取key和value。</p>
</blockquote>
<ul>
<li><p><strong>方法一</strong>：利用 <code>Set&lt;K&gt; keySet()</code> 方法</p>
<p>先得到所有 keys，再遍历 keys，根据每个 key 获得 value：</p>
<pre><code class="java">Set&lt;String&gt; keyset = map.keySet();//返回的是Set的方法，代表获取key值，具体类型可以根据泛型指定
for (String o : keyset) &#123;
    System.out.println(o + &quot; = &quot; + map.get(o));
&#125;
</code></pre>
</li>
<li><p><strong>方法二</strong>：利用 <code>Set&lt;V&gt; values()</code> 方法</p>
<p>直接把所有 values 取出，之后遍历 values</p>
<pre><code class="java">直接把所有 values 取出，之后遍历 values

Collection values = map.values();//values是返回connection的方法，代表获取values值，在这里不能用泛型，因为确认了返回的是connection类型
for (Object value : values) &#123;
    System.out.println(value);
&#125;
</code></pre>
</li>
<li><p>&#x3D;&#x3D;<strong>方法三</strong>：利用 <code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 方法（K和V都可以取到）&#x3D;&#x3D;</p>
</li>
</ul>
<p>&#x2F;&#x2F;通过获取 entrySet（是Map接口的内部接口） 来获取 k - v<br>entrySet方法：</p>
<pre><code class="java">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()&#123;...&#125;
</code></pre>
<p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310120814602.png" alt="image-20231007210521367"></p>
<p>Node实现了Map.Entry接口，可以获取到Node中的k-v值，一个k-v对应一个Node。&#x3D;&#x3D;(注意此接口Entry不是LinkedHashMap的内部类Entry)&#x3D;&#x3D;</p>
<pre><code class="java">Set&lt;Map.Entry&gt; entrySet = map.entrySet();//Entry是Map的内部接口。而HashMap$Node实现了Entry接口。（static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; ）所以有获取k-v的方法。
for (Map.Entry e : entrySet) &#123;
    System.out.println(e.getKey() + &quot; - &quot; + e.getValue());
&#125;
</code></pre>
<h5><span id="x3dx3d迭代器完成遍历x3dx3d">&#x3D;&#x3D;迭代器完成遍历&#x3D;&#x3D;</span></h5><pre><code class="java">/*1.只对key遍历,也可以同时对value遍历
  Set keys = map.keySet();
Iterator iterator = keys.iterator();*/
while (iterator.hasNext()) &#123;
    Object key = iterator.next();
    Object value = map.get(key);	
    System.out.println(key+&quot;=&quot;+value));
&#125;

/*2.只对values遍历
  Collection values = map.values();
  Iterator iterator = values.iterator();*/

while (iterator.hasNext()) &#123;
    Object next =  iterator.next();
    System.out.println(next);
&#125;

/*3.对key和value遍历
  Set&lt;Map.Entry&gt; kv = map.entrySet();
  Iterator iterator = kv.iterator();*/
while (iterator.hasNext()) &#123;
            Map.Entry next = iterator.next();
              list.add(next.getValue());
        &#125;
//果是传入的是对象，要调用对象的方法就转化为Map.Entry类型。
</code></pre>
<p>题目：显示工资大于18000的员工信息。</p>
<blockquote>
<p>引入泛型后可以省去向下转型的操作</p>
</blockquote>
<pre><code class="java">map.put(1, tom);
map.put(2 jack);
map.put(3, frank);
//方法1，迭代器遍历
Set&lt;Map.Entry&gt; entrySet = map.entrySet();
Iterator iterator = entrySet.iterator();
while (iterator.hasNext()) &#123;
    Object next = iterator.next();
    Map.Entry e = (Map.Entry) next;
    Staff stif = (Staff) e.getValue();
    if(stif.getSal()&gt;18000) &#123;
         while (iterator.hasNext()) &#123;
           Map.Entry  next = (Map.Entry)iterator.next();//直接向下转型，返回的是map中作为Object类型的键值对。所以可以直接转型,引入泛型后可以直接合并为一句(Map.Entry&lt;Intager,Staff&gt; staff = )	
            Staff staff = (Staff) next.getValue();
            if(staff.getSal()&gt;18000) &#123;
                System.out.println(staff);
            &#125;
        &#125;
        &#125;
//方式2，增强for循环遍历
        Set keys = map.keySet();
        for (Object key:
             keys) &#123;
          Staff v =  (Staff) map.get(key);
            if(v.getSal()&gt;18000)
            System.out.println(v);
        &#125;
stem.out.println(next);
    &#125;
&#125;
</code></pre>
<h3><span id="x3dx3d1351-散列表-hashmapx3dx3d">&#x3D;&#x3D;13.5.1 散列表 HashMap&#x3D;&#x3D;</span></h3><pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable
</code></pre>
<blockquote>
<p>HashMap 是 Map 接口使用频率最高的实现类。是根据关键码值（key value）而进行直接访问的数据结构。通过将关键码值映射到表中一个位置来访问记录，以加快查找速度。</p>
<p>那个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）</p>
<p>HashMap 是以 k - v 对得到方式来存储数据。&#x3D;&#x3D;一组数据会被封装到一个 Node 对象中。&#x3D;&#x3D;</p>
<pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
 final int hash;
 final K key;
 V value;
 Node&lt;K,V&gt; next;
...
 &#125;
</code></pre>
<p>JDK 7 前，HashMap 底层是 数组 + 链表。JDK 8 后，底层是 数组 + 链表 + 红黑树。HashMap 不保证映射的顺序。</p>
<p>&#x3D;&#x3D;HashMap 没有实现同步（没有 synchronized），是线程不安全的&#x3D;&#x3D;</p>
</blockquote>
<h4><span id="hashmap-的源码">#HashMap 的源码：</span></h4><ol>
<li><p>HashMap 底层维护(指的是对数据的增删改查等操作)了 Node 类型的数组 table。默认为 null</p>
<pre><code class="java">transient Node&lt;K,V&gt;[] table;
</code></pre>
<p> 另外，还有集合 values、keySet、enrtySet。<strong>这些集合能帮助程序员进行遍历</strong></p>
<pre><code class="java">transient Set&lt;K&gt;				keySet;
transient Collection&lt;V&gt;			values;
transient Set&lt;Map.Entry&lt;K,V&gt;&gt;	entrySet;
</code></pre>
</li>
<li><p>创建对象时，默认构造器将加载因子（loadfactor）初始化为 0.75。</p>
<p> 也能指定那些初始容量和加载因子。</p>
<p> 默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。</p>
<pre><code class="java">static final float DEFAULT_LOAD_FACTOR = 0.75f;
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
</code></pre>
</li>
</ol>
<p>​	</p>
<pre><code class="java">
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR;					// 这个默认构造的场合，其他参数都是默认值
    &#125;
    
</code></pre>
<pre><code class="java">public HashMap(int initialCapacity) &#123;
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
&#125;

public HashMap(int initialCapacity, float loadFactor) &#123;
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(...);
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(...);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
&#125;
```
</code></pre>
<ol start="3">
<li><p>添加时容量不够的场合，需要扩容。</p>
<p> 默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。</p>
<p> 扩容的场合，容量变为 2 倍。临界值相应变化。</p>
<p> 临界值不会超过那个指定的 MAXIMUM_CAPACITY（1 &lt;&lt; 30），否则变成 Integer.MAX_VALUE。</p>
<p> JDK 8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认是 8），并且 <code>table</code> 的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认 64），会进行树化。</p>
<p> &#x3D;&#x3D;剪枝：红黑树的元素减少到一定程度，会被重新转化为 链表&#x3D;&#x3D;</p>
<pre><code class="java">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;

final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;								// &lt;- 旧的数据数组 table
    int oldCap = (oldTab == null) ? 0 : oldTab.length;		// &lt;- 旧的 table 的容量
    int oldThr = threshold;									// &lt;- 旧的临界值
    int newCap, newThr = 0;									// &lt;- 新的容量、临界值
    
    /* 旧的数组不为空时，
        如果容量已达指定的 MAXIMUM_CAPACITY，则不扩容
        否则扩容为 2 倍容量，临界值也变为 2 倍 */
    if (oldCap &gt; 0) &#123;
        newCap = oldCap &lt;&lt; 1;
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        else if (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1;
    &#125;
    /* 旧的数组为空，但临界值已被指定（原因是：指定构造器传入初始容量为 0） */
    else if (oldThr &gt; 0)
        newCap = oldThr;
    /* 旧的数组为空，临界值为 0（原因是：使用默认构造器）
        默认构造器初始化容量为 16，默认临界因子为 0.75f */
    else &#123;
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    
    /* 到这里，newThr（新临界值）为 0 的原因可能是：
        1. 旧容量小于那个最小容量（16）
        2. 扩容后容量大于那个最大容量
        3. 旧的临界值为 0 或 Integer.MIN_VALUE
        4. 构造器传入初始容量为 0 */
    if (newThr == 0) &#123;
        /* 按照 新容量 * 临界因子 的方法计算临界值。临界值不会超过一个指定的最大值 */
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold = newThr;
    
    /* 确定了容量和临界值，下面把旧数组元素移至新数组。
        那个移动的场合，会以新容量重新计算所有元素的下标位置 */
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) &#123;
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123;
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next = e.next;
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
</li>
<li><p>添加 k - v 时，通过 key 的哈希值得到其在 table 的索引，判断索引位置是否被占用。</p>
<p> 未占用的场合，直接添加。</p>
<p> 占用的场合，判断其 key 是否相等。相等的场合，替换 value。否则，按照 树 或 链表 的方式处理。</p>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;
</code></pre>
</li>
</ol>
<p>​	<br>​	&#x2F;* 会先对放入元素的哈希值进行一次计算，得到一个数字：hash *&#x2F;<br>​	static final int hash(Object key) {<br>​	    int h &#x3D; key.hashCode();<br>​	    return (key &#x3D;&#x3D; null) ? 0 : (h ^ (h &gt;&gt;&gt; 16));	&#x2F;&#x2F; 位运算符：&gt;&gt;&gt; 无符号右移<br>​	}</p>
<p>​	<br>​	&#x2F;* put 方法会调用该 putVal 方法。<br>​		那些传入值是：	hash、	key、	value、			false、				true *&#x2F;<br>​	final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {<br>​	    Node&lt;K,V&gt;[] tab &#x3D; table; 		&#x2F;&#x2F; &lt;- 是那个存放数据的 table 数组<br>​	    int n;							&#x2F;&#x2F; &lt;- 是 table.length<br>​	    </p>
<pre><code class="java">    /* 如果原先的 table 为空，则对其重新分配空间 */
    if (tab == null || (n = tab.length) == 0) &#123;
        tab = resize();
        n = tab.length;
    &#125;
    
    /* 用方才计算的 hash 数，得到要放入元素的下标值 i
        n - 1 是数据数组的最大下标，(n - 1) &amp; hash 必定不大于 n - 1 */
    int i = (n - 1) &amp; hash;			// 位运算符：&amp; 按位与
    Node&lt;K,V&gt; p = tab[i];			// 得到 table 中，位于那个插入位置的元素
</code></pre>
<pre><code class="java">        
        /* 倘若该位置为空，则直接放入 */
        if (p == null) &#123;
            tab[i] = newNode(hash, key, value, null);
        &#125;
        /* 该位置不为空，意味着可能添加了重复元素 */
        else &#123;
            Node&lt;K,V&gt; e; 			// &lt;- 被发现重复的那个 Node。无重复时结果为 null。这个 Node 的 value 会被替换。
            K k = p.key;			// &lt;- 当前取出进行比较的 key 值
</code></pre>
<p>​	        </p>
<pre><code class="java">        /* 为了验证其是否重复，这里要进行如下比较：
            1. 比较两者的 hash 数。不同的场合是不同元素
            2. 使用 == 和 equals 两种方法比较 key。不同的场合是不同元素 
            如果是相同元素，则该节点的值会被替换 */
        if (p.hash == hash &amp;&amp; (k  == key || (key != null &amp;&amp; key.equals(k)))) &#123;
            e = p;
        &#125;
        
        /* 此处节点结构是 树 的场合，还需遍历比较树的每个节点 */
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        
        /* 此处节点结构是 链表 的场合，还需遍历比较每个链表节点 */
        else &#123;
            for (int binCount = 0; ; ++binCount) &#123;
                e = p.next;
                /* e == null 意味着遍历结束，全部不同。这样，在此处添加那个新的 Node */
                if (e == null) &#123;
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                &#125;
                /* 故技重施，如果发现相同，则替换那个新元素 */
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;
                    break;
                &#125;
                p = e;
            &#125;
        &#125;
        
        /* 经历上述比较后，e != null 意味着有元素要被替换了 */
        if (e != null) &#123;
            V oldValue = e.value;
            /* 传入的参数 onluIfAbsent == false，所以此处一定是 true */
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);		// &lt;- HashMap 中，该方法为空实现。
            return oldValue;
        &#125;
    &#125;
    ++modCount;
    
    /* 如果到达这里，说明添加了元素（而非替换），要查看大小是否超过临界值 */
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);		// &lt;- HashMap 中，该方法为空实现。
    return null;
&#125;
</code></pre>
<pre><code class="java">
    /* 上面提到的一些空实现的方法 */
    void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;
    void afterNodeInsertion(boolean evict) &#123; &#125;
    void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;
</code></pre>
<h3><span id="x3dx3d1352-散列表-hashtablex3dx3d">&#x3D;&#x3D;13.5.2 散列表 Hashtable&#x3D;&#x3D;</span></h3><pre><code class="java">public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable
</code></pre>
<blockquote>
<p>Hashtable 和 HashMap 基本一致，但Hashtable <strong>是线程安全的</strong> 。但也因为如此，Hashtable 的效率低下。</p>
</blockquote>
<h4><span id="hashtable-与-hashmap-的比较">#Hashtable 与 HashMap 的比较：</span></h4><table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>线程安全（同步）</th>
<th>效率</th>
<th>是否允许 null值</th>
</tr>
</thead>
<tbody><tr>
<td>Hashtable</td>
<td>1.0</td>
<td>安全</td>
<td>较低</td>
<td>不允许</td>
</tr>
<tr>
<td>HashMap</td>
<td>1.2</td>
<td>不安全</td>
<td>高</td>
<td>允许</td>
</tr>
</tbody></table>
<ul>
<li><p>Hashtable 底层也是有数组(&#x3D;&#x3D;Entry，但不是继承自Node的，和LinkedHashMap中的Entry无关)&#x3D;&#x3D;，默认构造器的初始容量为 11。临界值是 11 * 0.75 &#x3D; 8。</p>
</li>
<li><p>扩容大致如下：</p>
<pre><code class="java">int newCapacity = (oldCapacity &lt;&lt; 1) + 1;			//即，原容量 * 2 + 1
</code></pre>
</li>
<li><p>Hashtable 不会树化</p>
</li>
</ul>
<h4><span id="x3dx3dentry-node和mapentryx3dx3d">&#x3D;&#x3D;Entry、Node和Map.Entry&#x3D;&#x3D;</span></h4><p> 在HashMap中，Node是内部类，表示HashMap的一个节点，用于存储键值对。Node没有继承关系，它实现了Map.Entry接口。</p>
<p>在<strong>LinkedHashMap</strong>中，<strong>Entry</strong>是一个内部类，用于存储键值对，同时它继承自<strong>HashMap</strong>中的<strong>Node</strong>类。这是为了在LinkedHashMap中实现<strong>有序性</strong>而继承了Node。</p>
<p><strong>Entry</strong>表示键值对的条目。然而，Map.Entry是一个接口，它是Java标准库中用于表示键值对的接口，<u>而Entry只是HashMap和LinkedHashMap内部用来实现这个接口的类。</u></p>
<h4><span id="重写hashcode和equal方法">重写hashCode和equal方法</span></h4><p>我们看HashMap源码的主干可以看出，首先查询哈希表的表头位置，if为空直接创建节点赋值，不为空就是else里的三种情况。无非就是我们要插入的key值是否和表头相等，相等直接替换，<u>不相等看表头是链表还是已经树化</u>，按照不同方式处理。按照这个逻辑，我们就可以研究比较hash的作用是什么，首先我们了解一个逻辑式即：&#x3D;&#x3D;key相等-&gt;hash值相同&#x3D;&#x3D;（&#x3D;&#x3D;需要我们自己重写hashcode实现，注意只有hash值是相同的才有可能在同一数组位置形成链表&#x3D;&#x3D;）而如果他满足hash相等的条件后，我们此时无法确定key值是否相等，因为hash相等只是一个必要条件，接着判断key值相等就行，这样就极大的提高性能,类比生活的话，就是班长肯定要在班干部里面选，所以我们可以先判断他是不是班干部，而不是一上来直接按照班长的所有符合条件去判断班里每个人</p>
<pre><code class="java">public class HashSetExercise &#123;
    public static void main(String[] args) &#123;
        Set set = new HashSet();
        set.add(new Employee(&quot;jack&quot;,16));
        set.add(new Employee(&quot;tom&quot;,23));
        set.add(new Employee(&quot;frank&quot;,22));
        set.add(new Employee(&quot;frank&quot;,22));
        Iterator iterator = set.iterator();
        while (iterator.hasNext()) &#123;
            Object next =  iterator.next();
            System.out.println(next);
        &#125;
    &#125;
&#125;

class Employee&#123;
    private String name;
    private int age;

    public Employee(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return age == employee.age &amp;&amp; Objects.equals(name, employee.name);
    &#125;
    
    @Override
    public int hashCode() &#123;
        return Objects.hash(name, age);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>equals方法主要针对的是在table能否插入一个属性相同的对象，通常和hashcode一起重写。String类已经重写了equals方法，所以当</p>
<pre><code class="java">hashset.add(new String(&quot;hello&quot;));
hashset.add(new String(&quot;hello&quot;));
</code></pre>
<p>的时根据不能有相同元素的原则，所以只会存入一个“hello”，而重写其他类的equals也和String类的equals方法大同小异，同样是为了数据不重复。</p>
<h3><span id="1353-红黑树-treemap">13.5.3 红黑树 TreeMap</span></h3><pre><code class="java">public class TreeMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
</code></pre>
<blockquote>
<p>TreeMap 实现了 Map 接口。底层使用 红黑树 存储数据。</p>
<p>相较数组（访问快，检索、插入慢）和链表（插入快，检索、访问慢），树形数据结构（如二叉排序树）在保证数据检索速度的同时，也能保证数据插入、删除、修改的速度</p>
</blockquote>
<p><em><strong>——见 [[14.1.4.1 平衡二叉树]](<a target="_blank" rel="noopener" href="https://i-melody.github.io/2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14">https://i-melody.github.io/2022/06/02/Java/入门阶段/14</a> 树&#x2F;#14-1-4-1-平衡二叉树)</strong></em></p>
<h4><span id="treemap-的源码">#TreeMap 的源码：</span></h4><ol>
<li>TreeMap 底层维护了一个二叉树，以及一个比较器</li>
</ol>
<pre><code class="java">private final Comparator&lt;? super K&gt; comparator;

private transient Entry&lt;K,V&gt; root;
</code></pre>
<ol start="2">
<li>创建对象时，能采用无参构造，也能指定比较器完成构造</li>
</ol>
<p>  那个无参构造的场合，比较器为空。</p>
<pre><code class="java">public TreeMap() &#123;
    comparator = null;
&#125;

public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
    this.comparator = comparator;
&#125;
</code></pre>
<p>  比较器如果为空，则&#x3D;&#x3D;要求<strong>传入的 key</strong> 必须是 Comparable 接口的实现子类&#x3D;&#x3D;，否则无法进行比较。</p>
<pre><code class="java">final int compare(Object k1, Object k2) &#123;
    return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
&#125;
</code></pre>
<ol start="3">
<li>添加时，通过&#x3D;&#x3D;比较器(Comparator)&#x3D;&#x3D;确定那个添加位置，这一点类似于Map实现类利用equals方法来比较。&#x3D;&#x3D;<strong>如果key相等</strong>，会将原来key对应的值(value)给替换;&#x3D;&#x3D;</li>
</ol>
<pre><code class="java">public V put(K key, V value) &#123;
    Entry&lt;K,V&gt; t = root;	// &lt;- 树的根节点
    
    /* 二叉树为空的场合，创建根节点，将数据放入 */
    if (t == null) &#123;
        compare(key, key);
        root = new Entry&lt;&gt;(key, value, null);
        size = 1;
        modCount++;
        return null;
    &#125;
    
    int cmp;				// &lt;- 临时值，存放比较结果
    Entry&lt;K,V&gt; parent;		// &lt;- 临时值，存放父节点
    Comparator&lt;? super K&gt; cpr = comparator;		// &lt;- 比较器
    
    /* 有比较器的场合，按照这个方法进行比较 */
    if (cpr != null) &#123;
        do &#123;
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value);
        &#125; while (t != null);
    &#125;
    
    /* 比较器为空的场合，按照这个方法进行比较 */
    else &#123;
        if (key == null) &#123;
            throw new NullPointerException();
        &#125;
        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
        do &#123;
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value);
        &#125; while (t != null);
    &#125;
    
    /* 将数据节点放到正确的路径下 */
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
    if (cmp &lt; 0)
        parent.left = e;
    else
        parent.right = e;
    
    /* 此处会试着将该树转换成完全二叉树 */
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
&#125;
</code></pre>
<ol>
<li>添加的最后，会试着将该树转换成完全二叉树</li>
</ol>
<pre><code class="java">private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123;
    x.color = RED;

    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;
            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) &#123;
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            &#125; else &#123;
                if (x == rightOf(parentOf(x))) &#123;
                    x = parentOf(x);
                    rotateLeft(x);
                &#125;
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            &#125;
        &#125; else &#123;
            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) &#123;
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            &#125; else &#123;
                if (x == leftOf(parentOf(x))) &#123;
                    x = parentOf(x);
                    rotateRight(x);
                &#125;
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            &#125;
        &#125;
    &#125;
    root.color = BLACK;
&#125;
</code></pre>
<h3><span id="1354-properties">13.5.4 Properties</span></h3><blockquote>
<p>Properties 继承自 Hashtable 并实现了 Map 接口。也使用键值对的方式保存数据</p>
<p>Properties 使用特点与 <strong>Hashtable</strong> 相似</p>
<p>Properties 还可以用于 xxx.properties 文件中，加载数据到 Properties 对象，进行读取和修改</p>
<p>xxx.properties 文件常作为配置文件</p>
</blockquote>
<pre><code class="java">public class Properties extends Hashtable&lt;Object,Object&gt;
</code></pre>
<p><em><strong>——关于这些，详见 [[17 IO流 ]](<a target="_blank" rel="noopener" href="https://i-melody.github.io/2022/01/06/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/17">https://i-melody.github.io/2022/01/06/Java/入门阶段/17</a> IO流&#x2F;)</strong></em></p>
<ul>
<li><p><code>String getProperty(String key)</code> ：输入一个 String 类型的 key，返回一个 String 的 value</p>
<pre><code class="java">public String getProperty(String key) &#123;
Object oval = super.get(key);
String sval = (oval instanceof String) ? (String)oval : null;
return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval;
&#125;
</code></pre>
</li>
</ul>
<h2><span id="136-无序集合接口-set">13.6 无序集合接口 Set</span></h2><blockquote>
<p>Set 是 Collection 接口的子类接口。</p>
<p>Set 接口的特点是无序（添加和取出顺序不一致，其取出顺序由某个算法决定），没有索引</p>
<p>不允许重复元素。故而，最多包含一个 null</p>
</blockquote>
<pre><code class="java">public interface Set&lt;E&gt; extends Collection&lt;E&gt;
</code></pre>
<h3><span id="1361-hashset">13.6.1 HashSet</span></h3><pre><code class="java">public class HashSet&lt;E&gt;
    extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre>
<blockquote>
<p>HashSet 实现了 Set 接口。底层实际上使用 HashMap 来存储数据。<del>身在 Collection 心在 Map</del></p>
<p>HashSet 是无序的。其实际顺序取决于计算得到的 hash 值</p>
</blockquote>
<h4><span id="hashset-的源码">#HashSet 的源码</span></h4><ol>
<li><p>HashSet 底层是 HashMap。</p>
<pre><code class="java">private transient HashMap&lt;E,Object&gt; map;
</code></pre>
</li>
<li><p>实例化也和 HashMap 相同</p>
<pre><code class="java">public HashSet() &#123;
    map = new HashMap&lt;&gt;();
&#125;

public HashSet(int initialCapacity) &#123;
    map = new HashMap&lt;&gt;(initialCapacity);
&#125;

public HashSet(int initialCapacity, float loadFactor) &#123;
    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);
&#125;
</code></pre>
</li>
<li><p>添加一个元素时调用 HashMap 的方法</p>
<pre><code class="java">public boolean add(E e) &#123;
    return map.put(e, PRESENT)==null;
&#125;
</code></pre>
</li>
</ol>
<h3><span id="1362-linkedhashset">13.6.2 LinkedHashSet</span></h3><blockquote>
<p>LinkedHashSet 是 HashSet 的子类</p>
<p>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + 双向链表。<del>有其父必有其子</del></p>
<p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p>
</blockquote>
<pre><code class="java">public class LinkedHashSet&lt;E&gt;
    extends HashSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre>
<h4><span id="linkedhashset-的源码">#LinkedHashSet 的源码：</span></h4><ol>
<li><p>在类 HashSet 中，存在一个默认访问范围的构造器。该构造器不同于其他构造器，会让实例维护一个 LinkedHashMap</p>
<pre><code class="java">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;
    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
&#125;
</code></pre>
<p> LinkedHashSet 的构造器即调用了该父类构造器</p>
<pre><code class="java">public LinkedHashSet(int initialCapacity, float loadFactor) &#123;
    super(initialCapacity, loadFactor, true);
&#125;

public LinkedHashSet(int initialCapacity) &#123;
    super(initialCapacity, .75f, true);
&#125;

public LinkedHashSet() &#123;
    super(16, .75f, true);
&#125;
</code></pre>
</li>
</ol>
<h3><span id="1363-treeset">13.6.3 TreeSet</span></h3><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;
    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre>
<blockquote>
<p>TreeSet 实现了 Set 接口，其底层是一个 TreeMap。<del>好家伙，原来 Set 全家都是卧底</del></p>
<p>调用无参构造器创建 TreeSet 时，&#x3D;&#x3D;默认是无序排列&#x3D;&#x3D;。也能在构造时传入一个比较器(Comparator)来完成排序的策略。有比较器的场合，&#x3D;&#x3D;比较器返回 0 时，加入不了，没有替换&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;不传入比较器的场合，使用的是传入对象自带的比较器&#x3D;&#x3D;。如果不传入，则要求&#x3D;&#x3D;传入的 key 对象<strong>必须</strong>是 Comparable 接口的实现子类&#x3D;&#x3D;，否则会抛出ClassCastException异常</p>
</blockquote>
<p>—&gt;因为只有实现Comparable接口才能在compare方法内部使用compareTo方法，例如下方代码比较字符串长度可以改为<code>return ((Integer)((String) o1).length()).compareTo(((Integer)((String) o2).length()));</code>，因为int类型没有实现Compare接口，而Integer实现了才能使用,转为包装类型就可以了。</p>
<pre><code class="java">TreeSet treeSet = new TreeSet(new Comparator() &#123;
    @Override
    public int compare(Object o1, Object o2) &#123;
        /*按字符串比较，
         如果大小相等就加不进去*/
        // return ((String) o1).compareTo((String)o2);
        /*按字符串长度比较，
        如果按照长度，当增加同样长度的字符串是不会添加进去的*/
        return ((String) o1).length() - ((String) o2).length();

    &#125;
&#125;);
treeSet.add(&quot;hello&quot;);
treeSet.add(&quot;java&quot;);
treeSet.add(&quot;php&quot;);
treeSet.add(&quot;java&quot;);//字符串大小相等，加不进去。
                    //如果采用长度比较策略，只会加入同一长度字符串一次，后续加不进去
System.out.println(treeSet);
</code></pre>
<h2><span id="137-集合的选择">13.7 集合的选择</span></h2><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行分析选择。</p>
<p>判断存储的类型（一组对象 [单列]，或一组键值对 [双列]）</p>
<ul>
<li>一组对象：Collection 接口<ul>
<li>允许重复：List<ul>
<li>增删多：<code>LinkedList</code> （双向链表）</li>
<li>改查多：ArrayList （<code>Object[]</code> 数组）</li>
</ul>
</li>
<li>不允许重复：Set<ul>
<li>无序：HashSet （数组 + 链表 + 红黑树，底层是 HashMap）</li>
<li>排序：<code>TreeSet</code></li>
<li>顺序一致：LinkedHashSet （数组 + 双向链表，底层是 <code>LinkedHashMap</code>）</li>
</ul>
</li>
</ul>
</li>
<li>一组键值对：Map<ul>
<li>键无序：HashMap （底层是：哈希表 jdk7是数组+链表，接着是数组 + 链表 + <strong>红黑树</strong> [ JDK 8 以后 ] ）</li>
<li>键排序：<code>TreeMap</code></li>
<li>键顺序一致：<code>LinkedHashMap</code> （底层是 HashMap）</li>
<li>读取文件：Properties</li>
</ul>
</li>
</ul>
<h2><span id="138-工具类-collections">13.8 工具类 Collections</span></h2><blockquote>
<p>Collections 工具类是一个操作 &#x3D;&#x3D;Set、List、Map&#x3D;&#x3D; 等集合的工具类</p>
<p>其中提供了一系列静态方法，对集合元素进行 排序、查询和修改等操作</p>
</blockquote>
<h4><span id="常用方法">常用方法：</span></h4><p><strong>排序：</strong></p>
<ul>
<li><code>reverse(List)</code>：反转 List 中元素的排序</li>
<li><code>shuffle(List)</code>：对 <code>List </code>中元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素升序排列</li>
<li>&#x3D;&#x3D;<code>reverse(List, Comparator)</code>：根据指定 Comparator 对 List 排序&#x3D;&#x3D;</li>
<li><code>swap(List, int, int)</code>：将两处元素位置互换</li>
</ul>
<p><strong>查找、替换：</strong></p>
<ul>
<li><p><code>Object max(Collection)</code>：根据元素的自然排序，返回集合中最大的元素</p>
</li>
<li><p><code>Object max(Collection, Comparator)</code>：根据比较器，返回最大元素</p>
</li>
<li><p><code>Object min(Collection)</code>：根据元素的自然排序，返回最小元素</p>
</li>
<li><p><code>Object min(Collection, Comparator)</code>：根据比较器，返回最小元素</p>
</li>
<li><p><code>int frequency(Collection, Object)</code>：返回集合中指定元素的出现次数</p>
</li>
<li><p><code>void copy(List dest, List src)</code>：将 src 的内容复制到 dest 中</p>
<p>  这个场合，&#x3D;&#x3D;要保证 dest 的大小不小于 src。所以，可能需要先给 dest 赋值&#x3D;&#x3D;</p>
</li>
<li><p><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：用 newVal 替换所有 oldVal 值</p>
</li>
</ul>
<h2><span id="139-junit">13.9 JUnit</span></h2><blockquote>
<p>&#x3D;&#x3D;不能在提供了有参构造器的类的方法上使用，如果方法有参数也不行。&#x3D;&#x3D;</p>
<p>每个方法写一个单独的测试方法，这样可以避免反复撤销的操作。</p>
<pre><code class="java">@Test
 public void testlist() &#123; &#125;
@Test
 public void testdelete()&#123; &#125;
 @Test
 public void testupdate()&#123;&#125;
</code></pre>
<blockquote>
<p>一个类有多个功能代码需要测试，为了测试，就要写入 <code>main</code> 方法中</p>
<p>如果有多个功能代码测试，需要反复撤销，过程繁琐</p>
</blockquote>
<blockquote>
<p>JUnit 是一个 Java 语言单元测试框架</p>
<p>多数 Java 开发环境都已集成了 JUnit 作为单元测试工具</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fh411y7R8?p=566&t=259.3">使用方法</a></p>
<p>……总的来讲，方法就是加入 <code>@Test</code>，然后 <code>alt + enter</code> 引入 JUnit 5，最后运行</p>
</blockquote>
</blockquote>
<h2><span id="本章作业">本章作业</span></h2><h3><span id="x3dx3d1试分析hashset和treeset分别是如何实现去重的x3dx3d">&#x3D;&#x3D;1.试分析HashSet和TreeSet分别是如何实现去重的&#x3D;&#x3D;</span></h3><ol>
<li>HashSet的去重机制：hashCode()+equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引的位置没有数据，就直接存放，如果有元素就进行equals(存入对象的equals方法，需要程序员重写)的比较【遍历比较】，如果比较后，不相同就加入，否则不加入。</li>
<li>TreeSet的去重机制：如果传入了一个Comparator匿名对象后，就使用实现的compare去重，如果方法返回0，就认为是相同的元素&#x2F;数据，就不添加，&#x3D;&#x3D;如果你没有传入一个Comparator匿名对象，则认为添加的对象实现的Comparable接口的compareTo去重&#x3D;&#x3D;。</li>
</ol>
<h3><span id="在treeset传入一个对象自定义的对象时如果它没有实现comparable接口那么当treesetadd对象的时候会抛出classcastexception的异常">在TreeSet传入一个对象(自定义的对象)时，如果它没有实现Comparable接口，那么当treeset.add(对象)的时候会抛出ClassCastException的异常。</span></h3><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310090846619.png" alt="image-20231009084651414"></p>
<p>add时存放的p1hash值和经过修改属性后的hash值已经不是同一个了，数值还是存放在原p1中，&#x3D;&#x3D;绕不出去的问题在于p1.name&#x3D;CC之后其实此时占用的是AA的哈希位置，所以添加进去的CC经过哈希之后不可能在原来AA的位置&#x3D;&#x3D;</p>
<p>new Person(new Person(1001,”AA”))可以加进去是因为原来的位置被占了，但是由于内容被改了，所以可以加在同一位置的后面。</p>
<p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310090912580.png" alt="image-20231009091217504"></p>
<h1><span id="面试题">面试题</span></h1><h3><span id="hashset的元素不能重复">HashSet的元素不能重复</span></h3><ol>
<li><pre><code class="java">
 Set set = new HashSet();
 set.add(&quot;tom&quot;);
 set.add(&quot;tom&quot;);//添加不了，重复了
</code></pre>
</li>
<li><pre><code class="java">
 set.add(new Dog(&quot;tom&quot;));
 set.add(new Dog(&quot;tom&quot;));//可以添加，并不是一个元素
</code></pre>
</li>
<li><pre><code class="java"> 
 set.add(new String(&quot;tom&quot;));
 set.add(new String(&quot;tom&quot;))//不能添加
</code></pre>
<blockquote>
<p>第3点与<a href="####HashMap%E6%BA%90%E7%A0%81%EF%BC%9A">HashMap的底层源码</a>有关，在底层HashSet在一个数组里添加元素时会调用equals方法，如果目标索引处已经有了一个元素，那么将会调用这个equals方法（需要自己重写实现，不能单纯理解比较的是内容，每一个类都有相应的equals方法）决定能不能放进去，而String类重写了自己的equals方法，它比较的是内容，如果没有重写equals方法比较的是地址，也就是相当于“&#x3D;&#x3D;”；相同就会放弃相加，如果不相同就在当前元素位置的链表的下一个结点。</p>
</blockquote>
</li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
	
</script>



<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
  var now = new Date(); 
  function createtime() { 
    var grt= new Date("03/08/2020 16:44:00");//此处修改你的建站时间或者网站上线时间 
    now.setTime(now.getTime()+250); 
    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
    document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
  } 
  setInterval("createtime()",250);
</script>


<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>














<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<div class="aplayer"

    data-id="9126522781"

    data-server="netease"

    data-type="playlist"

    data-fixed="true"

    data-autoplay="false"

    data-loop="all"

    data-order="random"

    data-preload="auto"

    data-volume="0.7"

    data-mutex="true"

>
</div>
<script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>

<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>

<script>
(function() {

  var arr = new Array();
  var $tags = $('.post-tags').children('a');
  $tags.each(function() {
    arr.push($(this).html())
  })
  if (arr.indexOf("图集") !== -1) {

    $('.hj_img').each(function() {
      $(this).wrap('<a class="fancybox" data-fancybox="gallery" href="' + $(this).prop("src") + '"></a>'); 
    })
    //初始化fancybox，padding设为0，loop设为false
    $('.fancybox').fancybox({
      padding: 0,
      loop: false
    });
  }
})();
</script>

<!-- // 文字 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js"></script>
<!-- // 爱心 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js"></script>
<!-- // 按键屏蔽 需要jQuery -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/noSomeKey.js"></script>


</html>
