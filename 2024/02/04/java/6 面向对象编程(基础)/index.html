<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mysql | HatidaBlog</title>
  <meta name="keywords" content=" java ">
  <meta name="description" content="mysql | HatidaBlog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="第4章 检索数据4.5 检索不同的行DISTINCT关键字：此关键字指示MySQL只返回不同的值。  不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。 相当于将distinct后面的列放在一起作为条件  4.6 限制结果-limit关键">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql必知必会">
<meta property="og:url" content="http://example.com/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html">
<meta property="og:site_name" content="HatidaBlog">
<meta property="og:description" content="第4章 检索数据4.5 检索不同的行DISTINCT关键字：此关键字指示MySQL只返回不同的值。  不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。 相当于将distinct后面的列放在一起作为条件  4.6 限制结果-limit关键">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/kilomi/pic-bed/raw/master/img/202402050101323.png">
<meta property="article:published_time" content="2024-02-04T17:00:28.000Z">
<meta property="article:modified_time" content="2024-02-04T17:01:13.136Z">
<meta property="article:author" content="hatida">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/kilomi/pic-bed/raw/master/img/202402050101323.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>hatida</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/hatida"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(3)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">
<input type="hidden" id="yelog_site_word_count" value="47.3k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mysql</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="All 数据库 "
           href="/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="mysql必知必会">mysql必知必会</span>
            <span class="post-date" title="2024-02-05 01:00:28">2024/02/05</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/02/04/java/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E5%9F%BA%E7%A1%80)/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="mysql">mysql</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        
        <a  class="All 数据库 "
           href="/2024/02/04/mysql/mysql/"
           data-tag="mysql"
           data-author="" >
            <span class="post-title" title="mysql">mysql</span>
            <span class="post-date" title="2024-02-04 16:17:27">2024/02/04</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-java/6 面向对象编程(基础)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">mysql</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">java</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-02-05 01:04:13'>2024-02-04 16:17</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">6 面向对象编程（基础）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">6.1 类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.1.1 属性&#x2F;成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.1.2 创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;6.1.3 类与对象的内存访问机制&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">6.2 成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;6.2.1 方法的调用机制&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.2.2 使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;6.2.3 成员方法传参机制&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">6.3 &#x3D;&#x3D;方法递归调用&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.3.1 使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">6.4 方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;6.5 可变参数&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.5.1 使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">6.6 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.6.1 使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">6.7 构造方法、构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.7.1 使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;6.7.2 流程分析&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">&#x3D;&#x3D;6.8 this关键字&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">super 与 this 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6.8.1 使用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">迷宫游戏代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">八皇后代码</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="6-面向对象编程基础">6 面向对象编程（基础）</span></h1><blockquote>
<p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p>
<p>Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写</p>
</blockquote>
<h2><span id="61-类与对象">6.1 类与对象</span></h2><blockquote>
<p>从 类 到 对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者 把对象实例化</p>
<ol>
<li>类 是抽象的、概念的，代表一类事物</li>
<li>对象 是具体的、实际的，代表一个个具体事物</li>
<li>类 是 对象 的模板，对象 是 类 的一个个体，对应一个实例</li>
</ol>
</blockquote>
<h3><span id="611-属性x2f成员变量">6.1.1 属性&#x2F;成员变量</span></h3><blockquote>
<p>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; field（字段）</p>
</blockquote>
<pre><code class="java">class Cat&#123;
    String name;
    int age;
&#125;
</code></pre>
<h3><span id="612-创建对象">6.1.2 创建对象</span></h3><p>注意事项：</p>
<ol>
<li><p>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。</p>
<p> 对象的引用，也被称为对象的句柄。</p>
</li>
<li><p>使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用</p>
</li>
</ol>
<h3><span id="x3dx3d613-类与对象的内存访问机制x3dx3d">&#x3D;&#x3D;6.1.3 类与对象的内存访问机制&#x3D;&#x3D;</span></h3><blockquote>
<p>栈：一般存放基本数据类型（局部变量）</p>
<p>堆：存放对象（如<code>Cat cat1 = new Cat()</code>，是在这里开辟的空间），所有的java对象都存储在堆中。</p>
<p>方法区：常量池（常量，比如字符串），类加载信息</p>
</blockquote>
<ol>
<li>创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈 中的对象名被赋予指向那个空间的地址。</li>
<li>之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在 堆 中；是 字符串 的记录一个地址，该地址指向 方法区，那里的常量池有该字符串。</li>
</ol>
<h2><span id="62-成员方法">6.2 成员方法</span></h2><blockquote>
<p>使用 成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</p>
</blockquote>
<h3><span id="x3dx3d621-方法的调用机制x3dx3d">&#x3D;&#x3D;6.2.1 方法的调用机制&#x3D;&#x3D;</span></h3><p>以前文代码为例：</p>
<pre><code class="java">...
        int r = cat1.speak2(15, 135);		
...
public int speak2(int n1, int n2)&#123;	
   int res = n1 + n2;
   return res;
&#125;
...
</code></pre>
<ol>
<li>当程序执行到方法时，在 栈 中开辟一个新的 栈空间。该空间里储存 <code>n1 = 15</code> <code>n2 = 135</code>，之后计算并储存结果 <code>res = 150</code></li>
<li>当方法执行完毕，或执行到 <code>return</code> 语句时，就会返回</li>
<li>把 新栈空间 中的 <code>res = 150</code> 返回 main栈 中调用方法的地方</li>
<li>返回后，继续执行该方法的后续代码</li>
</ol>
<h3><span id="622-使用细节">6.2.2 使用细节</span></h3><ol>
<li>调用细节：<ul>
<li>同一个类中的方法调用，可以直接调用。</li>
<li>跨类的方法调用，需要创建新对象，然后再调用方法。</li>
</ul>
</li>
</ol>
<h3><span id="x3dx3d623-成员方法传参机制x3dx3d">&#x3D;&#x3D;6.2.3 成员方法传参机制&#x3D;&#x3D;</span></h3><p>&#x3D;&#x3D;Java 语言对对象采用的是 <strong>值传递</strong>，方法得到的总是那个传入对象的副本。&#x3D;&#x3D;</p>
<p>方法参数共有两种类型：</p>
<ol>
<li>基本数据类型（数字、布尔值)</li>
<li>对象引用。</li>
</ol>
<ul>
<li><p>&#x3D;&#x3D;方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参&#x3D;&#x3D;。</p>
</li>
<li><p>&#x3D;&#x3D;方法可以改变对象参数的状态。&#x3D;&#x3D;</p>
<p>  引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p>
<p>  但改变那个形参地址指向的场合，实参的指向不会改变</p>
</li>
</ul>
<blockquote>
<p>java核心技术卷一：</p>
<p>4.5 方法参数</p>
<p>&#x3D;&#x3D;按值调用&#x3D;&#x3D;表示方法接收的是调用者提供的值。而按引用调用表示方法接受的是调用者提供的变量地址，一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p>
<p>java程序设计语言总是采用按值调用，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p>
<pre><code class="java">double percent = 10;
harry.raiseSalary(percent):
不必理睬这个方法的具体实现， 在方法调用之后， percent 的值还是10。
</code></pre>
<p>但作将对象应用作为参数就不一样了。<br>拷贝的是对象的引用变量而不是整个对象，拷贝的和原来的引用指向同一个对象，可以理解为拷贝的对象引用是它的别名，实质指的是一个东西。可以通过这个别名引用来改变原对象。</p>
<p>总结一下Java 中方法参数的使用情况：</p>
<p>&#x3D;&#x3D;一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。&#x3D;&#x3D;<br>&#x3D;&#x3D;一个方法可以改变一个对象参数的状态。&#x3D;&#x3D;<br>&#x3D;&#x3D;一个方法不能让对象参数引用一个新的对象。&#x3D;&#x3D;</p>
</blockquote>
<h2><span id="63-x3dx3d方法递归调用x3dx3d">6.3 &#x3D;&#x3D;方法递归调用&#x3D;&#x3D;</span></h2><blockquote>
<p>递归：即方法自己调用自己，每次调用时传入不同变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p>
</blockquote>
<blockquote>
<p>下面，示范一个斐波那契数列方法</p>
<pre><code class="java">&gt;class T&#123;
   public int fib(int n)&#123;
       if(n == 1 || n == 2)&#123;
           return 1;
       &#125;else&#123;
           return (fib(n - 1)) + (feb(n - 2));
       &#125;
   &#125;
&gt;&#125;
</code></pre>
</blockquote>
<h3><span id="631-使用细节">6.3.1 使用细节</span></h3><ol>
<li>执行一个方法时，就创建一个新的受保护的独立 栈空间。</li>
<li>方法的局部变量是独立的，不会相互影响。</li>
<li>如果方法中使用的是引用变量，就会共享数据。（因为 [[6.2.3 成员方法传参机制]](<a target="_blank" rel="noopener" href="https://i-melody.github.io/2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6">https://i-melody.github.io/2021/11/29/Java/入门阶段/6</a> 面向对象编程（基础）&#x2F;#6-2-3-成员方法传参机制)）</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示 <code>StackOverflowError</code> “死龟”</li>
<li>当一个方法执行完毕，或遇到 <code>return</code> 就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕</li>
</ol>
<h2><span id="64-方法重载">6.4 方法重载</span></h2><p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求 形参列表 不一致。</p>
<h2><span id="x3dx3d65-可变参数x3dx3d">&#x3D;&#x3D;6.5 可变参数&#x3D;&#x3D;</span></h2><blockquote>
<p>Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p>
</blockquote>
<p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p>
<pre><code class="java">public void m(int... n)&#123;
    //此时，n 相当于一个 数组。
    int length = n.length;
    int num1 = n[0];
&#125;
</code></pre>
<h3><span id="651-使用细节">6.5.1 使用细节</span></h3><ol>
<li><p>可变参数 的实参可以是 0 个，也可以是 任意多 个。</p>
</li>
<li><p>可变参数 的实参可以是数组</p>
</li>
<li><p>可变参数 本质就是数组</p>
<p> 因此，出现：</p>
<pre><code class="java">public void met(int... n)&#123;				//这个方法与下面的方法不能构成重载
&#125;
</code></pre>
<p> 的场合，不能有方法：</p>
<pre><code class="java">public void met(int[] n)&#123;				//这个方法与上面的方法不能构成重载
&#125;
</code></pre>
</li>
<li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数 在最后</p>
<pre><code class="java">public void m(double dou, int... n) &#123;&#125;
</code></pre>
</li>
<li><p>一个形参列表<u>最多出现 一个 可变参数。</u></p>
</li>
</ol>
<h2><span id="66-作用域">6.6 作用域</span></h2><ol>
<li>在 Java 编程中，主要的变量就是 <strong>属性（成员变量</strong>）和 <strong>局部变量。</strong></li>
<li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li>
<li>作用域的分类<ul>
<li>全局变量：也就是 属性，作用域为整个类体</li>
<li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li>
</ul>
</li>
<li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。&#x3D;&#x3D;局部变量必须赋值使用&#x3D;&#x3D;</li>
</ol>
<h3><span id="661-使用细节">6.6.1 使用细节</span></h3><ol>
<li><p>属性 和 局部变量 &#x3D;&#x3D;可以重名&#x3D;&#x3D;，访问时遵循&#x3D;&#x3D;就近原则&#x3D;&#x3D;</p>
</li>
<li><p>在同一作用域中，两个局部变量不能重名</p>
</li>
<li><p>&#x3D;&#x3D;属性 的生命周期较长。其伴随对象的创建而创建，伴随<strong>对象</strong>的销毁而销毁。&#x3D;&#x3D;</p>
<p> &#x3D;&#x3D;局部变量 生命周期较短。其伴随代码块的执行而创建，伴随<strong>代码块</strong>的结束而销毁。&#x3D;&#x3D;</p>
</li>
<li><p>全局变量&#x2F;属性 可以被本类使用，&#x3D;&#x3D;也可以被其他类（通过对象）使用。&#x3D;&#x3D;</p>
<p> 局部变量 只能被本类的对应方法中调用</p>
</li>
<li><p>全局变量&#x2F;属性 <strong>可以加</strong> 修饰符</p>
<p> &#x3D;&#x3D;局部变量 <strong>不能加</strong> 修饰符&#x3D;&#x3D;</p>
</li>
</ol>
<h2><span id="67-构造方法-构造器">6.7 构造方法、构造器</span></h2><blockquote>
<p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化</p>
</blockquote>
<ol>
<li>构造器的修饰符可以是默认。也可以是别的</li>
<li>参数列表 规则同 成员方法</li>
</ol>
<h3><span id="671-使用细节">6.7.1 使用细节</span></h3><ol>
<li>构造器本质也是方法(并不会继承)。所以，可以 构造器重载。</li>
<li>构造器名 和 类名 相同</li>
<li>构造器无返回值</li>
<li>&#x3D;&#x3D;构造器是完成对象的初始化，而不是创建&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;创建对象时，系统<u>自动调用构造器</u>&#x3D;&#x3D;</li>
<li>如果提供了构造器，则不会提供默认构造器了。</li>
<li>&#x3D;&#x3D;一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器&#x3D;&#x3D;</li>
</ol>
<h3><span id="x3dx3d672-流程分析x3dx3d">&#x3D;&#x3D;6.7.2 流程分析&#x3D;&#x3D;</span></h3><pre><code class="java">Person p1 = new Person(&quot;Amy&quot;, 10);		

...
    
class Person&#123;
    String name;
    int age = 20;
    public Person(String pName, int pAge)&#123;
        name = pName;
        age = pAge;
    &#125;
&#125;
</code></pre>
<ol>
<li><p>加载 类信息（<strong>方法区</strong>）</p>
</li>
<li><p>在 <strong>堆</strong> 中开辟空间（地址）</p>
</li>
<li><p>完成对象初始化</p>
<ul>
<li><p>首先默认初始化。<code>age = 0; name = null</code></p>
</li>
<li><p>之后显式初始化。<code>age = 20; name = null</code>	&#x2F;&#x2F;定义时的赋值</p>
<p>  其中，&#x3D;&#x3D;显式初始化和代码块初始化按编写的先后顺序依次进行&#x3D;&#x3D;。</p>
</li>
<li><p>之后构造器的初始化。<code>age = 10; name = &quot;Amy&quot;</code></p>
</li>
</ul>
</li>
<li><p>把对象在 堆 中的 地址，返回给 <code>p1</code></p>
</li>
</ol>
<h2><span id="x3dx3d68-this关键字x3dx3d">&#x3D;&#x3D;6.8 this关键字&#x3D;&#x3D;</span></h2><blockquote>
<p>JVM 会给每个对象分配 this 代表当前对象。</p>
<p>相当于在 堆 中，this 指向自己（对象）</p>
<p>在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。</p>
<p>遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p>
</blockquote>
<pre><code class="java">class Example&#123;
    int n = 0;
    public void act(int n) &#123;&#125;
&#125;
</code></pre>
<p>上面这个类的 <code>act()</code> 方法实际有 2 个参数。对其调用：</p>
<pre><code class="java">Example e = new Exmaple();
e.act(100);
</code></pre>
<p>可见，出现在方法名前的参数 <code>e</code>，以及出现在方法名后的括号中的参数 <code>100</code></p>
<p>&#x3D;&#x3D;出现在方法名前的参数被称为 <strong>隐式参数</strong>（也称为 方法调用的 目标 或 接收者）&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;出现在方法名后的参数被称为 <strong>显式参数</strong>，就是所谓的实参&#x3D;&#x3D;</p>
<p>在每一个方法中，用 <strong>this 指代隐式参数</strong>。</p>
<pre><code class="java">public void act(int n) &#123;
    this.n = n;
&#125;
</code></pre>
<p>此时，再以相同方式调用方法：</p>
<pre><code class="java">e.act(100);					// &lt;———— 相当于 e.n = 100;
</code></pre>
<h3><span id="super-与-this-关键字"><code>super 与 this 关键字</code></span></h3><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<blockquote>
<p>《java核心技术卷1》：5.1.3 子类构造器</p>
<ol>
<li><p>this 有两个用途： 一是引用隐式参数(&#x3D;&#x3D;所构造的对象&#x3D;&#x3D;)， 二是<u>调用该类其他的构造器</u></p>
</li>
<li><p>super 也有两个用途：一是调用超类的方法，二是调用超类的构造器。</p>
</li>
</ol>
<p>在调用构造器的时候， 这两个关键字的使用方式很相似。&#x3D;&#x3D;调用构造器的语句只能作为另一个构造器的第一条语句出现。&#x3D;&#x3D;&#x3D;&#x3D;构造参数既可以传递给本类(this ) 的其他构造器， 也可以传递给超类(super ) 的构造器。&#x3D;&#x3D;</p>
</blockquote>
<h3><span id="681-使用方法">6.8.1 使用方法</span></h3><ol>
<li><p><code>this</code> 关键字可以用来访问本类的属性、方法、构造器</p>
</li>
<li><p><code>this</code> 用于区分当前类的 属性 和 局部变量</p>
</li>
<li><p>访问本类中成员方法的语法：<code>this.方法名</code></p>
</li>
<li><p>访问构造器的语法：<code>this(参数列表);</code></p>
<p> 注意：&#x3D;&#x3D;只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;<code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中 使用&#x3D;&#x3D;</p>
</li>
</ol>
<h2><span id="附录">附录</span></h2><h3><span id="迷宫游戏代码">迷宫游戏代码</span></h3><pre><code class="java">/**
*@author Melody
*@version v1.2.6
**/

//迷宫
import java.util.Scanner;
public class MazeOut&#123;

    public static void main(String[] args)&#123;
        //tools 方便后面调用方法。 inP 可以接收用户输入
        T tools = new T();
        Scanner inP = new Scanner(System.in);
        
        //提示并接收用户输入信息
        System.out.println(&quot;\n输入迷宫宽度（至少为6）：&quot;);
        int x = inP.nextInt();
        System.out.println(&quot;\n输入迷宫长度（至少为6）：&quot;);
        int y = inP.nextInt();  
        //若用户输入的长或宽超出范围，则将其重置为正常值
        if(x &lt; 6)&#123;
            x = 6;
        &#125; else if(x &gt; 110)&#123;
            x = 110;
        &#125;
        if(y &lt; 6)&#123;
            y = 6;
        &#125; else if(y &gt; 60)&#123;
            y = 60;
        &#125;
        System.out.println(&quot;\n输入迷宫的困难度（请输入1 - 6的数字，数字越高越不容易获胜）：&quot;);
        int hard = inP.nextInt();
        if(hard == 7)&#123;
            System.out.println(&quot;\n\n您选择了找点麻烦&quot;);
        &#125; else if (hard == 8 || hard == 9)&#123;
            System.out.println(&quot;\n\n您选择了给自己添堵&quot;);
        &#125;
        System.out.println(&quot;\n\t迷宫生产完毕\n&quot;);
        
        //设置一个 count 值，记录步数。设为数组，以便数据通用。第一位记录当前值，第二位为最大值。
        int[] count = &#123;0, 0&#125;;
        //调用方法，生成迷宫
        char[][] maze =new char[y][x];
        tools.newMaze(maze.length, maze[0].length, maze, hard);
        //调用方法，展示迷宫
        tools.showMaze(maze);
        
        //提示用户开始游戏
        System.out.println(&quot;\n召唤一个探索者，来探索迷宫吧（随便输点什么吧）&quot;);
        //输入 r 或 c 则采用递归方法，其余采用爬墙方法
        char inC = inP.next().charAt(0);
        if(inC == &#39;c&#39;)&#123;
            System.out.println(&quot;\n您触发了迷宫之神的眷顾。&quot;);
            if(hard &gt; 5)&#123;
                System.out.println(&quot;\n迷宫之神眉头一皱，发现事情并不简单。&quot;);
            &#125;
            if(x &gt; 12 || y &gt; 12)&#123;
                System.out.println(&quot;看到地图这么大，迷宫之神悻悻而归。他只喜欢12格以下的地图。&quot;);
                return; 
            &#125;
        &#125; else if(inC == &#39;r&#39;)&#123;
            System.out.println(&quot;\n您引来了一群无畏小黄鸡。他们视死如归，一心想着寻找出口&quot;);
        &#125; else &#123;
            System.out.println(&quot;\n我们找来了一只小蜘蛛。试试看吧。&quot;);
        &#125;
        System.out.println(&quot;\n&quot;);
        //调用方法，解密
        if(inC == &#39;r&#39; || inC == &#39;c&#39;)&#123;
            tools.outMazeRec(maze, inC, count);
        &#125; else &#123;
            tools.outMaze(maze, count);
        &#125;

    &#125;
&#125;





class T&#123;   
    //=======================================================================================    
    
    //方法 newMaze：让 n3 生成随机的 长 * 宽 = n1 * n2 的迷宫，其困难度为 n4
    public void newMaze(int n1, int n2, char[][] n3, int n4)&#123;
        //构建迷宫墙壁，以&#39;#&#39;表示。并随机向其中填充石块，以&#39;O&#39;表示
        ////墙壁是迷宫的 开头和结尾行 以及 每行的开头和结尾
        for(int i = 0; i &lt; n1; i++)&#123;
            for(int j = 0; j &lt; n2; j++)&#123;
                if(i == 0 || i == n1 - 1 ||j == 0 || j == n2 - 1)&#123;
                    n3[i][j] = &#39;#&#39;;
                &#125;else&#123;
                    //ran 是一个随机值，此处是概率生成挡路的石块&#39;O&#39;。其概率与 n4 值的大小正相关
                    //此外，若 n4（即用户输入的难度值 hard）超过范围，则按照 难度6 计算
                    int ran;
                    if(n4 &lt;= 9 &amp;&amp; n4 &gt;= 0)&#123;
                        ran = (int)(Math.random() * (9 - n4) + 1);
                    &#125;else&#123;
                        ran = (int)(Math.random() * 3 + 1);
                    &#125;
                    n3[i][j] = (ran == 1) ? &#39;O&#39; : &#39; &#39;;
                &#125;
            &#125;
        &#125;
        //生成起点、终点，优化地形
        n3[1][1] = &#39;B&#39;;
        n3[2][1] = &#39; &#39;;
        n3[1][2] = &#39; &#39;;
        n3[n1 - 2][n2 - 2] = &#39;F&#39;;
        n3[n1 - 3][n2 - 2] = &#39; &#39;;
        n3[n1 - 2][n2 - 3] = &#39; &#39;;
    &#125;
    
    
    

    
    //方法 showMaze：展示一个迷宫
    public void showMaze(char[][] n1)&#123;
        for(int i = 0; i &lt; n1.length; i++)&#123;
            for(int j = 0; j &lt; n1[i].length; j++)&#123;
                System.out.print(&quot; &quot; + n1[i][j]);
            &#125;
            System.out.println();
        &#125;
    &#125;
    //=======================================================================================   






    //=======================================================================================
    //方法 outMazeRec：递归方法迷宫游戏入口。可以接入普通递归方法，或最短路径方法。
    public void outMazeRec(char[][] n1, char n2, int[] count)&#123;
        //out：是否走出迷宫
        boolean out = false;
        //将迷宫的起止位置记为通路
        n1[1][1] = &#39; &#39;;
        n1[n1.length - 2][n1[0].length -2] = &#39; &#39;;
        //如果输入的是&#39;c&#39;，则采用最短路径法。反之采用普通递归方法
        if(n2 == &#39;c&#39;)&#123;
            out = outCountMaze(1, 1, n1, count);
        &#125;else&#123;
            out = outMazeRecursion(1, 1, n1, count);           
        &#125;
        //把迷宫起始位置重新标注出来
        n1[1][1] = &#39;B&#39;;
        //判断是否解谜成功。如果成功，迷宫终点显示&#39;V&#39;，并展示步数，否则显示&#39;F&#39;
        if(out)&#123;
            n1[n1.length - 2][n1[0].length -2] = &#39;V&#39;;
            showMaze(n1);
            System.out.println(&quot;\t YOU WIN！！！&quot;);
            System.out.println(&quot;通过路径为 &quot; + count[1] + &quot; 格&quot;);    
        &#125; else &#123;
            n1[n1.length - 2][n1[0].length -2] = &#39;F&#39;;
            showMaze(n1);
            System.out.println(&quot;\t YOU LOSE&quot;);
        &#125;
        
    &#125;
    //=======================================================================================




    //=======================================================================================
    //方法 outMazeRecursion：迷宫游戏，普通递归方法
    public boolean outMazeRecursion(int y, int x, char[][] n3, int[] count)&#123;
        count[1]++;
        if(n3[n3.length - 2][n3[0].length - 2] == &#39;.&#39;)&#123;
            return true;
        &#125; else if(n3[y][x] == &#39; &#39;)&#123;
            n3[y][x] = &#39;.&#39;;
            if(outMazeRecursion(y, x + 1, n3, count))&#123;
                return true;
            &#125; else if(outMazeRecursion(y + 1, x, n3, count))&#123;
                return true;
            &#125; else if(outMazeRecursion(y, x - 1, n3, count))&#123;
                return true;
            &#125; else if(outMazeRecursion(y - 1, x, n3, count))&#123;
                return true;
            &#125; else&#123;
                count[1]--;
                n3[y][x] = &#39;+&#39;; 
            &#125;
        &#125; else &#123;
            count[1]--;
            return false;
        &#125;
        count[1]--;
        return false;
    &#125;
    //=======================================================================================    






    //=======================================================================================
    //方法 outCountMaze：迷宫游戏，最短路径法的入口。这个入口由普通递归法接入。
    public boolean outCountMaze(int y, int x, char[][] n, int[] count)&#123;

        //首先，创建一个里数组。该数组用于 part1，原数组用于 part2。
        //似乎没必要作此设计。但我还是予以保留。
        char[][] inMaze = new char[n.length][n[0].length];
        for(int i = 0; i &lt; n.length; i++)&#123;
            for(int j = 0; j &lt; n[0].length; j++)&#123;
                inMaze[i][j] = n[i][j];
            &#125;
        &#125;

        //首先进行 part1，然后必定进行 part2。因为 part1 总会返回一个 false
        if(countMazeRec(y, x, inMaze, count) || true)&#123;
            count[0] = 0;
            return outMazeRecC(y, x, n, count);
        &#125;
        return false;
    &#125;


    //方法 countMazeRec：迷宫游戏，最短路径法，part1
    //该方法是先统计最短路径。最终总会返回 false
    public boolean countMazeRec(int y, int x, char[][] n3, int[] count)&#123;
        count[0]++;
        if(y == n3.length - 2 &amp;&amp; x == n3[0].length - 2)&#123;
            if(count[0] &lt; count[1] || count[1] == 0)&#123;
                count[1] = count[0];
            &#125;
        &#125; else if(n3[y][x] == &#39; &#39;)&#123;
            n3[y][x] = &#39;.&#39;;           
            if(countMazeRec(y, x + 1, n3, count))&#123;
                return true;
            &#125; else if(countMazeRec(y + 1, x, n3, count))&#123;
                return true;
            &#125; else if(countMazeRec(y, x - 1, n3, count))&#123;
                return true;
            &#125; else if(countMazeRec(y - 1, x, n3, count))&#123;
                return true;
            &#125; else&#123;
                n3[y][x] = &#39; &#39;;
                count[0]--;
                return false;
            &#125;
        &#125; else &#123;
            count[0]--;
            return false;
        &#125;
        count[0]--;
        return false;
    &#125;






    //方法 outMazeRecC：迷宫游戏，最短路径法，part2
    //该方法是在 part1 统计完最短路径后，按最短路径走出迷宫，并绘制路径
    public boolean outMazeRecC(int y, int x, char[][] n3, int[] count)&#123;
        count[0]++;
        if(y == n3.length - 2 &amp;&amp; x == n3[0].length - 2)&#123;
            if(count[0] &lt;= count[1])&#123;
                return true;
            &#125; else &#123;
                n3[n3.length - 2][n3[0].length - 2] = &#39; &#39;;
                count[0]--;
                return false;
            &#125;
        &#125; else if(n3[y][x] == &#39; &#39;)&#123;
            n3[y][x] = &#39;.&#39;;
            if(outMazeRecC(y, x + 1, n3, count))&#123;
                return true;
            &#125; else if(outMazeRecC(y + 1, x, n3, count))&#123;
                return true;
            &#125; else if(outMazeRecC(y, x - 1, n3, count))&#123;
                return true;
            &#125; else if(outMazeRecC(y - 1, x, n3, count))&#123;
                return true;
            &#125; else&#123;
                n3[y][x] = &#39; &#39;;
                count[0]--;
                return false;
            &#125;
        &#125; else &#123;
            count[0]--;
            return false;
        &#125;

    &#125;
    //=======================================================================================


    



    //=======================================================================================
    //方法 outMaze：爬墙方法迷宫游戏入口
    public void outMaze(char[][] n1, int[] count)&#123;
        //boolean out：记录是否走出迷宫
        boolean out = false;
        //角色光标 m
        n1[1][1] = &#39;m&#39;;
        
        //创建一系列变量，后面解释用法
        //创建 角色坐标
        int x = 1;
        int y = 1;
        //创建 辅助坐标 及 方向字符。初始方向为右。
        int xi = 1;
        int yi = 0;
        char dir = &#39;r&#39;;  
        //创建 里迷宫，标记起止点。
        char[][] inMaze = new char[n1.length][n1[0].length];
        inMaze[1][1] = &#39;B&#39;;
        inMaze[n1.length - 2][n1[0].length - 2] = &#39;F&#39;;
        
        //开始走迷宫。
        //如果一个迷宫有出路，则沿着一侧的墙壁走就一定能走到出路。以下方法就是基于这个原理。
        //角色坐标 y,x 是角色所在的位置坐标。辅助坐标 yi，xi 是角色靠近的墙壁坐标。
        //dir 代表角色此时的朝向。只要角色按照墙壁延申的方向向前，就一定不会迷路。
        //里迷宫的大小和真迷宫相同，坐标也一一对应。目的是为了记录数据，这些数据不会被用户看到。
        //里迷宫记载了 起始点 和 终点 的位置。如角色回到起点，则必定失败。到达终点则成功。
        for(;;)&#123;

            //判断 是否走出迷宫。如若是，则展示迷宫，记录脱出为真，并退出寻路
            if(inMaze[y][x] == &#39;F&#39;)&#123;
                n1[y][x] = &#39;V&#39;;
                n1[1][1] = &#39;B&#39;;
                showMaze(n1);
                out = true;
                break;
            &#125;

            //通过爬墙方式试图走出迷宫
            //这是方向朝右时的情况
            if(dir == &#39;r&#39;)&#123;
                //如果角色面对墙壁，意味着走到了墙角，则角色坐标不变，调整墙壁坐标，并转向
                if(n1[y][x + 1] == &#39;#&#39; || n1[y][x + 1] == &#39;O&#39;)&#123;
                    dir = yi &gt; y ? &#39;u&#39; : &#39;d&#39;;
                    yi = y;
                    xi = x + 1;
                //如果面前有路，且墙壁延伸，则前进
                &#125; else if (n1[yi][xi + 1] == &#39;#&#39; || n1[yi][xi + 1] == &#39;O&#39;)&#123;
                    n1[y][x] = &#39;.&#39;;
                    x++;
                    xi++;
                    n1[y][x] = &#39;m&#39;;
                    count[1]++;
                //如果面前有路，但墙壁不延伸，则是遇到了转角。角色移动，转向，但墙壁坐标不变
                &#125; else &#123;
                    dir = yi &gt; y ? &#39;d&#39; : &#39;u&#39;;
                    n1[y][x] = &#39;.&#39;;
                    n1[y][x + 1] = &#39;.&#39;;
                    y = yi;
                    x = xi + 1;
                    n1[y][x] = &#39;m&#39;;
                    count[1] += 2;
                &#125;
            //这是方向朝左的情况
            &#125; else if(dir == &#39;l&#39;)&#123;
                if(n1[y][x - 1] == &#39;#&#39; || n1[y][x - 1] == &#39;O&#39;)&#123;
                    dir = yi &gt; y ? &#39;u&#39; : &#39;d&#39;;
                    yi = y;
                    xi = x - 1;
                &#125; else if(n1[yi][xi - 1] == &#39;#&#39; || n1[yi][xi - 1] == &#39;O&#39;)&#123;
                    n1[y][x] = &#39;.&#39;;
                    x--;
                    xi--;
                    n1[y][x] = &#39;m&#39;;
                    count[1]++;
                &#125; else &#123;
                    dir = yi &gt; y ? &#39;d&#39; : &#39;u&#39;;
                    n1[y][x] = &#39;.&#39;;
                    n1[y][x - 1] = &#39;.&#39;;
                    y = yi;
                    x = xi - 1;
                    n1[y][x] = &#39;m&#39;;
                    count[1] += 2;
                &#125;
            //这是方向朝下的情况
            &#125; else if(dir == &#39;d&#39;)&#123;
                if(n1[y + 1][x] == &#39;#&#39; || n1[y + 1][x] == &#39;O&#39;)&#123;
                    dir = xi &lt; x ? &#39;r&#39; : &#39;l&#39;;
                    yi = y + 1;
                    xi = x;
                &#125; else if(n1[yi + 1][xi] == &#39;#&#39; || n1[yi + 1][xi] == &#39;O&#39;)&#123;
                    n1[y][x] = &#39;.&#39;;
                    y++;
                    yi++;
                    n1[y][x] = &#39;m&#39;;
                    count[1]++;
                &#125; else &#123;
                    dir = xi &lt; x ? &#39;l&#39; : &#39;r&#39;;
                    n1[y][x] = &#39;.&#39;;
                    n1[y + 1][x] = &#39;.&#39;;
                    y = yi + 1;
                    x = xi;
                    n1[y][x] = &#39;m&#39;;
                    count[1] += 2;
                &#125;
            //这是方向朝上的情况
            &#125; else if(dir == &#39;u&#39;)&#123;
                if(n1[y - 1][x] == &#39;#&#39; || n1[y - 1][x] == &#39;O&#39;)&#123;
                    dir = xi &lt; x ? &#39;r&#39; : &#39;l&#39;;
                    yi = y - 1;
                    xi = x;
                &#125; else if(n1[yi - 1][xi] == &#39;#&#39; || n1[yi - 1][xi] == &#39;O&#39;)&#123;
                    n1[y][x] = &#39;.&#39;;
                    y--;
                    yi--;
                    n1[y][x] = &#39;m&#39;;
                    count[1]++;
                &#125; else &#123;
                    dir = xi &lt; x ? &#39;l&#39; : &#39;r&#39;;
                    n1[y][x] = &#39;.&#39;;
                    n1[y - 1][x] = &#39;.&#39;;
                    y = yi - 1;
                    x = xi;
                    n1[y][x] = &#39;m&#39;;
                    count[1] += 2;
                &#125;
            &#125;

            //判断 是否回到起点。如若是，则一定是迷宫无解。展示迷宫并退出寻路
            if(inMaze[y][x] == &#39;B&#39;)&#123;
                showMaze(n1);
                break;
            &#125;
        &#125;
        //输出结果
        if(out)&#123;
            System.out.println(&quot;\t YOU WIN！！！\n\t您的步数为：&quot; + count[1]);
        &#125; else &#123;
            System.out.println(&quot;\t YOU LOSE&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3><span id="八皇后代码">八皇后代码</span></h3><pre><code class="java">import java.util.Scanner;
public class EightQueen&#123;

    public static void main(String[] args)&#123;
        T tools = new T();
        char[][] chess = new char[8][8];
        //调用方法，建立棋盘
        tools.buildChess(chess);
        //调用方法，开始游戏
        tools.eightQueen(chess);

    &#125;
&#125;



class T&#123;
    //buildChess：建立一个新棋盘。该棋盘白色格子用&#39; &#39;表示，黑色格子用&#39;#&#39;表示
    public void buildChess(char[][] chess)&#123;
        for(int i = 0; i &lt; chess.length; i++)&#123;
            for(int j = 0; j &lt; chess[0].length; j++)&#123;
                chess[i][j] = ((i + j) % 2 == 0) ? &#39; &#39; : &#39;#&#39;;
            &#125;
        &#125;
    &#125;




    //eightQueen：八皇后游戏的接入口
    public void eightQueen(char[][] chess)&#123;
        //建立 里棋盘 inward 及 计数数组 count。里棋盘用于计算问题，原棋盘输出给用户看。
        //计数 count 使用数组，这样其数据在所有方法都能通用
        char[][] inward = new char[chess.length][chess[0].length];
        int[] count = &#123;0&#125; ;
        //进行游戏。因为穷举所有方法，最后返回的一定是 false。反正我们不在意。
        boolean isFinished = gameEQS(0, 0, chess, inward, count);
    &#125;



    //gameEQS：八皇后游戏的基本方法
    //八皇后游戏方法。y 代表当前位置的纵坐标，x 是横坐标。chess 是棋盘，inward 是里棋盘，count 是计数数组
    public boolean gameEQS(int y, int x, char[][] chess, char[][] inward, int[] count)&#123;
        //当 y 超出棋盘 时，显然已经完成八皇后。
        //由于要进行穷举，此时我们计数并输出棋盘，然后返回 false 使其继续计算
        if(y == inward.length)&#123;
            count[0]++;
            System.out.println();
            gameEQS2(chess, inward, count);
            return false;
        //当 x 超出棋盘 时，显然棋盘该列已经无合法放置位置。我们返回 false
        &#125; else if(x == inward[0].length)&#123;
            return false;
        //gameEQS1，这个方法是查看该格子是否是合法放置位置。如若是，返回 true，而且在该位置放置棋子&#39;Q&#39;
        //当这个位置合法，我们进入下一行，从头开始判断。
        //如果后面的判断为 false，我们就拿掉这枚棋子。如果后面判断为 true 说明我们找到了一个方法。
        //特别地，由于代码目前是穷举模式，我想我们永远不会在此输出 true
        &#125; else if(gameEQS1(y, x, inward))&#123;
            if(gameEQS(y + 1, 0, chess, inward, count))&#123;
                return true;
            &#125; else &#123;
                inward[y][x] = &#39; &#39;;
            &#125;
        &#125;
        //如果代码进行到这个位置，证明我们所在的格子不适合放置棋子。我们只好去看看下一格如何。
        return gameEQS(y, x + 1, chess, inward, count);
    &#125;



    //gameEQS1：该方法是输入一个坐标，并输入里棋盘地址，在里棋盘上查看该位置是否合法
    //什么是合法的位置：就是该坐标的 同列、同行、同斜线 没有别的棋子
    //如果是合法位置，我们放置一个棋子，并返回 true
    public boolean gameEQS1(int y, int x, char[][] inward)&#123;
        for(int i = 0; i &lt; inward.length; i++)&#123;
            for(int j = 0; j &lt; inward[0].length; j++)&#123;
                if(j == x || i == y || i - j == y - x || i + j == y + x)&#123;
                    if(inward[i][j] == &#39;Q&#39;)&#123;
                        return false;
                    &#125;
                &#125;
            &#125;
        &#125;
        inward[y][x] = &#39;Q&#39;;
        return true;
    &#125;



    //gameEQS2：这个方法是把当前 里棋盘 的棋子放置到棋盘上，输出棋盘 并 输出计数。
    //在输出完成后，会清空棋盘。
    public void gameEQS2(char[][] chess, char[][] inward,int[] count)&#123;
        for(int i = 0; i &lt; chess.length; i++)&#123;
            for(int j = 0; j &lt; chess[0].length; j++)&#123;
                if(inward[i][j] == &#39;Q&#39;)&#123;
                    chess[i][j] = &#39;Q&#39;;
                &#125;
                System.out.print(&quot; &quot; + chess[i][j]);
            &#125;
            System.out.println();
        &#125;
        System.out.print(&quot;\n&quot; + count[0] + &quot;\n&quot;);
        buildChess(chess);
    &#125;



    //gameEQSDebug
    //输出里棋盘。测试用。
    public void gameEQSDebug(char[][] inward)&#123;
        for(int i = 0; i &lt; inward.length; i++)&#123;
            for(int j = 0; j &lt; inward[0].length; j++)&#123;
                System.out.print(&quot; &quot; + inward[i][j]);
            &#125;
            System.out.println();
        &#125;
        System.out.println();
    &#125;
&#125;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>














<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<div class="aplayer"

    data-id="9126522781"

    data-server="netease"

    data-type="playlist"

    data-fixed="true"

    data-autoplay="false"

    data-loop="all"

    data-order="random"

    data-preload="auto"

    data-volume="0.7"

    data-mutex="true"

>
</div>
<script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>

<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>

<script>
(function() {

  var arr = new Array();
  var $tags = $('.post-tags').children('a');
  $tags.each(function() {
    arr.push($(this).html())
  })
  if (arr.indexOf("图集") !== -1) {

    $('.hj_img').each(function() {
      $(this).wrap('<a class="fancybox" data-fancybox="gallery" href="' + $(this).prop("src") + '"></a>'); 
    })
    //初始化fancybox，padding设为0，loop设为false
    $('.fancybox').fancybox({
      padding: 0,
      loop: false
    });
  }
})();
</script>

<!-- // 文字 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js"></script>
<!-- // 爱心 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js"></script>
<!-- // 按键屏蔽 需要jQuery -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/noSomeKey.js"></script>


</html>
