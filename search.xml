<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2024/02/09/test/"/>
      <url>/2024/02/09/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><h1><span id="标题1">标题1</span></h1></li><li><h2><span id="标题2">标题2</span></h2></li><li><h3><span id="标题3">标题3</span></h3></li><li><h4><span id="标题4">标题4</span></h4></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql必知必会</title>
      <link href="/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="第4章-检索数据">第4章 检索数据</span></h1><h2><span id="45-检索不同的行">4.5 检索不同的行</span></h2><p>DISTINCT关键字：此关键字指示MySQL只返回不同的值。</p><blockquote><p>不能部分使用DISTINCT DISTINCT关键字应用于所有列而<br>不仅是前置它的列。如果给出SELECT DISTINCT vend_id,<br>prod_price，除非指定的两个列都不同，否则所有行都将被<br>检索出来。</p><p>相当于将distinct后面的列放在一起作为条件</p></blockquote><h2><span id="46-限制结果-limit关键字">4.6 限制结果-limit关键字</span></h2><h3><span id="461分页">4.6.1分页</span></h3><p>应用实例：</p><blockquote><p> 用户提交过来一个页码，以及每页显示的记录条数</p></blockquote><pre><code>int pageNo = 5; //第5页int pageSize = 10; //每页显示10条</code></pre><p>&#x3D;&#x3D;记公式：limit (pageNo-1)*pageSize , pageSize&#x3D;&#x3D;</p><pre><code>pageno = 1 limit 0,10pageno = 2limit 10,10pageno = 3 limit 20,10pageno = 4 limit 30,10...以此类推</code></pre><h2><span id="47-使用完全限定的表名">4.7 使用完全限定的表名</span></h2><pre><code>SELECT products.prod_nameFROM crashcourse.products;</code></pre><p>这段语句限定了表和数据库，在一些情景很有用。</p><h1><span id="第5章-排序检索数据">第5章 排序检索数据</span></h1><h2><span id="51-排列数据">5.1 排列数据</span></h2><blockquote><p>子句（clause） </p><p>SQL语句由子句构成，有些子句是必需的，而<br>有的是可选的。一个子句通常由一个关键字和所提供的数据组成</p></blockquote><p>为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。</p><h2><span id="52-按多个列排序">5.2 按多个列排序</span></h2><blockquote><p>order by子句后加多个列，如果前一个列中所有的值都是唯一的则不会按照第二个列来排序。</p></blockquote><h2><span id="53-指定排序方向">5.3 指定排序方向</span></h2><blockquote><p>ordery by子句默认是升序排列，可以使用DESC关键字来指定降序排列。</p></blockquote><pre><code class="sql">SELECT prod_id,prod_price,prod_nameFROM productsORDER BY prod_price DESC,prod_name;//【1】</code></pre><p>【1】：&#x3D;&#x3D;DESC关键字只应用到直接位于其前面的列名，上面的情况第一列按照指定的降序排列，第二列按照默认的升序排列&#x3D;&#x3D;</p><p><strong>在多个列上降序排序：</strong> </p><blockquote><p>如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。</p></blockquote><p>与DESC相反的关键字是ASC（ASCENDING），ASC没有多大用处，因为升序是默认的。</p><h1><span id="第6章-过滤数据">第6章 过滤数据</span></h1><h2><span id="x3dx3dwhere子句操作符x3dx3d">&#x3D;&#x3D;WHERE子句操作符&#x3D;&#x3D;</span></h2><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定的两个值之间</td></tr></tbody></table><h3><span id="范围值检查between">范围值检查between</span></h3><p>使用BETWEEN操作符。其语法与其他WHERE子句的操作符不同，需要指定2个值，范围的开始值和范围的结束值。</p><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10;</code></pre><p>等价于下面的子句：</p><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE prod_price &gt;= 5 AND prod_price&lt;=10;</code></pre><h3><span id="x3dx3d空值检查x3dx3d">&#x3D;&#x3D;空值检查&#x3D;&#x3D;</span></h3><h1><span id="第7章-数据过滤">第7章 数据过滤</span></h1><h2><span id="and操作符">and操作符</span></h2><pre><code class="sql">SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id 1003 AND prod_price &lt;10</code></pre><blockquote><p>and，两个条件都要满足。</p></blockquote><h2><span id="or操作符">OR操作符</span></h2><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id 1002 OR vend_id 1003;</code></pre><blockquote><p>or，两个条件满足其一即可</p></blockquote><h2><span id="x3dx3d计算次序x3dx3d">&#x3D;&#x3D;计算次序&#x3D;&#x3D;</span></h2><blockquote><p>WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂和高级的过滤。</p></blockquote><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id 1002 OR vend_id 1003 AND prod_price &gt;10;</code></pre><p>上面的sql语句本意在于列出价格为10美元（含）以上且由1002或1003制造的所有产品，但是语句并没有返回预期的结果。</p><blockquote><p>SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符</p></blockquote><p>此问题的解决方法是使用圆括号明确地分组相应的操作符</p><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE (vend_id 1002 OR vend_id 1003)AND prod_price &gt;=10:</code></pre><blockquote><p>在WHERE子句中使用圆括号 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序。</p></blockquote><h2><span id="in操作符">IN操作符</span></h2><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id IN (1002,1003)ORDER BY prod_name;</code></pre><blockquote><p>N操作符完成与OR相同的功能，等价于下面的sql语句</p></blockquote><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id=1002 OR vend id=1003ORDER BY prod_name;</code></pre><p><strong>使用IN操作符的好处</strong></p><ul><li>在使用长的合法选项清单时，IN操作符的语法更&#x3D;&#x3D;清楚且更直观。&#x3D;&#x3D;</li><li>在使用IN时，&#x3D;&#x3D;计算的次序更容易管理&#x3D;&#x3D;（因为使用的操作符更少）。</li><li>IN操作符一般&#x3D;&#x3D;比OR操作符清单执行更快。&#x3D;&#x3D;</li><li>IN的最大优点是&#x3D;&#x3D;可以包含其他SELECT语句&#x3D;&#x3D;，使得能够更动态地建<br>  立WHERE子句。第14章将对此进行详细介绍。</li></ul><h2><span id="not操作符">NOT操作符</span></h2><blockquote><p>WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。</p></blockquote><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id NOT IN (1002,1003)ORDER BY prod_name;</code></pre><p>&#x3D;&#x3D;MySQL中的NOT MySQL支持使用NOT 对IN 、BETWEEN 和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。&#x3D;&#x3D;</p><h1><span id="第8章-用通配符进行过滤">第8章 用通配符进行过滤</span></h1><h2><span id="like操作符">LIKE操作符</span></h2><blockquote><p><strong>通配符（wildcard）</strong>： 用来匹配值的一部分的特殊字符</p></blockquote><blockquote><p><strong>搜索模式（search pattern）</strong>： 由字面值、通配符或两者组合构成的搜索条件。</p></blockquote><h2><span id="百分号通配符">百分号（%）通配符</span></h2><blockquote><p>%代表搜索模式中给定位置的0个、1个或多个字符。</p></blockquote><ol><li><p>搜索模式<code>‘jet%’</code>找出所有以词jet起头的产品</p><pre><code class="sql">SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE &#39;jet%&#39;</code></pre></li></ol><p>&#x3D;&#x3D;区分大小写： 根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，’jet%’与JetPack 1000将不匹配。&#x3D;&#x3D;</p><ol start="2"><li><p>搜索模式<code>&#39;%anvil%&#39;</code>表示匹配任何位置包含文本anvil的值，而不论它之前或之后出现什么字符。</p></li><li><p>搜索模式<code>‘s%e’</code>找出以s起头以e结尾的所有产品：</p></li></ol><p><strong>注意尾空格</strong> </p><blockquote><p>尾空格可能会干扰通配符匹配。例如，在保存词anvil 时， 如果它后面有一个或多个空格， 则子句WHERE prod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数（第11章将会介绍）去掉首尾空格。</p></blockquote><p><strong>注意NULL</strong> </p><blockquote><p>虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行。</p></blockquote><h2><span id="下划线_通配符">下划线（_）通配符</span></h2><blockquote><p><strong>下划线的用途与%一样，但下划线&#x3D;&#x3D;只匹配单个字符&#x3D;&#x3D;而不是多个字符。</strong></p></blockquote><h1><span id="第10章-创建计算字段">第10章 创建计算字段</span></h1><blockquote><p>字段（field）： 基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</p></blockquote><h2><span id="x3dx3d拼接字段x3dx3d">&#x3D;&#x3D;拼接字段&#x3D;&#x3D;</span></h2><p><strong>Concat()函数</strong></p><blockquote><p>拼接（concatenate）： 将值联结到一起构成单个值</p></blockquote><p>在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。</p><p><strong>MySQL的不同之处</strong> </p><blockquote><p>多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心</p></blockquote><pre><code class="sql">SELECT Concat(vend_name,&#39;(&#39;,vend_country,&#39;)&#39;)//[1]FROM vendorsORDER BY vend_name;</code></pre><blockquote><p><code>[1]</code>:Concat()拼接串，即把多个串连接起来形成一个较长的串。Concat()需要一个或多个指定的串，各个串之间用逗号分隔。</p><p>上面的SELECT语句连接以下4个元素：</p><ul><li>存储在vend_name列中的名字；</li><li>包含一个空格和一个左圆括号的串；</li><li>存储在vend_country列中的国家；</li><li>包含一个右圆括号的串</li></ul></blockquote><p><strong>去除空格Trim函数</strong></p><p>在第8章中曾提到通过删除数据右侧多余的空格来整理数据，这可以使用MySQL的RTrim()函数来完成，如下所示：<br>RTrim()函数去掉值右边的所有空格。通过使用RTrim()，各个列都进行了整理</p><pre><code>SELECT Concat(RTrim(vend_name),&#39;(&#39;,RTrim(vend_country),&#39;)&#39;)FROM vendorsORDER BY vend_name;</code></pre><blockquote><p>Trim函数: MySQL除了支持RTrim()（正如刚才所见，它去掉串右边的空格），还支持LTrim()（去掉串左边的空格）以及<br>Trim()（去掉串左右两边的空格）。</p></blockquote><p><strong>使用别名Alias</strong></p><blockquote><p>别名（alias）：是一个字段或值的替换名。别名用AS关键字赋予</p></blockquote><blockquote><p>别名的其他用途 ：别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在<br>原来的名字含混或容易误解时扩充它。</p></blockquote><blockquote><p>导出列： 别名有时也称为导出列（derived column），不管称为什么，它们所代表的都是相同的东西</p></blockquote><h2><span id="执行算数运算">执行算数运算</span></h2><pre><code class="sql">SELECT prod_id,quantity,item_price,quantity*item_price As expanded_price//[1]FROM orderitemsWHERE order_num 20005;</code></pre><p><code>[1]</code>:输出中显示的expanded_price列为一个计算字段，此计算为quantity*item_price。客户机应用现在可以使用这个新计算<br>列，就像使用其他列一样。</p><p><strong>&#x3D;&#x3D;如何测试计算&#x3D;&#x3D;</strong> </p><blockquote><p>SELECT提供了测试和试验函数与计算的一个很好的办法。虽然SELECT通常用来从表中检索数据，但可以省略FROM子句以便简单地访问和处理表达式。例如，SELECT3*2;将返回6，SELECT Trim(‘abc’);将返回abc，而SELECTNow()利用Now()函数返回当前日期和时间。通过这些例子，可以明白如何根据需要使用SELECT进行试验。</p></blockquote><h1><span id="第11章-使用数据处理函数">第11章 使用数据处理函数</span></h1><h2><span id="函数">函数</span></h2><p>去掉串尾空格的RTrim()就是一个函数的例子。</p><blockquote><p>函数没有SQL的可移植性强，如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p></blockquote><h2><span id="使用函数">使用函数</span></h2><p>大多数SQL实现支持以下类型的函数</p><ul><li>用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。</li><li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）<br>  的数值函数。</li><li>用于处理日期和时间值并从这些值中提取特定成分（例如，返回<br>  两个日期之差，检查日期有效性等）的日期和时间函数。</li><li>返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本<br>  细节）的系统函数</li></ul><h3><span id="文本处理函数">文本处理函数</span></h3><p>Trim()函数:</p><p>Upper()函数:</p><pre><code class="sql">SELECT vend_name,Upper (vend_name)AS vend_name_upcaseFROM vendorsORDER BY vend_name;</code></pre><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr></tbody></table><h3><span id="日期和时间处理函数">日期和时间处理函数</span></h3><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202402050101323.png" alt="image-20231202102542306"></p><blockquote><p>无论你什么时候指定一个日期，，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd</p></blockquote><pre><code class="sql">SELECT cust_id,order_numFROM ordersWHERE order_date =&#39;2005-09-01&#39;;</code></pre><p><em><strong>使用WHERE order_date &#x3D; ‘2005-09-01’可靠吗？</strong></em></p><blockquote><p>order_date的数据类型为datetime。这种类型存储日期及时间值。样例表中的值全都具有时间值00:00:00，但实际中很可能并不总是这样。如果用当前日期和时间存储订单日期（因此你不仅知道订单日期，还知道下订单当天的时间）， 怎么办？ 比如， 存储的order_date 值为2005-09-01 11:30:05，则WHEREorder_date &#x3D; ‘2005-09-01’失败。即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。</p></blockquote><blockquote><p>解决办法是指示MySQL仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较。为此，必须使用Date()函数。Date(order_date)指示MySQL仅提取列的日期部分，更可靠的SELECT语句为：</p></blockquote><pre><code class="sql">SELECT cust_id,order_numFROM ordersWHERE Date(order_date)=&#39;2005-09-01&#39;;</code></pre><p><strong>如果要的是日期，请使用Date()</strong> :</p><blockquote><p>如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。</p></blockquote><p><strong>还有一种日期比较需要说明。如果你想检索出2005年9月下的所有订单，怎么办？</strong></p><p>简单的相等测试不行，因为它也要匹配月份中的天数。</p><p>方法一：</p><pre><code class="sql">SELECT custid,order_numFROM ordersWHERE Date(order_date) BETWEEN &#39;2005-09-01&#39;AND &#39;2005-09-30&#39;;</code></pre><p>方法二（一种不需要记住每个月中有多少天或不需要操心闰年2月的办法）：</p><pre><code class="sql">SELECT cust_id,order_numFROM ordersWHERE Year(order_date)=2005 AND Month(order_date)=9;</code></pre><h3><span id="数值处理函数">数值处理函数</span></h3><blockquote><p>数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期—时间处理函数的使用那么频繁。<br>具有讽刺意味的是，在主要DBMS的函数中，数值函数是最一致最统一的函数。</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table><h1><span id="x3dx3d第12章-汇总数据x3dx3d">&#x3D;&#x3D;第12章 汇总数据&#x3D;&#x3D;</span></h1><h2><span id="聚集函数">聚集函数</span></h2><blockquote><p>我们经常需要汇总数据而不用把它们实际检索出来，MySQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有以下几种：</p></blockquote><ul><li>确定表中行数（或者满足某个条件或包含某个特定值的行数）。</li><li>获得表中行组的和。</li><li>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。</li></ul><p><strong>聚集函数</strong></p><blockquote><p>（aggregate function） 运行在行组上，计算和返回单个值的函数。</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM</td><td>返回某列值之和</td></tr></tbody></table><h3><span id="avg函数">AVG函数</span></h3><blockquote><p>AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，<strong>也可以用来返回特定列或行的平均值。</strong></p></blockquote><p><strong>返回所有列的平均值</strong></p><pre><code class="sql">SELECT AVG(prod_price) AS avg_priceFROM products;</code></pre><p><strong>返回特定行的平均值</strong></p><pre><code class="sql">SELECT AVG(prod_price) AS avg_priceFROM productsWHERE vend_id = 1003;</code></pre><p><strong>&#x3D;&#x3D;只用于单个列&#x3D;&#x3D;</strong></p><blockquote><p>AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。</p></blockquote><p>**NULL值 **</p><blockquote><p><strong>AVG()函数忽略列值为NULL的行。</strong></p></blockquote><h3><span id="count函数">COUNT()函数</span></h3><p>COUNT()函数有两种使用方式。</p><ul><li>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li><li>使用COUNT(column)对特定列中具有值的行进行计数，&#x3D;&#x3D;忽略NULL值&#x3D;&#x3D;</li></ul><h3><span id="max函数">MAX()函数</span></h3><p><strong>对非数值数据使用MAX()</strong> </p><blockquote><p>虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。</p></blockquote><p><strong>NULL值</strong> </p><blockquote><p>MAX()函数忽略列值为NULL的行。</p></blockquote><h3><span id="min函数">MIN()函数</span></h3><p><strong>对非数值数据使用MIN()</strong> </p><blockquote><p>MIN()函数与MAX()函数类似，MySQL允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面的行</p></blockquote><p><strong>NULL值</strong></p><blockquote><p>MIN()函数忽略列值为NULL的行。</p></blockquote><h3><span id="x3dx3dsum函数x3dx3d">&#x3D;&#x3D;SUM()函数&#x3D;&#x3D;</span></h3><blockquote><p>SUM()用来返回指定列值的和(总计)</p></blockquote><p>orderitems表包含订单中实际的物品，每个物品<br>有相应的数量（quantity）。可如下检索所订购物品的总数（所有quantity值之和）：</p><pre><code class="sql">SELECT SUM(quantity) As items_orderedFROM orderitemsWHERE order_num = 20005;</code></pre><blockquote><p>SUM()也可以用来合计计算值。</p></blockquote><p>在下面的例子中，合计每项物品item_price*quantity，得出总的订单金额：</p><pre><code class="sql">SELECT SUM(item_price*quantity) AS total_priceFROM orderitemsWHERE order_num = 20005;</code></pre><p><strong>在多个列上进行计算</strong> </p><blockquote><p>如本例所示，&#x3D;&#x3D;利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。&#x3D;&#x3D;</p></blockquote><p><strong>NULL值</strong> </p><blockquote><p>SUM()函数忽略列值为NULL的行。</p></blockquote><h2><span id="聚合不同值">聚合不同值</span></h2><h3><span id="distinct聚集函数">Distinct聚集函数</span></h3><p>以上5个聚集函数都可以如下使用：</p><ul><li>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</li><li>只包含不同的值，指定DISTINCT参数</li></ul><pre><code class="sql">SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend id = 1003;</code></pre><p>在使用了DISTINCT后，此例子中的avg_price比较高，因为有多个物品具有相同的较低价格。排除它们提升了平均价格。</p><p><strong>注意</strong></p><blockquote><p>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p></blockquote><p><strong>将DISTINCT用于MIN()和MAX()</strong> </p><blockquote><p>虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的</p></blockquote><h2><span id="组合聚集函数">组合聚集函数</span></h2><p>目前为止的所有聚集函数例子都只涉及单个函数。但实际上SELECT语句可根据需要包含多个聚集函数。请看下面的例子：</p><pre><code class="sql">SELECT COUNT(*)AS num_items,MIN(prod_price)AS price_min,MAX(prod_price)AS price_max,AVG(prod_price)AS price_avgFROM products;</code></pre><p><strong>取别名</strong> </p><blockquote><p>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</p></blockquote><h1><span id="x3dx3d第13章-分组数据x3dx3d">&#x3D;&#x3D;第13章 分组数据&#x3D;&#x3D;</span></h1><h2><span id="数据分组">数据分组</span></h2><pre><code class="sql">SELECT COUNT(*)AS num_prodsFROM productsWHERE vend id = 1003;</code></pre><p>这个案例只能返回供应商1003提供的产品数目，如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？<br>这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。</p><h3><span id="创建分组">创建分组</span></h3><pre><code class="sql">SELECT vend_id,COUNT(*) AS num_prodsFROM productsGROUP BY vend_id;</code></pre><blockquote><p>GROUP BY子句指示MySQL&#x3D;&#x3D;<strong>按vend_id排序</strong>并分组数据&#x3D;&#x3D;。这导致对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。因为使用了GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。<u>GROUP BY子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。</u></p></blockquote><p><strong>&#x3D;&#x3D;一些重要的规定：&#x3D;&#x3D;</strong></p><ul><li><p>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制</p></li><li><p>如果在GROUP BY子句中<strong>嵌套了分组，数据将在最后规定的分组上进行汇总</strong>。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</p><pre><code>例如，假设有一个包含以下字段的表格：Country（国家）、City（城市）、Population（人口）。如果使用以下SQL查询语句：SELECT Country, City, SUM(Population)FROM table_nameGROUP BY Country, City;那么数据将首先按照Country字段进行分组，然后在每个Country分组内再按照City字段进行分组。最后，将在最后指定的Country和City分组上进行汇总，计算每个City的人口总数。</code></pre></li><li><p>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（&#x3D;&#x3D;但不能是聚集函数&#x3D;&#x3D;）。<strong>如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</strong></p></li><li><p>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</p></li><li><p>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p></li><li><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p></li></ul><p><strong>使用ROLLUP</strong> </p><blockquote><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值，如下所示：</p></blockquote><pre><code class="sql">SELECT vend_id,COUNT(*)AS num_prodsFROM productsGROUP BY vend_id WITH ROLLUP;</code></pre><h2><span id="过滤分组">过滤分组</span></h2><p>除了能用GROUP BY分组数据外，MySQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，可能想要列出至少有两个订单的所有顾客。为得出这种数据，必须基于完整的分组而不是个别的行进行过滤。<br>我们已经看到了WHERE子句的作用（第6章中引入）。但是，在这个例子中WHERE不能完成任务，因为WHERE过滤指定的是行而不是分组。事实上，WHERE没有分组的概念。那么，不使用WHERE使用什么呢？MySQL为此目的提供了另外的子句，那就是HAVING子句。<u>HAVING非常类似于WHERE。事实上，目前为止所</u><br><u>学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是&#x3D;&#x3D;WHERE过滤行，而HAVING过滤分组。&#x3D;&#x3D;</u></p><pre><code class="sql">SELECT cust_id,COUNT(*)AS ordersFROM ordersGROUP BY cust idHAVING COUNT(*)&gt;=2;</code></pre><blockquote><p>这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(*) &gt;&#x3D;2（两个以上的订单）的那些分组。</p></blockquote><p><strong>HAVING和WHERE的差别</strong> </p><blockquote><p>这里有另一种理解方法&#x3D;&#x3D;，WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。&#x3D;&#x3D;这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组</p></blockquote><p><strong>有没有在一条语句中同时使用WHERE和HAVING子句的需要呢？</strong><br>事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个<br>以上订单的分组。为更好地理解，请看下面的例子，它列出具有2个（含）以上、价格为10（含）以上的产品的供应商：</p><pre><code class="sql">SELECT vend_id,COUNT(*) AS num_prodsFROM productsWHERE prod_price &gt;=10GROUP BY vend idHAVING COUNT(*)&gt;=2;</code></pre><p>WHERE子句过滤所有prod_price至少为10的行。然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。如果没有WHERE子句，将会多检索出两行（供应商1002，销售的所有产品价格都在10以下；</p><h2><span id="分组和排序">分组和排序</span></h2><blockquote><p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p></blockquote><h2><span id="select子句顺序">SELECT子句顺序</span></h2><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table><h1><span id="第14章-使用子查询">第14章 使用子查询</span></h1><blockquote><p>查询（query）： 任何SQL语句都是查询。但此术语一般指SELECT语句。</p></blockquote><blockquote><p>子查询（subquery）：即<strong>嵌套在其他查询中的查询。</strong></p></blockquote><h2><span id="利用子查询进行过滤">利用子查询进行过滤</span></h2><p>本书所有章中使用的数据库表都是关系表（关于每个表及关系的描述，请参阅附录B）。订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的<br>orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。<br>现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索？下面列出具体的步骤。</p><p>(1) 检索包含物品TNT2的所有订单的编号。<br>(2) 检索具有前一步骤列出的订单编号的所有客户的ID。<br>(3) 检索前一步骤返回的所有客户ID的客户信息。</p><p>上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。也可以使用子查询来把3个查询组合成一条语句。第一条SELECT语句的含义很明确，对于prod_id为TNT2的所有订单物品，它检索其order_num列。输出列出两个包含此物品的订单：</p><pre><code class="sql">SELECT order_numFROM orderitemsWHERE prod_id &#39;TNT2&#39;;结果：+--------+order_num----------2000520007+--------+</code></pre><p>下一步，查询具有订单20005和20007的客户ID。</p><pre><code class="sql">SELECT cust idFROM ordersWHERE order_num IN (20005,20007); +--------+|cust_id  ||10001    ||10004    | +--------+</code></pre><p>现在，把第一个查询（返回订单号的那一个）变为子查询组合两个查询。请看下面的SELECT语句：</p><pre><code class="sql">SELECT cust idFROM ordersWHERE order_num IN (SELECT order_num                    FROM orderitems                WHERE prod_id &#39;TNT2&#39;);结果： +--------+|cust_id  ||10001    ||10004    | +--------+</code></pre><p>&#x3D;&#x3D;在SELECT语句中，子查询总是从内向外处理。&#x3D;&#x3D;在处理上面的SELECT语句时，MySQL实际上执行了两个操作。</p><p>首先，它执行下面的查询：</p><pre><code class="sql">SELECT order num FROM orderitems WHERE prod_id=&#39;TNT2</code></pre><p>此查询返回两个订单号：20005和20007。然后，这两个值以IN操作符要求的逗号分隔的格式传递给外部查询的WHERE子句。</p><p>外部查询变成：</p><pre><code class="sql">SELECT cust_id FROM orders WHERE order_num IN (20005,20007)</code></pre><p>可以看到，输出是正确的并且与前面硬编码WHERE子句所返回的值相同。</p><p><strong>&#x3D;&#x3D;格式化SQL&#x3D;&#x3D;</strong></p><blockquote><p>包含子查询的SELECT语句难以阅读和调试，特别是它们较为复杂时更是如此。如上所示把子查询分解为多行并且适当地进行缩进，能极大地简化子查询的使用。</p></blockquote><p>最后一步：</p><pre><code class="sql">SELECT cust_name,cust_contactFROM customersWHERE custid IN (SELECT cust_id                    FROM orders                    WHERE order_num IN (SELECT order_num                                        FROM orderitems                                        WHERE prod_id =&#39;TNT2&#39;));</code></pre><blockquote><p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。<u>对于能嵌套的子查询的数目没有限制</u>，不过在实际使用时由于性能的限制，不能嵌套太多的子查询</p></blockquote><p><strong>列必须匹配</strong></p><blockquote><p>在WHERE子句中使用子查询（如这里所示），&#x3D;&#x3D;应该保证SELECT语句具有与WHERE子句中相同数目的列&#x3D;&#x3D;。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</p></blockquote><p>虽然子查询一般与IN操作符结合使用，但也可以用于测试等于（&#x3D;）、不等于（&lt;&gt;）等。</p><h2><span id="作为计算字段使用子查询">作为计算字段使用子查询</span></h2><blockquote><p><strong>相关子查询（correlated subquery）:</strong> 涉及外部查询的子查询。</p></blockquote><p>假如需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。<br>为了执行这个操作，遵循下面的步骤。<br>(1) 从customers表中检索客户列表。<br>(2) 对于检索出的每个客户，统计其在orders表中的订单数目。</p><pre><code class="sql">SELECT cust_name,cust state,(SELECT COUNT(*FROM ordersWHERE orders.cust_id =  customers.cust_id) As ordersFROM customersORDER BY cust_name;</code></pre><h1><span id="第15章-联结表">第15章 联结表</span></h1><blockquote><p>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p></blockquote><blockquote><p><strong>外键（foreign key）：</strong> 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</p></blockquote><blockquote><p><strong>可伸缩性（scale）：</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。</p></blockquote><h2><span id="创建联结">创建联结</span></h2><pre><code class="sql">SELECT vend_name,prod_name,prod_priceFROM vendors,productsWHERE vendors.vend_id products.vend_idORDER BY vend_name,prod_name;</code></pre><p>表名.列名这种方式是完全限定列名，如果不这样做，而向下面的方式来匹配会造成笛卡儿积的情况</p><pre><code class="sql">SELECT vend_name,prod_name,prod_priceFROM vendors,productsWHERE vend_id = vend_idORDER BY vend_name,prod_name;</code></pre><p><strong>笛卡儿积（cartesian product）</strong> </p><blockquote><p>由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数</p></blockquote><h3><span id="不要忘了where子句"><strong>不要忘了WHERE子句</strong></span></h3><blockquote><p>&#x3D;&#x3D;应该保证所有联结都有WHERE子句，&#x3D;&#x3D;否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。</p></blockquote><blockquote><p>叉联结 ：有时我们会听到返回称为叉联结（cross join）的笛卡儿积的联结类型。</p></blockquote><h3><span id="内部联结">内部联结</span></h3><blockquote><p>上述的联结都是<strong>等值联结（equijoin）</strong>，它基于两个表之间的相等测试，这种联结也称为<strong>内部联结</strong></p></blockquote><p>还有另外一种语法：</p><pre><code class="sql">SELECT vend_name,prod_name,prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id;</code></pre><blockquote><p>此语句中的SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE<br>子句给出。传递给ON的实际条件与传递给WHERE的相同。</p></blockquote><p>一般建议使用这种语法.</p><h3><span id="联结多个表">联结多个表</span></h3><blockquote><p>SQL对一条SELECT语句中可以联结的表的数目没有限制</p></blockquote><p>具体的内容参照<code>15.2.3联结多个表</code></p><h1><span id="第16章-创建高级联结">第16章 创建高级联结</span></h1><h2><span id="使用表别名">使用表别名</span></h2><blockquote><p>表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、ORDER BY子句以及语句的其他部分。</p></blockquote><blockquote><p>应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p></blockquote><h2><span id="使用不同类型的联结">使用不同类型的联结</span></h2><p>迄今为止，我们使用的只是称为<strong>内部联结或等值联结（equijoin）的简单联结</strong>。还有3种其他联结，它们分别是<strong>自联结、自然联结和外部联结。</strong></p><h3><span id="自联结">自联结</span></h3><p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。<br>方法一：子查询</p><pre><code class="sql">SELECT prod_id,prod_nameFROM productsWHERE vend_id (SELECT vend idFROM productsWHERE prod_id =&#39;DTNTR&#39;);</code></pre><p>方法二：自联结</p><pre><code class="sql">SELECT p1.prod_id,p1.prod_nameFROM products As p1,products As p2WHERE p1.vend_id p2.vend_idAND p2.prod_id = &#39;DTNTR&#39;;</code></pre><p><strong>用自联结而不用子查询</strong></p><blockquote><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p></blockquote><h3><span id="自然联结">自然联结</span></h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。&#x3D;&#x3D;自然联结排除多次出现，使每个列只返回一次。&#x3D;&#x3D;</p><p><em><strong>怎样完成这项工作呢？</strong></em></p><p>答案是，系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。下面举一个例子：</p><pre><code class="sql">SELECT C.*o.order_num,o.order_date,oi.prod_id,oi.quantity,OI.item_priceFROM customers AS c,orders As o,orderitems AS oiWHERE C.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id &#39;FB&#39;;</code></pre><p>在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p><blockquote><p>迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结</p></blockquote><h3><span id="x3dx3d外部联结x3dx3d">&#x3D;&#x3D;外部联结&#x3D;&#x3D;</span></h3><blockquote><p>&#x3D;&#x3D;联结包含了那些在相关表中没有关联行的行。&#x3D;&#x3D;这种类型的联结称为外部联结。</p></blockquote><p><strong>相较于内连接(INNER JOIN)的区别：</strong></p><p>内连接：（A和B连接，AB两张表没有主次关系。平等的。）</p><p>外连接：通过LEFT和RIGHT指定哪个表的地位高，如果是LEFT，按照LEFT中的字段和右边表进行匹配，即使没有关联的行也会匹配。</p><p>例如：</p><pre><code>+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+</code></pre><p><strong>思考：外连接的查询结果条数一定是 &gt;&#x3D; 内连接的查询结果条数？</strong><br><strong>正确。</strong></p><p>案例：查询每个员工的上级领导，要求显示所有员工的名字和领导名？</p><pre><code class="sql">select a.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;from emp aleft join emp bon a.mgr = b.empno; 结果：+--------+--------+| 员工名      | 领导名     |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || KING   | NULL   |//[1]| TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+</code></pre><p><code>[1]:</code>可以看到即使KING没有领导，也会被匹配到,这种情况是以员工表a作为主表进行参照的，它的地位大于领导表b。</p><h2><span id="使用带聚集函数的联结">使用带聚集函数的联结</span></h2><p>如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT()函数的代码可完成此工作：</p><pre><code class="sql">SELECT customers.cust name,customers.cust_id,COUNT(orders.order_num) AS num_ordFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id;</code></pre><p>此SELECT语句使用INNER JOIN将customers和orders表互相关联。GROUP BY 子句按客户分组数据， 因此， 函数调用COUNT(orders.order_num)对每个客户的订单计数，将它作为num_ord返回</p><pre><code class="sql">SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num)AS num_ordFROM customers LEFT OUTER JOIN ordersON customers.cust_id=orders.cust_idGROUP BY customers.cust_id;</code></pre><p>这个例子使用左外部联结来包含所有客户，甚至包含那些没有任何下订单的客户。结果显示也包含了客户Mouse House，它有0个订单。</p><h2><span id="使用联结和联结条件">使用联结和联结条件</span></h2><p>在总结关于联结的这两章前，有必要汇总一下关于联结及其使用的<br>某些要点。</p><ul><li>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</li><li>保证使用正确的联结条件，否则将返回不正确的数据。</li><li>应该总是提供联结条件，否则会得出笛卡儿积。</li><li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li></ul><h1><span id="第17章-组合查询">第17章 组合查询</span></h1><h2><span id="组合查询">组合查询</span></h2><blockquote><p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）</p></blockquote><p>有两种基本情况，其中需要使用组合查询：</p><ul><li>在单个查询中从不同的表返回类似结构的数据；</li><li>对单个表执行多个查询，按单个查询返回数据。</li></ul><p><strong>组合查询和多个WHERE条件</strong></p><blockquote><p>多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，&#x3D;&#x3D;任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出&#x3D;&#x3D;，在以下段落中可以看到这一点。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好组合查询和多个WHERE条件 多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出，在以下段落中可以看到这一点。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好</p></blockquote><h2><span id="创建组合查询">创建组合查询</span></h2><h3><span id="使用union">使用UNION</span></h3><p>UNION的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。</p><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;5;</code></pre><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN (1001,1002);</code></pre><p>第一条SELECT检索价格不高于5的所有物品。第二条SELECT使用IN找出供应商1001和1002生产的所有物品。</p><p>组合后的语句：</p><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;=5UNIONSELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN (1001,1002);</code></pre><p>等价于：</p><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;=5OR vend_id IN(1001,1002); //注意这里是OR</code></pre><h3><span id="union规则">UNION规则</span></h3><ul><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个<br>  UNION关键字）。</li><li>UNION中的每个查询&#x3D;&#x3D;必须包含相同的列、表达式或聚集函数&#x3D;&#x3D;（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。<br>  如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。</li></ul><h3><span id="包含或取消重复的行">包含或取消重复的行</span></h3><p>前面的案例中第一条SELECT语句的查询结果有一条和第二个SELECT语句重复了但在UNION两条语句后过滤掉了，这种场合下如果想返回所有匹配行(重复出现的行)，可使用UNION ALL而不是UNION</p><p><strong>UNION与WHERE</strong> </p><blockquote><p>本章开始时说过，UNION几乎总是完成与多个WHERE条件相同的工作。UNION ALL为UNION的一种形式，它完成WHERE子句完成不了的工作。<strong>如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用UNION ALL而不是WHERE。</strong></p></blockquote><h3><span id="对组合查询结果排序">对组合查询结果排序</span></h3><blockquote><p>SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，<strong>它必须出现在最后一条SELECT语句之后</strong>。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此<strong>不允许使用多条ORDER BY子句。</strong></p></blockquote><p><strong>组合不同的表</strong></p><blockquote><p>为使表述比较简单，本章例子中的组合查询使用的均是相同的表。但是其中使用UNION的组合查询可以应用不同的表，但请检查UNION的第二条规则，只有在两个表包含一样的列才可以这样做。</p></blockquote><h1><span id="第19章-插入数据">第19章 插入数据</span></h1><p>INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：</p><ul><li>插入完整的行；</li><li>插入行的一部分；</li><li>插入多行；</li><li>插入某些查询的结果</li></ul><h2><span id="插入完整的行">插入完整的行</span></h2><pre><code class="sql">INSERT INTO CustomersVALUES (NULL,&#39;Pep E.LaPew&#39;,&#39;100 Main Street&#39;,&#39;Los Angeles&#39;,&#39;CA,&#39;90046&#39;,&#39;USA&#39;,NULL,NULL);</code></pre><blockquote><p><strong>没有输出：</strong> INSERT语句一般不会产生输出。</p></blockquote><ul><li><p>对每个列必须提供一个值。如果某个列没有值（如上面的cust_contact和cust_email列），应该使用NULL值（假定表允许对该列指定空值）。</p></li><li><p>各个列必须以它们在表定义中出现的次序填充。</p></li><li><p>第一列cust_id也为NULL。这是因为每次插入一个新行时，该列由MySQL自动增量。你不想给出一个值（这是MySQL的工作），又不能省略此列（如前所述，必须给出每个列），所以指定一个NULL值（它被MySQL忽略，MySQL在这里插入下一个可用的cust_id值）。</p></li></ul><blockquote><p><strong>这种语法很简单，但并不安全，应该尽量避免使用</strong></p></blockquote><p><strong>总是使用列的列表</strong></p><blockquote><p>一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化</p></blockquote><p><strong>仔细地给出值</strong> </p><blockquote><p>不管使用哪种INSERT语法，都必须给出VALUES的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功</p></blockquote><p>使用这种语法，还可以省略列。这表示可以只给某些列提供值，给其他列不提供值</p><p>省略的列必须满足以下某个条件。</p><ul><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值</li></ul><p>如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级</p><pre><code class="sql">INSERT LOW_PRIORITY INTO</code></pre><p>这也适用于下一章介绍的UPDATE和DELETE语句</p><h2><span id="插入多个行">插入多个行</span></h2><pre><code class="sql">INSERT INTO customers (cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&#39;Pep E.LaPew&#39;,&#39;100 Main Street&#39;,&#39;Los Angeles&#39;,&#39;CA&#39;,190046,&#39;USA&#39;);INSERT INTO customers (cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&#39;M.Martian&#39;,&#39;42 Galaxy Way&#39;,&#39;New York&#39;,&#39;NY&#39;,11213&#39;,&#39;USA);</code></pre><p>只要每条INSERT语句中的列名（和次序）相同，可以如下组合各语句：</p><pre><code class="sql">INSERT INTO customers (cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&#39;Pep E.LaPew&#39;,&#39;100 Main Street&#39;,&#39;Los Angeles&#39;,&#39;CA&#39;,90046&#39;,USA),(&#39;M.Martian&#39;,42 Galaxy Way&#39;,New York&#39;,&#39;NY&#39;11213&#39;,&#39;USA);</code></pre><p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔</p><p><strong>提高INSERT的性能</strong></p><blockquote><p>此技术可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。</p></blockquote><h2><span id="插入检索出的数据">插入检索出的数据</span></h2><blockquote><p>INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中</p></blockquote><p>&#x3D;&#x3D;注意，被插入的表结构必须和被检索的表的表结构一致，同时在填充这个新表时不能使用被检索表中的主键值，这样主键值会重复导致后续的插入会失败。&#x3D;&#x3D;可以在检索的列中仅省略这列值（从INSERT和SELECT中,两个都省略））让MySQL在导入数据的过程中产生新值。</p><pre><code class="sql">INSERT INTO customers(cust_id,    cust contact,    cust_email,    cust_name,    cust address,    cust_city,    cust_state,    cust_zip,    cust_country)SELECT cust_id,    cust_contact,    cust_email,    cust name,    cust_address,    cust_city,    cust_state,    cust_zip,    cust countryFROM custnew;</code></pre><h1><span id="第20章-更新和删除数据">第20章 更新和删除数据</span></h1><h2><span id="更新数据">更新数据</span></h2><p>为了更新（修改）表中的数据，可使用UPDATE语句。可采用两种方式使用UPDATE：</p><ul><li>更新表中特定行；</li><li>更新表中所有行。</li></ul><p><strong>不要省略WHERE子句</strong> </p><blockquote><p>在使用UPDATE时一定要注意细心。因为稍不注意，就会更新表中所有行</p></blockquote><p>UPDATE语句由3部分组成</p><ul><li><p>要更新的表；</p></li><li><p>列名和它们的新值</p></li><li><p>确定要更新行的过滤条件。</p></li></ul><p>更新单个列</p><pre><code class="sql">UPDATE customersSET cust_name &#39;The Fudds&#39;WHERE custid 10005;</code></pre><p>更新多个列，使用<code>,</code>分隔：</p><pre><code class="sql">UPDATE customersSET cust_name &#39;The Fudds&#39;,cust_email &#39;elmer@fudd.com&#39;WHERE custid 10005;</code></pre><p><strong>在UPDATE语句中使用子查询</strong> </p><blockquote><p>UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</p></blockquote><p><strong>IGNORE关键字</strong></p><blockquote><p>**&#x3D;&#x3D;如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消&#x3D;&#x3D;**（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：UPDATE IGNORE customers…</p></blockquote><p>&#x3D;&#x3D;为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）&#x3D;&#x3D;。如下进行：</p><pre><code class="sql">UPDATE customersSET cust_email=NULLWHERE cust_id = 10005;</code></pre><h2><span id="删除数据">删除数据</span></h2><p>为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方式使用DELETE：</p><ul><li>从表中删除特定的行；</li><li>从表中删除所有行</li></ul><p><strong>不要省略WHERE子句</strong> </p><blockquote><p>在使用DELETE时一定要注意细心。因为稍不注意，就会错误地删除表中所有行,这一点和UPDATE语句一样</p></blockquote><p>删除一行数据：</p><pre><code class="sql">DELETE FROM customersWHERE cust_id = 10006;</code></pre><p>删除所有数据：</p><pre><code class="sql">DELETE FROM customers;</code></pre><blockquote><p>DELETE不需要列名或通配符。DELETE删除整行而不是删除列。&#x3D;&#x3D;为了删除指定的列，请使用UPDATE语句。&#x3D;&#x3D;</p></blockquote><p><strong>删除表的内容而不是表</strong> </p><blockquote><p>DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身,删除表的语句为drop table 表名；</p></blockquote><p><strong>更快的删除</strong> </p><blockquote><p>如果想从表中删除所有行，不要使用DELETE。可使用<code>TRUNCATE TABLE</code>语句，它完成相同的工作，但速度更快（<strong>TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据</strong>）**,但delete删除可以回滚数据，Truncate则不行。**</p></blockquote><h2><span id="更新和删除的指导原则">更新和删除的指导原则</span></h2><p>MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。</p><h1><span id="第21章-创建和操纵表">第21章 创建和操纵表</span></h1><h2><span id="创建表">创建表</span></h2><pre><code class="sql">CREATE TABLE customers(cust_id  int NOT NULL AUTO INCREMENT,cust_name char(50) NOT NULL,cust_address char(50) NULL,cust_city  char(50) NULL,cust_state   char(5) NULL,cust_zip     char(10) NULL,cust_country char(50) NULL,cust_contact char(50) NULL,cust_email   char(255) NULL,PRIMARY KEY (cust id))ENGINE=InnoDB;</code></pre><p><strong>处理现有的表</strong> </p><blockquote><p>在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。如果你仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS。这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。&#x3D;&#x3D;如果表存在就<code>drop table if exists 表名;</code>&#x3D;&#x3D;</p></blockquote><h3><span id="使用null值">使用NULL值</span></h3><ul><li><p>允许NULL值的列也允许在插入行时不给出该列的值。</p></li><li><p>不允许NULL值的列不接受该列没有值的行，换句话说，<strong>在插入或更新行时，该列必须有值，如果该列没有值将返回错误，且插入失败</strong></p></li><li><p>如果创建表不指定NOT NULL，则认为指定的是NULL。</p></li></ul><p><strong>理解NULL</strong> </p><blockquote><p>不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定</p></blockquote><h3><span id="主键再介绍复合主键">主键再介绍(复合主键)</span></h3><ul><li><p>主键值必须唯一。即表中的每个行必须具有唯一的主键值。</p></li><li><p>如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一，叫做<strong>复合主键</strong></p></li></ul><p>复合主键的添加：为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名</p><pre><code class="sql">CREATE TABLE orderitems(order_num int NOT NULL,order_item int NOT NULLprod_id char(10) NOT NULLquantity int NOT NULLitem_price decimal(8,2) NOT NULL,PRIMARY KEY (order_num,order_item))ENGINE=InnoDB;</code></pre><p>orderitems表包含orders表中每个订单的细节。每个订单有多项物品，但每个订单任何时候都只有1个第一项物品，1个第二项物品，如此等等。因此，订单号（order_num列）和订单物品（order_item列）的组合是唯一的，从而适合作为主键，其定义为：</p><p><code>PRIMARY KEY (order_num,order_item)</code></p><blockquote><p>主键可以在创建表时定义（如这里所示），或者在创建表之后定义</p></blockquote><p><strong>主键和NULL值</strong> </p><blockquote><p>第1章介绍过，主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识</p></blockquote><h3><span id="使用auto_increment">使用AUTO_INCREMENT</span></h3><pre><code class="sql">cust_id int NOT NULL AUTO INCREMENT,</code></pre><p>AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTO_INCREMENT），&#x3D;&#x3D;每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。&#x3D;&#x3D;</p><p><strong>覆盖AUTO_INCREMENT</strong></p><blockquote><p>如果一个列被指定为AUTO_INCREMENT，则它需要使用特殊的值吗？你可以简单地在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将开始使用该手工插入的值，从插入的值开始增。</p></blockquote><p><strong>确定AUTO_INCREMENT值</strong> </p><blockquote><p>让MySQL生成（通过自动增量）主键的一个缺点是你不知道这些值都是谁。</p></blockquote><p>案例：考虑这个场景：你正在增加一个新订单。这要求在orders表中创建一行，然后在orderitms表中对订购的每项物品创建一<br>行。order_num在orderitems表中与订单细节一起存储。这就是为什么orders表和orderitems表为相互关联的表的原因。这显然要求你在插入orders行之后，插入orderitems行之前知道生成的order_num（就是在orders表中最后行插入的主键值）。</p><p>可使用last_insert_id()函数获得这个值，如下所示：</p><p><code>SELECT last_insert_id()</code>,此语句返回最后一个AUTO_INCREMENT值（<strong>针对最近插入的那个表</strong>），然后可以将它用于后续的MySQL语句</p><h3><span id="指定默认值">指定默认值</span></h3><p>默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定</p><pre><code class="sql">CREATE TABLE orderitemsorder_num int NOT NULL,order_item int NOT NULLprod_id char(10) NOT NULL,quantity int NOT NULL DEFAULT 1,item_price decimal(8,2)  NOT NULLPRIMARY KEY (order_num,order_item)ENGINE=InnoDB:</code></pre><p><strong>不允许函数</strong> </p><blockquote><p>与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量</p></blockquote><p><strong>使用默认值而不是NULL值</strong> </p><blockquote><p>许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。</p></blockquote><h2><span id="x3dx3d更新表x3dx3d">&#x3D;&#x3D;更新表&#x3D;&#x3D;</span></h2><blockquote><p>为更新表定义，可使用ALTER TABLE语句。但是，理想状态下，&#x3D;&#x3D;当表中存储数据以后，该表就不应该再被更新&#x3D;&#x3D;</p></blockquote><p>下面的例子给表添加一个列:</p><pre><code class="sql">ALTER TABLE vendorsADD vend_phone CHAR(20);</code></pre><p>这条语句给vendors表增加一个名为vend_phone的列，&#x3D;&#x3D;必须明确其数据类型。&#x3D;&#x3D;</p><p>删除刚刚添加的列：</p><pre><code class="sql">ALTER TABLE VendorsDROP COLUMN vend_phone;</code></pre><p>ALTER TABLE的一种常见用途是定义外键。下面是用来表所用的外键的代码：</p><pre><code class="sql">ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num)REFERENCES orders (order_num);ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);ALTER TABLE ordersADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);ALTER TABLE productsADD CONSTRAINT fk_products_vendorsFOREIGN KEY (vend_id)REFERENCES vendors (vend_id);</code></pre><p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p><ul><li><p>用新的列布局创建一个新表；</p></li><li><p>使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅第19章）从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；</p></li><li><p>检验包含所需数据的新表；</p></li><li><p>重命名旧表（如果确定，可以删除它）；</p></li><li><p>用旧表原来的名字重命名新表；</p></li><li><p>根据需要，重新创建触发器、存储过程、索引和外键。</p></li></ul><p><strong>小心使用ALTER TABLE</strong> </p><blockquote><p>使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。&#x3D;&#x3D;数据库表的更改不能撤销&#x3D;&#x3D;，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p></blockquote><h2><span id="删除表">删除表</span></h2><p>删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语句即可：</p><pre><code class="sql">DROP TABLE customers2;</code></pre><p>这条语句删除customers 2表（假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。</p><h2><span id="重命名表">重命名表</span></h2><p>使用RENAME TABLE语句可以重命名一个表：</p><pre><code class="sql">RENAME TABLE customers2 TO customers;</code></pre><p>对多个表重命名：</p><pre><code class="sql">RENAME TABLE backup_customers TO customers            backup_vendors TO vendors,            backup_products TO products;</code></pre><h1><span id="第22章-使用视图">第22章 使用视图</span></h1><blockquote><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p></blockquote><h2><span id="为什么使用视图">为什么使用视图?</span></h2><ul><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><blockquote><p>视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。<br>在添加或更改这些表中的数据时，视图将返回改变过的数据。</p></blockquote><p><strong>性能问题</strong></p><blockquote><p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p></blockquote><h3><span id="视图的规则和限制">视图的规则和限制</span></h3><ul><li>与表一样，视图必须&#x3D;&#x3D;唯一命名&#x3D;&#x3D;（&#x3D;&#x3D;不能给视图取与别的视图或表相同的名字&#x3D;&#x3D;）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该<u>视图中ORDER BY将被覆盖。</u></li><li>&#x3D;&#x3D;视图不能索引，也不能有关联的触发器或默认值&#x3D;&#x3D;</li><li>&#x3D;&#x3D;视图可以和表一起使用&#x3D;&#x3D;。例如，编写一条联结表和视图的SELECT语句。</li></ul><h2><span id="使用视图">使用视图</span></h2><ul><li><p>视图用CREATE VIEW语句来创建。</p></li><li><p>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</p></li><li><p>用DROP删除视图，其语法为DROP VIEW viewname;。</p></li><li><p>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</p></li></ul><pre><code class="sql">CREATE VIEW productcustomers ASSELECT cust_name,cust_contact,prod_idFROM customers,orders,orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_num;</code></pre><p>使用这个视图：</p><pre><code class="sql">SELECT cust_name,cust_contactFROM productcustomersWHERE prod_id &#39;TNT2&#39;;</code></pre><p><strong>WHERE子句与WHERE子句</strong> </p><blockquote><p>如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p></blockquote><h2><span id="x3dx3d更新视图x3dx3d">&#x3D;&#x3D;更新视图&#x3D;&#x3D;</span></h2><p>视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。<strong>如果你对视图增加或删除行，实际上是对其基表增加或删除行。</strong></p><p>&#x3D;&#x3D;如果视图定义中有以下操作，则不能进行视图的更新：&#x3D;&#x3D;</p><ol><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；(查询结果当作where子句条件)</li><li>并；(union,union all)</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ol><p><strong>将视图用于检索</strong> </p><blockquote><p>一般，应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。</p></blockquote><pre><code class="sql">DROP VIEW if EXISTS emp_view;CREATE VIEW emp_view  as SELECT emp.*,dept.DNAME,dept.LOCFROM empJOIN depton emp.DEPTNO=dept.DEPTNO;#案例1：INSERT INTO emp_view(EMPNO,ENAME,JOB)VALUES(1000,&#39;王五&#39;,&#39;SALESMAN&#39;);UPDATE emp_view set DEPTNO=20,MGR=7499 WHERE ENAME=&#39;王五&#39; //不报错，但不起作用DELETE FROM emp_view WHERE ENAME=&#39;王五&#39;;//执行失败#案例2：INSERT INTO emp_view(EMPNO,ENAME,DEPTNO)VALUES(2000,&#39;张三&#39;,20);UPDATE emp_view set Job=&#39;SALESMAN&#39; WHERE ENAME=&#39;张三&#39;;//不报错，起作用DELETE FROM emp_view WHERE ENAME=&#39;王五&#39;;//执行失败,因为涉及多个表，delete失败。</code></pre><p>这里实测了一下，插入成功，但是只在emp表中看到了这个数据，在视图中没有，并且执行update无变化，delete会报错，是因为在插入的时候没有指定它的deptno，因此在不满足视图中的语句，所以无法更新和删除。张三这条数据就正常更新了，但还是不能删除，&#x3D;&#x3D;因为对依赖于多个基本表的视图，不能使用DELETE语句。&#x3D;&#x3D;</p><h1><span id="x3dx3d第23章-使用存储过程函数x3dx3d">&#x3D;&#x3D;第23章 使用存储过程(函数)&#x3D;&#x3D;</span></h1><blockquote><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p></blockquote><ul><li>通过把处理封装在容易使用的单元中，简化复杂的操作（正如前<br>  面例子所述）。</li><li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过<br>  程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li><li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要<br>  知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</li><li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li><li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可<br>  以看到。）</li></ul><blockquote><p>简而言之：使用存储过程有3个主要的好处，即&#x3D;&#x3D;简单、安全、高性能。&#x3D;&#x3D;</p></blockquote><h2><span id="使用存储过程">使用存储过程</span></h2><pre><code class="sql">CALL productpricing(apricelow,                    @pricehigh,                    @priceaverage);</code></pre><blockquote><p>执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格</p></blockquote><blockquote><p>存储过程可以显示结果，也可以不显示结果</p></blockquote><ul><li>创建存储过程：</li></ul><pre><code class="sql">CREATE PROCEDURE productpricing(BEGINSELECT Avg(prod_price) AS priceaverageFROM products;END;</code></pre><p>此存储过程名为productpricing，如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。BEGIN和END语句用来限定存储过程体，<strong>过程体</strong>本身仅是一个简单的SELECT语句。</p><p><strong>&#x3D;&#x3D;mysql命令行客户机的分隔符(就是在CMD窗口运行的mysql)&#x3D;&#x3D;</strong> </p><blockquote><p>默认的MySQL语句分隔符为;（mysql命令行实用程序也使用;作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。解决办法是临时更改命令行实用程序的语句分隔符，如下所示：其中，DELIMITER &#x2F;&#x2F;告诉命令行实用程序使用&#x2F;&#x2F;作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为END&#x2F;&#x2F;而不是END;。这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符可使用DELIMITER ;。除\符号外，任何字符都可以用作语句分隔符。如果你使用的是mysql命令行实用程序，在阅读本章时请记住这里的内容。</p></blockquote><ul><li>使用存储过程：</li></ul><pre><code class="sql">CALL productpricing();</code></pre><p>因为存储过程实际上是一种函数，所以存储过程名后需要有()符号（即使不传递参数也需要）。</p><h3><span id="删除存储过程">删除存储过程</span></h3><pre><code class="sql">DROP PROCEDURE productpricing;//注意后面没有括号</code></pre><p><strong>仅当存在时删除</strong> </p><blockquote><p>如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。</p></blockquote><pre><code class="sql">DROP procedure if EXISTS f1;//如果存在f1函数就删除它类似用法：DROP table if EXISTS t1;DROP view if EXISTS v1;</code></pre><h3><span id="使用参数">使用参数</span></h3><p>存储过程并不显示结果，而是把结果返回给你指定的变量。</p><blockquote><p><strong>变量（variable）</strong>:内存中一个特定的位置，用来临时存储数据</p></blockquote><ul><li>使用OUT参数：</li></ul><pre><code class="sql">CREATE PROCEDURE productpricing(    OUT p1 DECIMAL(8,2),    OUT ph DECIMAL(8,2),    OUT pa DECIMAL(8,2))BEGINSELECT Min(prod_price)//注意INTO的位置INTO plFROM products;SELECT Max(prod_price)INTO phFROM products;SELECT Avg(prod_price)INTO paFROM products;END;</code></pre><p>此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。</p><p><strong>参数的数据类型</strong> </p><blockquote><p>存储过程的参数允许的数据类型与表中使用的数据类型相同。附录D列出了这些类型。&#x3D;&#x3D;注意，记录集不是允许的类型，因此，不能通过一个参数返回多个行和列&#x3D;&#x3D;。这就是前面的例子为什么要使用3个参数（和3条SELECT语句）的原因。</p></blockquote><pre><code class="sql">CALL productpricing (apricelow,                    @pricehigh,                    @priceaverage);</code></pre><p>这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。</p><blockquote><p><strong>变量名 ：</strong>所有MySQL变量都必须以@开始。</p></blockquote><ul><li>根据变量检索：</li></ul><pre><code class="sql">SELECT @priceaverage;</code></pre><pre><code class="sql">SELECT @pricehigh,@pricelow,@priceaverage;</code></pre><ul><li>同时使用OUT和IN参数：</li></ul><pre><code class="sql">CREATE PROCEDURE ordertotal(IN onumber INT,OUT ototal DECIMAL(8,2))BEGINSELECT Sum(item_price*quantity)FROM orderitemsWHERE order num = onumberINTO ototal;END;</code></pre><p>onumber定义为IN，因为订单号被传入存储过程。ototal定义为OUT，因为要从存储过程返回合计。SELECT语句使用这两个参数，WHERE子句使用onumber选择正确的行，INTO使用ototal存储计算出来的合计</p><pre><code class="sql">CALL ordertotal(20005,@total);//第一个是传入的值，第二个是接收返回的值</code></pre><p>第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。</p><p>为了得到另一个订单的合计显示，需要再次调用存储过程，然后重新显示变量，&#x3D;&#x3D;这样会覆盖原来total的值。&#x3D;&#x3D;</p><pre><code class="sql">CALL ordertotal(20009,@total);SELECT @total;//它的值改变为20009订单号对应的</code></pre><h3><span id="建立智能存储过程">建立智能存储过程</span></h3><blockquote><p>参照原书</p></blockquote><h3><span id="检查存储过程">检查存储过程</span></h3><blockquote><p>为显示用来创建一个存储过程的CREATE语句，使用<code>SHOW CREATE PROCEDURE</code>语句：</p></blockquote><pre><code class="sql">SHOW CREATE PROCEDURE ordertotal;</code></pre><blockquote><p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE  STATUS。</code></p></blockquote><p><strong>限制过程状态结果</strong> </p><blockquote><p>SHOW PROCEDURE STATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，例如：</p></blockquote><pre><code class="sql">SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;;</code></pre><h1><span id="拓展">拓展</span></h1><h2><span id="mysql数据类型">Mysql数据类型</span></h2><h3><span id="int类型">int类型</span></h3><p>int(10)表示的是无符号的整型数，而int(11)代表有符号的整型(前面一位用来表示符号)，这一点和其他的类型有区别。</p><p>相当于加了unsigned关键字设置为无符号。</p><h3><span id="char类型">char类型</span></h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11 异常（Exception）</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/11%20%E5%BC%82%E5%B8%B8%EF%BC%88Exception%EF%BC%89/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/11%20%E5%BC%82%E5%B8%B8%EF%BC%88Exception%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="11-异常exception">11 异常（Exception）</span></h1><blockquote><p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”（开发过程中的语法错误和逻辑错误不是异常）</p><p>这些 异常事件 可分为两类：</p><ul><li><p>Error（错误）：Java 虚拟机无法解决的严重问题。</p><p>  如：JVM 系统内部错误，资源耗尽等严重情况。Error 是严重错误，程序会崩溃。</p></li><li><p>Exception：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。</p><p>  如：空指针访问，试图读取不存在的文件，网络中断等等。</p><p>  Exception 又分为两大类：</p><ul><li>运行时异常（程序运行时，发生的异常）</li><li>编译时异常（编程时，编译器检查出的异常）</li></ul></li></ul></blockquote><h2><span id="111-异常体系图">11.1 异常体系图</span></h2><blockquote><p>编译异常（受检异常） 和 运行异常（非受检异常）</p><p>Java 源程序 ——(javac.exe)——&gt; 字节码文件 ——(java.exe)——&gt; 在内存中加载，运行类</p><p> 编译异常↑ 运行异常↑</p></blockquote><p><a href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg=="><img src="https://i-melody.github.io/img/Java_InputImage/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE_11.1.webp" alt="img"></a></p><p> <em>（异常体系图_11.1）</em></p><p>异常分为两大类：运行时异常 和 编译时异常</p><ul><li><p>运行时异常，编译器不要求强制处置的异常。一般是指编程的逻辑错误，是程序员应该避免其出现的异常。</p><p>  java.lang.RuntimeException 类及它的子类都是运行时异常</p><p>  对于运行时异常，可以不做处理。因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响</p></li><li><p>编译时异常，是编译器要求必须处置的异常</p></li></ul><h3><span id="1111-常见的运行时异常">11.1.1 常见的运行时异常</span></h3><blockquote><p>常见的运行时异常（RuntimeException）包括</p><ul><li>NullPointerException：空指针异常</li><li>ArithmeticException：数学运算异常</li><li>ArrayIndexOutOfBoundsException：数组下标越界异常</li><li>ClassCastException：类型转换异常</li><li>NumberFormatException：数学格式异常</li></ul></blockquote><p><strong>空指针异常</strong></p><ul><li>当应用程序试图在需要对象的地方使用 null 时，抛出该异常。</li></ul><blockquote><pre><code>String str = null;int n = str.length;//这里，出现了 空指针异常JAVA</code></pre></blockquote><p><strong>数学运算异常</strong></p><ul><li>当出现异常的运算条件时，抛出该异常。</li></ul><blockquote><pre><code>double n = 100 / 0;//这里，出现了 数学运算异常JAVA</code></pre></blockquote><p><strong>数组下标越界异常</strong></p><ul><li>用非法索引（为负或超出范围）访问数组时，抛出该异常。</li></ul><blockquote><pre><code>int[] nums = &#123;0, 0, 0, 0&#125;;nums[-50] = 100;//这里，出现了 数组下标越界异常JAVA</code></pre></blockquote><p><strong>类型转换异常</strong></p><ul><li>当试图把对象强制转换为不是实例的子类时，抛出该异常。</li></ul><blockquote><pre><code>public class Example &#123;    public static void main(String[] args)&#123;        A a1 = new A1();        A2 a1 = (A2)a1;//这里，出现了 类型转换异常    &#125;&#125;class A &#123;&#125;class A1 extends A &#123;&#125;class A2 extends A &#123;&#125;JAVA</code></pre></blockquote><p><strong>数字格式不正确异常</strong></p><ul><li>当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li></ul><blockquote><pre><code>String str = &quot;ABC&quot;;int num = Integer.parseInt(str);//这里，出现了 数字格式不正确异常JAVA</code></pre></blockquote><h3><span id="1112-常见的编译异常">11.1.2 常见的编译异常</span></h3><blockquote><p>常见的编译异常：</p><ul><li>SQLException：操作数据库时，查询表可能发生异常</li><li>IOException：操作文件时，发生的异常</li><li>FileNotFoundException：操作一个不存在的文件时，发生的异常</li><li>ClassNotFoundException：加载类，而该类不存在时，发生的异常</li><li>EOFException：操作文件，到文档末尾，发生的异常</li><li>IllegalArguementException：参数异常</li></ul></blockquote><p>因为还没有学习 SQL、文件编程 等，这里不举例子</p><h2><span id="112-异常处理">11.2 异常处理</span></h2><blockquote><p>异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是 <code>throws</code></p><ul><li><code>try - chatch - finally</code>：程序员在代码中捕获发生的异常，自行处理</li><li><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是 JVM</li></ul></blockquote><h3><span id="1121-try-catch-异常处理">11.2.1 <code>try - catch</code> 异常处理</span></h3><blockquote><p>Java 提供 try 和 catch 块 来处理异常。try 块用于包含可能出错的代码，catch 块用于处理 try 块中的异常。可以根据需要在程序中有多个 <code>try - catch</code> 块。</p></blockquote><blockquote><p>基本语法</p><pre><code>try &#123;    //可疑代码    //将异常生成对应的异常对象，传递给 catch 块&#125; catch(Exception e) &#123;    //如果发生异常，执行这些代码&#125; finally &#123;    //无论是否异常，都执行这些代码    //finally 块可以不写&#125;JAVA</code></pre></blockquote><blockquote><p>快捷键：选中代码后按 ctrl + alt + T</p></blockquote><h4><span id="11211-使用细节">#11.2.1.1 使用细节</span></h4><ol><li><p>如果异常发生了，则异常发生后面的代码块都不执行，直接进入 catch 块</p></li><li><p>如果异常未发生，则顺序执行 try 代码块，catch 块不执行</p></li><li><p>如果希望不管是否异常，都执行一些代码，则使用 finally</p></li><li><p>可以有多个 catch 捕获不同的异常。要求 子类异常在前，父类异常在后。</p><blockquote><pre><code>try &#123;    ...&#125; catch (NullPointerException e) &#123;    ...&#125; catch (ArithmeticException e) &#123;    ...&#125; catch (ArrayIndexOutOfBoundsException e) &#123;    ...&#125; catch (Exception e)&#123;    ...&#125;JAVA</code></pre></blockquote></li><li><p>可以进行 try - finally 配合使用（不写 catch）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。</p><p> 应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p></li><li><p>如果没有出现异常，执行 try 中所有语句，不执行 catch 语句，最后执行 finally 语句</p></li><li><p>如果出现异常，则 try 块异常发生后，剩余语句不执行。之后执行 catch 语句，最后，执行 finally 语句。</p></li></ol><h3><span id="1122-throws-异常处理">11.2.2 <code>throws</code> 异常处理</span></h3><blockquote><p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理</p><p>在方法中声明 <code>throws</code> 语句可以声明抛出异常的列表。<code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p></blockquote><blockquote><p>语法</p><pre><code>public void metord() throws FileNontFoundException ,NullPointerException &#123;    ...&#125;JAVA</code></pre></blockquote><h4><span id="11221-使用细节">#11.2.2.1 使用细节</span></h4><ol><li>对于 <strong>编译异常</strong>，程序中必须处理。</li><li>对于 <strong>运行异常</strong>，程序中诺没有处理，默认处理是 <code>throws</code></li><li>子类 重写 父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。</li><li>如果有 <code>try - catch</code> 就不必 <code>throws</code> 了</li></ol><h2><span id="113-自定义异常">11.3 自定义异常</span></h2><blockquote><p>当程序中出现了某些 “错误”，但该信息并未在 <code>Throwable</code> 子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息</p></blockquote><ol><li>定义类：自定义异常类名，继承 RuntimeException 或 Exception</li><li>如果继承 Exception，属于 编译异常。</li><li>如果继承 RuntimeException，属于 运行异常。（一般来说，选这个。这样利用了默认处理机制，更方便）</li></ol><blockquote><pre><code>&gt;class Metords &#123;   public void method() &#123;       int n = 10;       if(n &gt; 100)&#123;           throw new CustomException(&quot;不能大于100&quot;);       &#125;   &#125;&gt;&#125;&gt;class CustomException extends RuntimeException &#123;public CustomException(String message) &#123;    super(message);&#125;&gt;&#125;JAVA</code></pre></blockquote><h3><span id="1131-throw-和-throws">11.3.1 <code>throw</code> 和 <code>throws</code></span></h3><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td><code>throws</code></td><td>异常处理的一种方式</td><td>方法声明时</td><td>异常类型</td></tr><tr><td><code>throw</code></td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><h3><span id="1132-编程小技巧">11.3.2 编程小技巧</span></h3><p>老韩曰：编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 枚举和注解</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/10%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="10-枚举和注解">10 枚举和注解</span></h1><h2><span id="101-枚举">10.1 枚举</span></h2><p>把具体的对象一一列举出来的类，就称为 枚举类（enumeration）</p><p>实现方法：</p><ol><li>自定义枚举</li><li><code>enum</code> 关键字枚举</li></ol><h3><span id="1011-自定义枚举">10.1.1 自定义枚举</span></h3><ol><li>构造器私有化</li><li>去掉 set 方法（可保留 get），防止属性被修改。因为枚举对象值通常为只读</li><li>在类内部直接创建固定对象。使用 <code>final</code> + <code>static</code> 共同修饰，对象名通常全部大写。</li><li>枚举对象按照需要可以有多个属性</li></ol><h3><span id="1012-enum-关键字">10.1.2 <code>enum</code> 关键字</span></h3><pre><code class="java">enum Example &#123; RED(&quot;小红&quot;, 10), BLUE(&quot;小蓝&quot;, 11), YELLOW; //这句话要放在前面，第三个是无参 private String name; private int age; private Example(String name, int age) &#123;     this.name = name;     this.age = age; &#125;&#125;</code></pre><ol><li>用关键字 <code>enum</code> 替代 <code>class</code></li><li>用 <code>常量名.(形参列表);</code> 代替创建对象（放在前面）。多个对象的场合，用 <code>,</code> 间隔。</li><li>如果使用 <code>enum</code> 枚举，要求将常量对象写在前面</li></ol><h4><span id="10121-使用细节">#10.1.2.1 使用细节</span></h4><ol><li><p>当我们用 <code>enum</code> 关键字开发一个枚举类时，默认会继承 java.lang.Enum 类，而且是一个 <code>final</code> 类。</p><p> 这样，我们就能使用 Enum 中的相关方法。</p><p> <strong>也正因为如此，&#x3D;&#x3D;<code>enum</code> 类不能继承其他类，亦不能被其它类继承&#x3D;&#x3D;</strong></p><p> 不过，&#x3D;&#x3D;<code>enum</code> 类和其他类一样，可以实现接口&#x3D;&#x3D;。</p></li><li><p>传统的 <code>public ststic final RED(&quot;小红&quot;, 10);</code> 简化为 <code>RED(&quot;小红&quot;, 10);</code></p></li><li><p>如果使用无参构造器创建枚举对象，则 实参列表 和 <code>( )</code> 都能省略</p></li></ol><h4><span id="10122-enum-类中的常用方法">#10.1.2.2 <code>Enum</code> 类中的常用方法</span></h4><ul><li><code>valueOf</code>：将字符串转换成枚举对象。要求字符串必须是已有的常量名，否则报异常。</li><li><code>values</code>：返回一个数组 <code>Example[]</code>，其中包含定义的所有枚举对象</li><li><code>getDeclaringClass</code>：得到枚举常量所属的 <code>class</code></li><li><code>name</code>：得到当前枚举常量的名称。建议优先用 <code>toString</code></li><li><code>ordinal</code>：输出该枚举对象的次序&#x2F;编号（从 0 开始编号。如上例 <code>BLUE.ordinal = 1</code>）</li><li><code>compareTo</code>：比较两个枚举常量的编号（调用常量编号 减去 传入常量编号）</li><li><code>clone</code>：&#x3D;&#x3D;枚举类不能 <code>clone</code>，所以，这是一个只会抛出异常的方法&#x3D;&#x3D;</li></ul><h3><span id="1013-enumeration接口">10.1.3 Enumeration接口</span></h3><blockquote><p>Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。这种传统接口已被迭代器取代，虽然Enumeration 还未被遗弃，但在现代代码中已经被很少使用了。尽管如此，它还是使用在诸如Vector和Properties这些传统类所定义的方法中，除此之外，还用在一些API类，并且在应用程序中也广泛被使用。 下表总结了一些Enumeration声明的方法：</p></blockquote><table><thead><tr><th>1</th><th><strong>boolean hasMoreElements( )</strong>  测试此枚举是否包含更多的元素。</th></tr></thead><tbody><tr><td>2</td><td><strong>Object nextElement( )</strong> 如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</td></tr></tbody></table><h4><span id="实例">实例</span></h4><p>以下实例演示了Enumeration的使用：</p><pre><code class="java">import java.util.Vector;import java.util.Enumeration; public class EnumerationTester &#123;    public static void main(String args[]) &#123;      Enumeration&lt;String&gt; days;      Vector&lt;String&gt; dayNames = new Vector&lt;String&gt;();      dayNames.add(&quot;Sunday&quot;);      dayNames.add(&quot;Monday&quot;);      dayNames.add(&quot;Tuesday&quot;);      dayNames.add(&quot;Wednesday&quot;);      dayNames.add(&quot;Thursday&quot;);      dayNames.add(&quot;Friday&quot;);      dayNames.add(&quot;Saturday&quot;);      days = dayNames.elements();      while (days.hasMoreElements())&#123;         System.out.println(days.nextElement());       &#125;   &#125;&#125;</code></pre><pre><code>SundayMondayTuesdayWednesdayThursdayFridaySaturday</code></pre><h2><span id="102-注解">10.2 注解</span></h2><p>注解（Annotation）也被称为元数据（Metadata）。用于修饰 包、类、方法、属性、构造器、局部变量 等数据信息</p><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p><p>在 JavaSE 中，注解的使用目的比较简单，例如 标记过时的功能，忽略警告 等。在 JavaEE 中注解占据了更重要的角色，例如用于配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。</p><ol><li><p>使用 <code>@Annotation</code> 时要在前面增加 <code>@</code> 符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</p></li><li><p>三个基本的 <code>@Annotation</code>：</p><ul><li><code>@Override</code>：限定某个方法，是 重写 父类方法。该注解只能用于方法。如果你写了该注解，编译器会替你校验，看看是不是真的 重写 了父类方法。</li><li><code>@Deprecated</code>：用于表示某个程序元素（类、方法等）已经过时</li><li><code>@SuppressWarnings()</code>：抑制编辑器警告</li></ul></li><li><p>如果发现 <code>public @interface XXX&#123;&#125;</code> 这种东西，说明是定义了一个注解类 <code>XXX</code>。这里的 <code>@interface</code> 不代表接口（<code>interface</code>）。</p></li></ol><h3><span id="1021-override">10.2.1 <code>@Override</code></span></h3><ol><li><code>@Override</code> 表示指定重写父类的方法（从编译器层面验证），如果父类没有该方法，就报错</li><li>不写该注解，重写依然构成重写</li><li><code>@Override</code> 只能修饰方法，不能修饰其他 类、包、属性等</li><li>查看 <code>@Override</code> 注解源码为 <code>@Target(ElementType.METHOD)</code> 说明只能修饰方法</li><li><code>@Target</code> 是修饰注解的注解，称为 元注解</li></ol><h3><span id="1022-deprecated">10.2.2 <code>@Deprecated</code></span></h3><ol><li><p><code>@Deprecated</code> 表示指定的某个程序元素（类、方法等）已过时</p></li><li><p>不推荐使用，但仍能使用</p></li><li><p>可以修饰方法、类、字段、包、参数</p><p> <code>@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</code></p></li><li><p><code>@Deprecated</code> 可以做到新旧版本的兼容和过度</p></li></ol><h3><span id="1023-suppresswarnings">10.2.3 <code>@SuppressWarnings()</code></span></h3><ol><li><p>当我们不想看到警告信息时，用 <code>@SuppressWarnings()</code></p><p> 语法：<code>@SuppressWarnings(&#123;&quot;...&quot;&#125;)</code></p><p> 在后面 <code>(&#123;&quot;unused&quot;, &quot;unchecked&quot;&#125;)</code> 这样写入你希望抑制的信息，以下是所有可以输入的关键字</p><table><thead><tr><th align="left"><strong>关键字</strong></th><th align="left"><strong>用途</strong></th></tr></thead><tbody><tr><td align="left">all</td><td align="left">抑制所有警告</td></tr><tr><td align="left">boxing</td><td align="left">抑制与装箱&#x2F;解装箱操作相关的警告</td></tr><tr><td align="left">cast</td><td align="left">抑制与强制转换操作相关的警告</td></tr><tr><td align="left">dep-ann</td><td align="left">抑制与已弃用注释相关的警告</td></tr><tr><td align="left">deprecation</td><td align="left">抑制与弃用有关的警告</td></tr><tr><td align="left">fallthrough</td><td align="left">抑制与 switch 语句中丢失断点相关的警告</td></tr><tr><td align="left">finally</td><td align="left">抑制不返回的 finally 块的相关警告</td></tr><tr><td align="left">hiding</td><td align="left">抑制与隐藏变量的局部变量相关的警告</td></tr><tr><td align="left">incomplete-switch</td><td align="left">抑制与 switch 语句中缺少条目相关的警告（enum）</td></tr><tr><td align="left">nls</td><td align="left">抑制与 非nls 字符串字面值相关的警告</td></tr><tr><td align="left">null</td><td align="left">抑制相对于null分析的警告</td></tr><tr><td align="left">rawtypes</td><td align="left">在类参数上使用泛型时，抑制与非特定类型相关的警告</td></tr><tr><td align="left">restriction</td><td align="left">抑制与不推荐或禁止引用有关的警告</td></tr><tr><td align="left">serial</td><td align="left">抑制与可序列化类缺少serialVersionUID字段相关的警告</td></tr><tr><td align="left">static-access</td><td align="left">抑制与不正确的静态访问有关的警告</td></tr><tr><td align="left">synthetic-access</td><td align="left">抑制与未优化的内部类访问相关的警告</td></tr><tr><td align="left">unchecked</td><td align="left">抑制与未检查的操作相关的警告</td></tr><tr><td align="left">unqualified-field-access</td><td align="left">抑制与字段访问不合格相关的警告</td></tr><tr><td align="left">unused</td><td align="left">抑制与未使用代码相关的警告</td></tr></tbody></table></li><li><p><code>@SuppressWarnings</code> 的范围与你放置的位置相关。</p></li></ol><h3><span id="1024-jdk-的元注解了解即可">10.2.4 JDK 的元注解（了解即可）</span></h3><blockquote><p>JDK 的 元注解 是用于修饰其他注解的注解</p></blockquote><ol><li><p><code>@Rentention</code>：指定注解的作用范围，有三种范围 <code>SOURCE</code> <code>CLASS</code> <code>RUNTIME</code></p><p> <code>@Rentention</code> 的三种值：</p><ul><li><code>RententionPolicy.SOURCE</code>：编译器使用后，直接丢弃这种策略的注释</li><li><code>RententionPolicy.CLASS</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时， JVM 不会保留注释。这是默认值</li><li><code>RententionPolicy.RUNTIME</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解</li></ul></li><li><p><code>@Target</code>：指定注解的使用范围</p><p> <code>@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</code></p></li><li><p><code>@Documented</code>：指定该注解会不会在 Javadoc 体现</p></li><li><p><code>@Inherited</code>：子类会继承父类注解</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21 反射</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/21%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/21%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311020905457.png" alt="image-20231102090548360"></p><p>从带代码&#x2F;编译阶段到类加载阶段是jvm底层实现的，而类加载到运行阶段是程序员应用阶段完成的。</p><p>&#x3D;&#x3D;class.forName( )方法中一定要填写完整类名（即包名+类名），即便该类与调用forName方法的类在同一包下，也需填写完整类名！&#x3D;&#x3D;</p><h1><span id="21-反射">21 反射</span></h1><blockquote><ol><li>反射机制（Reflection）允许程序在执行期借助于 Reflection API 取得任何类的内部信息（如成员变量、成员方法等），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到。</li><li>加载完类之后，在堆中就产生了一个 <code>Class</code> 类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构。所以，形象地称之为：反射</li></ol><p>ocp 原则（开闭原则）：<strong>不修改源码来扩展功能</strong></p></blockquote><p><strong>计算机的三个阶段</strong></p><ol><li><p>代码阶段 &#x2F; 编译阶段</p><blockquote><p>编写代码 ——（Javac 编译）——&gt; .class 字节码文件</p></blockquote></li><li><p>Class 类阶段 &#x2F; 加载阶段</p><blockquote><p>字节码文件 ——（ClassLoader 类加载器）——&gt; <code>Class</code> 类对象（堆中）· 字节码二进制数据 &#x2F; 元数据（方法区）</p><p><code>Class</code> 类对象包含：成员变量 <code>Field[] fields</code>、构造器 <code>Constructor[] cons</code>、成员方法 <code>Methord[] ms</code></p></blockquote></li><li><p>Runtime 运行阶段</p><blockquote><p>创建对象，该对象知道其属于哪个 <code>Class</code> 对象</p></blockquote></li></ol><p><strong>反射机制可以完成</strong></p><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成<a href="https://juejin.cn/post/6974018412158664734">动态代理</a></li></ol><h2><span id="211-反射相关的常用类">21.1 反射相关的常用类</span></h2><ol><li><p><code>java.lang.Class</code>：代表一个类。<code>Class</code> 对象表示某个类加载后在堆中的对象</p><blockquote><pre><code class="java">Class cls = Class.forName(classFullPath);//[1]Object o = cls.newInstance();//[2]</code></pre><ol><li>通过完整类名得到一个类的 Class 对象</li><li>通过该 Class 对象创建一个该类的 对象实例</li></ol></blockquote></li><li><p><code>java.lang.reflect.Method</code>：代表类的方法。<code>Method</code> 对象表示某个类的某个方法</p><blockquote><pre><code class="java">Method method = cls.getMethod(methodName);//[1]method.invoke(o);//[2]</code></pre><ol><li>通过该 Class 对象得到一个 方法对象</li><li>方法对象.invoke：调用该方法</li></ol></blockquote></li><li><p><code>java.lang.reflect.Field</code>：代表类的成员变量</p><blockquote><pre><code class="java">Field field = cls.getField(fieldName);//[1]</code></pre><ol><li>该方法只能得到非私有对象</li></ol></blockquote></li><li><p><code>java.lang.reflect.Constructor</code>：代表类的构造方法</p><blockquote><pre><code class="java">Constructor constructor = cls.getConstructor();//[1]Constructor constructor2 = cls.getConstructor(String.class)                                                        //[2]</code></pre><ol><li>得到一个无参构造器</li><li>得到一个形参是 <code>(String str)</code> 的构造器</li></ol></blockquote></li></ol><p><strong>反射的优点和缺点</strong></p><ul><li>优点：可以动态地创建和使用对象（也是框架底层核心），使用灵活。没有反射机制，框架技术就失去底层支撑</li><li>缺点：使用反射基本是解释执行。这对执行速度有影响。</li></ul><p><strong>反射调用优化 - 关闭访问检查</strong></p><ol><li><p><code>Method</code> 和 <code>Field</code>、<code>Constructor</code> 对象都有 <code>setAccessible()</code> 方法</p></li><li><p>&#x3D;&#x3D;<code>setAccessible()</code> 作用是启动和禁用访问安全检查的开关，在需要访问私有域(会破坏封装性)时，传一个true。&#x3D;&#x3D;</p></li><li><p>参数值为 true，表示反射对象在使用时取消访问检查，这样能提高反射效率。</p><p> 为 false 表示执行访问检查</p></li></ol><h2><span id="212-class-类">21.2 <code>Class</code> 类</span></h2><ol><li><code>Class</code> 也是类，因此也继承 <code>Object</code> 类</li><li><code>Class</code> 类不是 new 出来的，而是系统创建的</li><li>对于某个类的 <code>Class</code> 类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个 <code>Class</code> 实例生成</li><li>通过 <code>Class</code> 可以完整地得到一个类的完整结构，通过一系列 API</li><li><code>Class</code> 对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的。有的地方称为类的元数据（包括 方法代码、变量名、方法名、访问权限 等）</li></ol><h3><span id="2121-class-类的常用方法">21.2.1 <code>Class</code> 类的常用方法</span></h3><ul><li><p><code>Class.forName(String)</code>：返回指定类名的 <code>Class</code> 对象</p></li><li><p><code>newInstance()</code>：返回一个无参构造器创建的实例</p></li><li><p><code>getName()</code>：返回该 <code>Class</code> 对象表示的实体的全类名</p></li><li><p><code>getClass()</code>：返回该 <code>Class</code> 对象的运行类型 <code>java.lang.Class</code></p></li><li><p><code>getPackage()</code>：返回该 <code>Class</code> 对象所在的包</p></li><li><p><code>getSuperClass()</code>：返回该 <code>Class</code> 对象的父类 <code>Class</code> 对象</p></li><li><p><code>getInterface()</code>：返回该 <code>Class</code> 对象的接口（数组）</p></li><li><p><code>getAnnotations()</code>：返回注解信息（<code>Annotation[]</code>）</p></li><li><p><code>getClassLoader()</code>：返回该 <code>Class</code> 对象的加载器（<code>ClassLoader</code> 类型）</p></li><li><p><code>getSuperclass()</code>：返回该 <code>Class</code> 对象实体的超类的 <code>Class</code></p></li><li><p><code>getConstructors()</code>：返回本类所有包含 <code>public</code> 修饰的构造器的 <code>Constructor</code> 对象数组</p><p>  该方法返回的构造器不含父类构造器！</p></li><li><p><code>getDeclaredConstructer()</code>：返回本类所有构造器的 <code>Constructor</code> 对象数组</p></li><li><p><code>getFileds()</code>：返回一个包含 <code>public</code> 修饰的属性的 <code>Field</code> 对象的数组</p><p>  <code>getFiled(String name)</code>：返回指定的 <code>Field</code></p></li><li><p><code>getDeclaredFields()</code>：获取本类中所有属性</p></li><li><p><code>field.get(instance)</code>：返回指定实例的指定属性</p></li><li><p>&#x3D;&#x3D;<code>field.set(instance, ..)</code>：给指定实例的指定属性赋值&#x3D;&#x3D;</p></li><li><p><code>getMethod()</code>：获得所有 <code>public</code> 修饰的方法的 <code>Method</code> 对象</p></li><li><p>&#x3D;&#x3D;<code>getMethod(String name, Class paramTypes, ...)</code>：&#x3D;&#x3D;返回一个 <code>Method</code> 对象，其形参类型为 paramType</p></li><li><p>&#x3D;&#x3D;<code>getDeclaredMethod()</code>：获取本类中所有方法&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;isAssignableFrom();在其中传入一个类对象，用来判断调用这个方法的类对象是否为传入类对象的类型，根instanceof的作用相似。&#x3D;&#x3D;</p></li></ul><h3><span id="2122-获取-class-对象">21.2.2 获取 <code>Class</code> 对象</span></h3><pre><code class="java">package com.melody.note;class Test &#123;&#125;</code></pre><ol><li><p>（编译阶段）已知一个类的全类名，且该类在类路径下：</p><blockquote><pre><code class="java">Class cls1 = Class.forName(&quot;com.melody.note.Test&quot;);//会调用类的静态方法，相较于classloader是重量级的，classloader返回的是部分信息，而这个是返回类的所有信息</code></pre><p>应用场景：配置文件，读取类全路径，加载类。</p><p>可能抛出 <code>ClassNotFoundExcption</code></p></blockquote></li><li><p>（加载阶段）已知具体的类：</p><blockquote><pre><code class="java">Class cls2 = Test.class;</code></pre><p>应用场景：参数传递。</p><p>该方法最为安全</p></blockquote></li><li><p>（运行阶段）已知某个类的实例：</p><blockquote><pre><code class="java">Class cls3 = new Test().getClass();</code></pre><p>应用场景：通过创建好的对象获取 <code>Class</code> 对象</p></blockquote></li><li><p>&#x3D;&#x3D;通过类加载器：&#x3D;&#x3D;</p><blockquote><pre><code class="java">ClassLoader cll = new Test().getClass().getClassLoader();Class cls4 = cll.loadClass(&quot;com.melody.note.Test&quot;);//不会调用类的静态方法，轻量级的，适用于对一个类进行判断的场景(比如是否包含注解)</code></pre></blockquote></li><li><p>基本数据类型：</p><blockquote><pre><code class="java">Class clsB1 = int.class;Class&lt;Boolean&gt; clsB2 = boolean.class;</code></pre></blockquote></li><li><p>基本数据类型包装类：</p><blockquote><pre><code class="java">Class clsB3 = Character.TYPE;Class&lt;Long&gt; clsB4 = Long.TYPE;</code></pre></blockquote></li></ol><h3><span id="2123-哪些类有-class-对象">21.2.3 哪些类有 <code>Class</code> 对象</span></h3><ol><li>外部类、成员内部类、静态内部类、局部内部类、匿名内部类</li><li>接口（interface）</li><li>数组</li><li>枚举（enum）</li><li>注解</li><li>基本数据类型</li><li>void</li></ol><h2><span id="x3dx3d213-类的加载x3dx3d">&#x3D;&#x3D;21.3 类的加载&#x3D;&#x3D;</span></h2><p><strong>基本说明</strong></p><blockquote><p>反射机制是 Java 实现动态语言的关键，也就是通过反射实现类动态加载</p></blockquote><ol><li>静态加载：编译时加载相关的类（不管有没有执行到代码块），如果没有则报错。依赖性强</li><li>动态加载：运行时加载需要的类（执行到相关的代码块时），如果运行时不用该类，则不报错。降低了依赖性</li></ol><p><strong>类加载时机</strong></p><ol><li>创建对象时（new） [静态加载]</li><li>子类被加载时，父类也被加载 [静态加载]</li><li>调用类中的静态成员 [静态加载]</li><li>通过反射 [动态加载]</li></ol><p><a href="https://i-melody.github.io/img/Java_InputImage/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9B%BE_21.3.webp"><img src="https://i-melody.github.io/img/Java_InputImage/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%9B%BE_21.3.webp" alt="img"></a></p><p><em>（类加载图_21.3）</em></p><ul><li><p>加载（Loading）：</p><p>  将类的 .class 文件读入内存，并为之创建一个 java.lang.Class 对象。此过程由类加载器完成</p></li><li><p>连接（Linking）：</p><p>  将类的二进制数据合并进 JRE 中</p></li><li><p>初始化（initialization）：</p><p>  JVM 负责对类进行初始化。这里主要是静态成员</p></li></ul><h3><span id="2131-类加载的五个阶段">21.3.1 类加载的五个阶段</span></h3><ul><li><p><strong>加载阶段</strong></p><p>  JVM 在该阶段的主要目的是将字节码从不同数据源（.class 文件、jar 包、网络等）转化为二进制字节流加载到内存中，并生成一个代表该类的 <code>java.lang.Class</code> 对象</p></li><li><p><strong>连接阶段 - 验证</strong></p><p>  目的是确保 <code>Class</code> 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>  包括：文件格式验证（是否以魔数 0xcafebabe 开头）、元数据验证、字节码验证、符号引用验证</p><p>  可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机加载的时间</p></li><li><p><strong>连接阶段 - 准备</strong></p><p>  JVM 会在该阶段对 静态变量 分配内存并执行默认初始化。这些变量使用的内存都将在方法区中进行分配</p><pre><code class="java">public int n1 = 1;//实例属性，非静态变量，此阶段不分配内存public static int n2 = 2;//静态变量，默认初始化为 0，后面初始化的时候才会真正赋为2.public static final int n3 = 3;//static final 常量，静态初始化为 3（一开始就是3，后面就不变了）</code></pre></li><li><p><strong>连接阶段 - 解析</strong></p><p>  JVM 将常量池内符号引用替换为直接引用的过程</p></li><li><p><strong>初始化</strong></p><p>  到初始化阶段，才真正开始执行类中定义的 Java 程序代码。此阶段是执行 <code>&lt;clinit&gt;()</code> 方法的过程</p><p>  <code>&lt;clinit&gt;()</code> 方法是由编译器按语句在文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并</p><p>  JVM 会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁、同步。如果多个线程去初始化一个类，那么&#x3D;&#x3D;只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法&#x3D;&#x3D;，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕</p></li></ul><h2><span id="214-通过反射获取类的结构信息">21.4 通过反射获取类的结构信息</span></h2><h3><span id="javalangclass-类与前面的的重复"><strong><code>java.lang.Class</code> 类（与前面的的重复）</strong></span></h3><blockquote><ul><li><p><code>getSuperClass()</code>：返回该 <code>Class</code> 对象的父类 <code>Class</code> 对象</p></li><li><p><code>getInterface()</code>：返回该 <code>Class</code> 对象的接口（数组）</p></li><li><p><code>getAnnotations()</code>：返回注解信息（<code>Annotation[]</code>）</p></li><li><p><code>getClassLoader()</code>：返回该 <code>Class</code> 对象的加载器（<code>ClassLoader</code> 类型）</p></li><li><p><code>getSuperclass()</code>：返回该 <code>Class</code> 对象实体的超类的 <code>Class</code></p></li><li><p><code>getConstructors()</code>：返回本类所有包含 <code>public</code> 修饰的构造器的 <code>Constructor</code> 对象数组</p><p>  &#x3D;&#x3D;该方法返回的构造器不含父类构造器！&#x3D;&#x3D;</p></li><li><p><code>getDeclaredConstructer()</code>：返回本类&#x3D;&#x3D;所有构造器的 <code>Constructor</code> 对象数组&#x3D;&#x3D;</p></li><li><p><code>getFileds()</code>：返回一个包含 <code>public</code> 修饰的属性的 <code>Field</code> 对象的数组</p><p>  <code>getFiled(String name)</code>：返回指定的 <code>Field</code></p></li><li><p><code>getDeclaredFields()</code>：获取本类中所有属性</p></li><li><p><code>field.get(instance)</code>：返回指定实例的指定属性</p></li><li><p><code>field.set(instance, ..)</code>：给指定实例的指定属性赋值</p></li><li><p><code>getMethod()</code>：获得所有 <code>public</code> 修饰的方法的 <code>Method</code> 对象</p></li><li><p><code>getMethod(String name, Class paramTypes, ...)</code>：返回一个 <code>Method</code> 对象，其形参类型为 paramType</p></li><li><p><code>getDeclaredMethod()</code>：获取本类中所有方法</p></li></ul></blockquote><h3><span id="javalangreflectfield-类"><strong><code>java.lang.reflect.Field</code> 类</strong></span></h3><blockquote><ul><li><p><code>getModifiers()</code>：以 int 形式返回修饰符</p><p>  默认修饰符 [0]、public [1]、private [2]、protected [4]、static [8]、final [16]</p><p>  示例：</p><blockquote><pre><code class="java">public static final int n = 0;</code></pre><p>这个变量的修饰符的 int 表示 &#x3D; 1 + 8 + 16 &#x3D; 25</p></blockquote></li><li><p><code>getType()</code>：以 <code>Class</code> 形式返回类型</p><blockquote><p>上例变量的 <code>getType()</code> 等同于 <code>Integer.getClass()</code></p></blockquote></li><li><p><code>getName()</code>：返回属性名</p></li></ul></blockquote><h3><span id="javalangreflectmethod-类"><strong><code>java.lang.reflect.Method</code> 类</strong></span></h3><blockquote><ul><li><code>getModifiers()</code>：以 int 形式返回修饰符（同上）</li><li><code>getName()</code>：返回方法名</li><li><code>getReturnType()</code>：以 <code>Class</code> 形式返回返回类型</li><li><code>getParameterTypes()</code>：以 <code>Class[]</code> 形式返回形参类型数组</li></ul></blockquote><h3><span id="javalangreflectconstructer-类"><strong><code>java.lang.reflect.Constructer</code> 类</strong></span></h3><blockquote><ul><li><code>getModifiers()</code>：以 int 形式返回修饰符</li><li><code>getName()</code>：返回构造器名（和全类名相等）</li><li><code>getParameterTypes()</code>：以 <code>Class[]</code> 形式返回形参类型数组</li></ul></blockquote><h2><span id="215-通过反射创建对象">21.5 通过反射创建对象</span></h2><ol><li><p>调用类中的 public 修饰的无参构造器</p><blockquote><pre><code class="java">Object obj1 = cls.newInstance();</code></pre></blockquote></li><li><p>调用类中指定的构造器</p><blockquote><pre><code class="java">Constructer cons = cls.getConstructer(int.class, String.class, ...);Object obj2 = cons.newInstance(1, &quot;nnn&quot;, ...);</code></pre></blockquote></li><li><p>&#x3D;&#x3D;<code>setAccessible(true)</code>：爆破（暴力破解）。使用反射可以访问 private 构造器&#x3D;&#x3D;，这样做会破坏封装性。</p><blockquote><pre><code class="java">Constructer cons2 = cls.getDeclaredConstructer(boolean.class ...);cons2.setAccessible(true);//下面就可以调用私有构造器创建对象了Object obj3 = cons.newInstance(false, ...);</code></pre></blockquote></li></ol><h2><span id="216-通过反射访问成员">21.6 通过反射访问成员</span></h2><blockquote><pre><code class="java">Field field = cla.getDeclaredField(&quot;name&quot;);field.setAccessible(true);field.set(o, &quot;111&quot;);//[1]</code></pre><ol><li><p>o 表示一个类的实例</p><p> &#x3D;&#x3D;如果该属性是静态属性（属于类的），则对象 o 可以是 null&#x3D;&#x3D;</p></li></ol></blockquote><blockquote><pre><code class="java">Method method = cls.getDeclaredMethod(&quot;m1&quot;);method.setAccessible(true);Object returnObj = method.invoke(o, &#39;c&#39;, ...);//[1]</code></pre><ol><li><p>o 表示一个类的实例，后面是实参列表</p><p> 同理，静态方法的场合，对象 o 可以是 null。</p></li></ol></blockquote><p>&#x3D;&#x3D;在反射中调用方法时，如果方法有返回值，例如String，调用会返回Object类型(编译类型),但是实际运行类型还是String。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25 正则表达式</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/25%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="25-正则表达式">25 正则表达式</span></h1><p>Regular expression 简称：RegExp</p><blockquote><p>正则表达式：对字符串执行模式匹配的技术。一个正则表达式，就是用某种模式去匹配字符串的一个公式。除 Java 外，还有许多语言支持正则表达式。</p></blockquote><pre><code class="java">String content = &quot;HeruinKCoin&quot;;//对象文本String regular = &quot;[A-Z]&quot;;//[1] 创建规则Pattern pattern = Pattern.compile(regular);//[2] 创建模式对象Matcher matcher = pattern.matcher(content);//[3] 创建匹配器while (matcher.find())&#123;//[4] find() 是否找到下一个    System.out.println(matcher.group(0));//[5] group(0) 输出找到的当前对象&#125;</code></pre><blockquote><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311101802722.png" alt="image-20231110180206653">在这里matcher.group(0),返回的是0到1这个两个索引表示的字符串。</p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311101757453.png" alt="image-20231110175724388"></p><p><code>Matcher</code> 底层维护了一个 <code>group[]</code> 数组。如果 <strong>[4]</strong> 在文本里匹配到对象，会在 <code>group[0]</code> 记载该起始位置 n1，在 <code>group[1]</code> 记录该结束位置的下一位 n2。即 [n1,n2) 为匹配的字符串，n2 位置是下次匹配的起始位置。</p><p>当 <strong>[1]</strong> 创建的规则包含分组（如 <code>String regular = &quot;(\\d\\d)(\\d\\d)&quot;;</code>），则第一组的起止位置记录在 <code>group[2]</code>、<code>group[3]</code>，第二组在 <code>group[4]</code>、<code>group[5]</code>。以此类推。这时，**[5]** 的 <code>group(0)</code> 代表输出全部，<code>group[1]</code> 代表输出第一组，group[2]表示输出第二组，以此类推。</p></blockquote><h2><span id="251-语法">25.1 语法</span></h2><p><strong>元字符</strong></p><ul><li>限定符</li><li>选择匹配符</li><li>分组组合和反向引用符</li><li>特殊字符</li><li>字符匹配符</li><li>定位符</li></ul><h3><span id="2511-转义符号">25.1.1 转义符号 <code>\</code></span></h3><p>使用正则表达式去检索某些特殊字符时，需要加上转义符号（如：<code>(</code> 需要写成 <code>\(</code>）</p><p>在 Java 的正则表达式中，<code>\\</code> 代表一个 <code>\</code>。<em><strong>——见 [[1.8 Java 转义字符 ]](<a href="https://i-melody.github.io/2021/11/21/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/1">https://i-melody.github.io/2021/11/21/Java/入门阶段/1</a> 基础知识&#x2F;#1-8-Java-转义字符)</strong></em></p><p>&#x3D;&#x3D;需要用到转义符号的字符有&#x3D;&#x3D;：<code>.</code>、<code>+</code>、<code>(</code>、<code>)</code>、<code>$</code>、<code>/</code>、<code>\</code>、<code>?</code>、<code>[</code>、<code>]</code>、<code>^</code>、<code>&#123;</code>、<code>&#125;</code></p><h3><span id="2512-字符匹配符">25.1.2 字符匹配符</span></h3><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td><code>[ ]</code></td><td>可接收的字符列表</td><td><code>[abcd]</code></td><td>abcd 中的任一字符</td></tr><tr><td><code>[^]</code></td><td>不接收的字符列表</td><td><code>[^abcd]</code></td><td>非 abcd 的任意字符</td></tr><tr><td><code>-</code></td><td>连字符</td><td><code>[a-z]</code></td><td>a - z 中的任意字符</td></tr><tr><td><code>.</code></td><td>除了斜杆n、斜杆r、斜杆r和斜杆n，都匹配；</td><td><code>a..b</code></td><td>a 开头，b结尾，中间含 2 字符</td></tr><tr><td><code>\d</code></td><td>匹配单个数字字符，相当于[0-9]</td><td><code>\d&#123;3&#125;(\d)?</code></td><td>包含 3 个数字，或4个数字的字符串，<code>（\d）?</code>要注意，这个很有用,表示前面的条件加这个条件，但是这个条件只是可能存在第四个数字。</td></tr><tr><td><code>\D</code></td><td>匹配单个非数字字符，相当于<code>[^0-9]</code></td><td><code>\D(\d)*</code></td><td>单个非数字字符开头，后接任意个数字字符</td></tr><tr><td><code>\w</code></td><td>匹配单个数字、&#x3D;&#x3D;下划线&#x3D;&#x3D;、大小写字母字符，相当于[0-9a-zA-Z_]</td><td><code>\w&#123;2&#125;\d&#123;3&#125;</code></td><td>2 个数字字母字符开头(任意组合，全为数字，全为字符或者都有)，后接 3 个数字字符</td></tr><tr><td><code>\W</code></td><td>匹配单个非数字、非大小写字母字符,相当于<code>[^0-9a-zA-Z_]</code></td><td><code>\W+\d&#123;2&#125;</code></td><td>以至少 1 个非数字字母字符开头，后接 2 个数字字符</td></tr><tr><td><code>\s</code></td><td>匹配空白字符（空格、制表位等）</td><td></td><td></td></tr><tr><td><code>\S</code></td><td>匹配非空白字符</td><td></td><td></td></tr></tbody></table><ul><li><p>关于 <code>.</code>：特别地，出现 <code>[.]</code> 的场合，那个小圆点依然表示小圆点。<code>[?]</code> 同理，表示问号</p></li><li><p>&#x3D;&#x3D;正则表达式默认区分大小写。要不区分大小写，就加上 <code>(?i)</code>&#x3D;&#x3D;</p><ul><li><p><code>(?i)abc</code>：即 abc 都不区分大小写</p></li><li><p><code>a(?i)bc</code>：即仅 bc 不区分大小写</p></li><li><p><code>a((?i)b)c</code>：即仅 b 不区分大小写</p></li><li><p>创建模式对象时，若如此做：</p><pre><code class="java">Pattern pattern = Pattern.compile(regular, Pattern.CASE_INSENSITIVE);</code></pre></li></ul></li></ul><p>这个场合，也能不区分大小写。</p><h3><span id="2513-选择匹配符">25.1.3 选择匹配符 <code>|</code></span></h3><p>……我的感想是，和 Java 的逻辑或 <code>|</code> 一样！</p><h3><span id="2514-限定符">25.1.4 限定符</span></h3><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td><code>*</code></td><td>指定字符重复任意次（可以为 0 次）</td><td><code>(abc)*</code></td><td>仅包含任意个 abc 字符串的字符串</td></tr><tr><td><code>+</code></td><td>指定字符重复至少一次</td><td><code>m+(abc)*</code></td><td>以任意个 m 开头，后面可以有 abc 字符串的字符串</td></tr><tr><td><code>?</code></td><td>指定字符重复最多一次（可以为 0 次）</td><td><code>m+abc?</code></td><td>以任意个 m 开头，后面可以有最多一个 abc 字符串的字符串</td></tr><tr><td><code>&#123;n&#125;</code></td><td>n 个匹配</td><td><code>[abc]&#123;3&#125;</code></td><td>长度为 3 的 abc 中的任意字符的组合</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>至少 n 个匹配</td><td><code>[abc]&#123;3,&#125;</code></td><td>长度不小于 3 的 abc 中的任意字符的组合</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>n 到 m 个匹配</td><td><code>[abc]&#123;3,5&#125;</code></td><td>长度介于 3 到 5 之间的 abc 中的任意字符的组合</td></tr></tbody></table><ul><li><p>Java 的匹配模式默认是&#x3D;&#x3D;贪婪匹配&#x3D;&#x3D;。即：<code>aaaaa</code> 匹配 <code>a&#123;3,5&#125;</code> 的场合，会匹配到 <code>aaaaa</code></p><p>  &#x3D;&#x3D;希望实现非贪婪匹配，可以添加额外的 <code>?</code>。如：<code>*?</code>、<code>+?</code>、<code>??</code> 代表各自规则的非贪婪匹配&#x3D;&#x3D;</p><p>  注意，除非语句要求限定长度，否则语法都会尽量长的返回字符串</p></li></ul><h3><span id="x3dx3d2515-定位符x3dx3d">&#x3D;&#x3D;25.1.5 定位符&#x3D;&#x3D;</span></h3><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td><code>^</code></td><td>指定起始字符</td><td><code>^[0-9]+[a-z]*</code></td><td>至少一个数字开头，后接任意小写字母字符串，如果是123abc12可以匹配到‘123abc’，如果是ab123abc则会匹配不到，因为开头必须为数字。结尾没有做要求。</td></tr><tr><td><code>$</code></td><td>指定结束字符</td><td><code>^[0-9][a]$</code></td><td>一个数字开头，一个 a 结尾,结尾也必须是a，否则匹配不到。</td></tr><tr><td><code>\b</code></td><td>匹配目标字符串的边界</td><td><code>K\.C\b</code></td><td>匹配边界的 K.C</td></tr><tr><td><code>\B</code></td><td>匹配目标字符串的非边界</td><td><code>K\.C\B</code></td><td>匹配非边界的 K.C</td></tr></tbody></table><ul><li>边界即字符串的末尾，或字符串中空格间隔的子串的末尾。</li><li>用的最多的是<code>^</code>和<code>$</code>，他们经常搭配使用。例如要限定一个邮箱格式，则写为<code>^ [a-zA-Z0-9_-]+@ [a-zA-Z0-9_-]+ (\\. [a-zA-Z0-9_-]+)+$</code></li></ul><h3><span id="2516-分组">25.1.6 分组</span></h3><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>(pattern)</code></td><td>非命名捕获。捕获匹配的字符串。</td></tr><tr><td><code>(?&lt;name&gt;pattern)</code>、<code>(?&#39;name&#39;pattern)</code></td><td>命名捕获，给组取名，&#x3D;&#x3D;可以在group方法中传入这个命名的字符串&#x3D;&#x3D;来得到相应分组字符串。用于 name 的字符串不能包含标点符号，也不能以数字开头</td></tr></tbody></table><ul><li>编号为 0 的第一个捕获是由整个正则表达式匹配的文本。其他捕获结果根据左括号的顺序从 1 开始自动编号。</li></ul><h3><span id="x3dx3d2517-非捕获分组x3dx3d">&#x3D;&#x3D;25.1.7 非捕获分组&#x3D;&#x3D;</span></h3><p>写法简洁，但是这样就不能gourp(1)和gourp(2)访问了。</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td><code>(?:pattern)</code></td><td>匹配 pattern &#x3D;&#x3D;但不捕获该匹配的子表达式&#x3D;&#x3D;</td><td>&#96;industr(?:y</td><td>ies)&#96;</td></tr><tr><td><code>(?=pattern)</code></td><td>匹配处于 pattern 前的搜索字符串。非捕获分组。</td><td>&#96;Windows(?&#x3D;7|10）</td><td>只得到windows 7或windows 10前的Windows</td></tr><tr><td><code>(?!pattern)</code></td><td>匹配不处于 pattern 前的搜索字符串。非捕获分组。</td><td>&#96;Windows(?!7|10）</td><td>得到除了windows7或windows10之前的windows</td></tr></tbody></table><h2><span id="252-常用类">25.2 常用类</span></h2><ul><li><p><code>Pattern</code> 类：</p><p>  <code>Pattern</code> 对象是一个正则表达式对象，该类没有公共构造方法。</p><p>  用 <code>Pattern.compile(reg)</code> 获取一个 <code>Pattern</code> 对象。</p></li><li><p><code>Matcher</code> 类：</p><p>  <code>Matcher</code> 对象是输入字符串进行解释和匹配的引擎，也没有公共构造方法。</p><p>  用 <code>Pattern</code> 对象的 <code>matcher(content)</code> 方法获得一个 <code>Matcher</code> 对象。</p></li><li><p><code>PatternSyntaxExcption</code> 类：</p><p>  <code>PatternSyntaxExcption</code> 是一个非强制异常类，表示一个正则表达式中的语法错误。</p></li></ul><h3><span id="2521-pattern-类常用方法">25.2.1 <code>Pattern</code> 类常用方法</span></h3><ul><li><p><code>Pattern.matches(reg, content)</code>：&#x3D;&#x3D;整体匹配，&#x3D;&#x3D;输入的字符串是否符合表达式。返回布尔值。</p><p>  <code>matcher.matches()</code>：整体匹配，字符串是否符合表达式。返回布尔值。前面的方法实际上就是这个方法。</p></li><li><p><code>Pattern.compile(reg)</code>：返回一个指定表达式的 <code>Pattern</code> 对象</p></li><li><p><code>pattern.matcher(content)</code>：返回一个字串的 <code>Matcher</code> 对象</p></li><li><p><code>matcher.pattern()</code>：返回该 <code>Matcher</code> 对象的表达式</p><p>  <code>pattern.pattern()</code>：返回该 <code>Pattern</code> 对象的表达式</p></li><li><p><code>matcher.find()</code>：尝试查找下一个匹配的序列，返回布尔值</p><p>  <code>matcher.find(int)</code>：重置该匹配器，从指定索引位置开始重新查找</p></li><li><p><code>matcher.start()</code>：返回本次匹配的字符起始位置的索引</p><p>  <code>matcher.end()</code>：返回本次匹配的字符结束位置 + 1 的索引</p><p>  &#x3D;&#x3D;这个场合，<code>content.substring(matcher.start(), matcher.end())</code> 就是匹配的字符串&#x3D;&#x3D;</p></li><li><p><code>matcher.start(int)</code>：返回本次匹配的字符的该组内容的起始位置的索引</p><p>  <code>matcher.end(int)</code>：返回本次匹配的字符的该组内容的结束位置 + 1 的索引</p></li><li><p>&#x3D;&#x3D;<code>matcher.replaceAll(str)</code>：替换匹配到的全部内容,返回替换的字符，原来的字符不变化，可以通过用原字符串引用接受这个返回值来变相”改变“内容（字符串是不可以修改的，只是原来的引用指向了新的字符串对象）&#x3D;&#x3D;</p><p>  <code>matcher.replaceFirst(str)</code>：替换第一次匹配到的内容</p><p>  这些场合，返回的字符串才是替换后的字符串。原字符串不变。</p></li></ul><h2><span id="253-分组-捕获-x3dx3d反向引用x3dx3d">25.3 分组、捕获、&#x3D;&#x3D;反向引用&#x3D;&#x3D;</span></h2><ul><li><p>分组（子表达式）</p></li><li><p>捕获：把正则表达式中，子表达式（分组）的内容保存到内存中以数字编号或显式命名的组里，方便后面引用。以分组的左括号为标志，第一组组号为 1，第二组为 2，以 0 代表整个正则表达式。</p></li><li><p>反向引用：分组的内容被捕获后，可以在这个括号后使用。这种引用既可以是在正则表达式内部，也可以在外部。内部反向引用 <code>\分组号</code>、外部反向引用 <code>$分组号</code></p><pre><code class="java">String regular = &quot;(\\w)\\1+&quot;;//即，重复的字母或数字Matcher matcher = Pattern.compile(regular).mathcer(content);content = matcher.replaceAll(&quot;$1&quot;);//这样，就完成了去重</code></pre><pre><code class="java">//前五位数字-后面9为每三位数字相同。String content =&quot;12345-111222333&quot;;String regular = &quot;[0-9]&#123;5&#125;-(\\d)\\1&#123;2&#125;(\\d)\\2&#123;2&#125;(\\d)\\3&#123;2&#125;&quot;;Pattern pattern = Pattern.compile(regular);Matcher matcher  = pattern.matcher(content);while (matcher.find())&#123;    System.out.println(matcher.group(0));&#125;</code></pre></li></ul><h2><span id="x3dx3d254-在-string-中使用正则表达式x3dx3d">&#x3D;&#x3D;25.4 在 <code>String</code> 中使用正则表达式&#x3D;&#x3D;</span></h2><ul><li><code>str.matches(reg)</code>：&#x3D;&#x3D;整体匹配&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<code>str.replaceAll(reg, reg)</code>：替换匹配到的全部内容&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<code>str.split(reg)</code>：分割内容&#x3D;&#x3D;</li></ul><h1><span id="应用实例">应用实例</span></h1><h2><span id="1验证汉字">1.验证汉字</span></h2><pre><code class="java">String content = &quot;你好&quot;;String content2 = &quot;你hello好&quot;;String regular = &quot;^[\u0391-\uffe5]+$&quot;;//这个范围是汉字的范围Pattern pattern = Pattern.compile(regular);Matcher matcher = pattern.matcher(content);if(matcher.find())&#123;    System.out.println(&quot;满足格式&quot;);&#125;else &#123;    System.out.println(&quot;不满足格式&quot;);&#125;</code></pre><h2><span id="2验证url">2.验证url</span></h2><pre><code class="java">String regular = &quot;^((https|http):\\/\\/)([\\w-]+\\.)+([\\w-])+(\\/[\\w.?%/&amp;=-]*)?$&quot;;</code></pre><h2><span id="3结巴程序去重">3.结巴程序去重</span></h2><pre><code class="java">String content = &quot;我....我要....学学学学....编程java!&quot;;String regular = &quot;[.]+&quot;;Pattern pattern = Pattern.compile(regular);Matcher matcher = pattern.matcher(content);content = matcher.replaceAll(&quot;&quot;);System.out.println(content);pattern = Pattern.compile(&quot;(.)\\1+&quot;);matcher = pattern.matcher(content);while (matcher.find()) &#123;    System.out.println(matcher.group(0));&#125;String target = matcher.replaceAll(&quot;$1&quot;);System.out.println(target);content = Pattern.compile(&quot;(.)\\1+&quot;).matcher(content).replaceAll(&quot;$1&quot;);System.out.println(content);</code></pre><p>实际上可以用String来做，这样就可以去重了。</p><pre><code class="java"> content.replaceAll(&quot;(.)\\1+&quot;,&quot;$1&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5 数组、排序和查找</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/5%20%E6%95%B0%E7%BB%84/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/5%20%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="5-数组-排序和查找">5 数组、排序和查找</span></h1><blockquote><p>数组：可以存放多个同一类型的数据。数组也是一种数据，是引用类型。</p><p>即：数组就是一组数据。</p></blockquote><h2><span id="51-一维数组">5.1 一维数组</span></h2><blockquote><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。</p><p>数组中的元素可以是任何数据类型。包括基本类型和引用类型。</p><p>数组的下标从 0 开始。且必须在指定范围内使用，否则报错。</p><p>数组属于 引用类型，数组型数据是 对象（Object）</p><p>数组创建后，如果没有赋值，有默认值：int（0），short（0），byte（0），long（0L），float（0.0F），double（0.0），char（\u0000），boolean（false），String（null），Object（null）</p></blockquote><p><strong>数组的构造方法：</strong></p><p>使用数组的步骤：1.声明数组并开辟空间 2.给数组各个元素赋值 3.使用数组</p><ul><li><p>构造方式1：动态初始化</p><pre><code>int[] ints = new int[5];// 创建了数组 name，存放5个intint ints2[] = new int[1];// 这种写法也行ints[2] = 15;// 访问数组第3个数JAVA</code></pre></li><li><p>构造方式2：动态初始化</p><pre><code>char[] chars;// 先声明数组 name，此时数组是 nullchars = new char[2];// 分配内存空间，可以存放数据了chars[1] = &#39;\t&#39;;JAVA</code></pre></li><li><p>构造方式3：静态初始化</p><pre><code>boolean[] bools = &#123;true, false, true, false&#125;;String[] strs = new String[]&#123;&quot;阿伟，你又在打电动噢&quot;, &quot;烦啦&quot;&#125;;JAVA</code></pre><p>  确切知道数组每个元素的场合可以用这个方法。</p></li></ul><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：<code>数组名[元素下标]</code></p><p>  其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素 <code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>  是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h3><span id="511-数组赋值机制">5.1.1 数组赋值机制</span></h3><ol><li><p>基本数据类型赋值，赋值方式是值拷贝。这个值就是具体的数据，且互不影响</p></li><li><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><pre><code>int[] array1 = &#123;0, 0, 0&#125;;int[] array2 = array1;array2[0] = 100;JAVA</code></pre><p> 上述情况下，<code>array1[0]</code> 也会变成 <code>100</code>。因为数组在 JVM 的 栈 里是一个地址，指向 堆 里的一个空间。这两个数组在上述情况下指向同一空间。</p><pre><code>int[] array1 = &#123;0, 0, 0&#125;;int[] array2 = new int[array1.length];for (int i = 0;i &lt; array1.length;i++) &#123;    array2[i] = array1[i];&#125;JAVA</code></pre><p> 上述方式拷贝后，两数组相互独立。</p></li></ol><h3><span id="512-数组的扩容">5.1.2 数组的扩容</span></h3><p>当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><p>以下是一个扩容方法：</p><pre><code>import java.util.Scanner;public class Code5_1_3&#123;    public static void main(String[] args)&#123;        Scanner inP = new Scanner(System.in);        int[] arr1 = &#123;1, 2, 3&#125;;// 这是原数组        int add = 0;// 这个变量记录输入的新元素的值        int count = arr1.length;// 这个变量是新数组的长度        char yN = &#39;a&#39;;// 记录询问继续与否时用户的输入字符        do&#123;           /* 创建多一位的新数组，把新元素赋给新数组的最后一位 */                System.out.println(&quot;请输入添加数字：&quot;);                add = inP.nextInt();                int[] tem = new int[arr1.length + 1];                tem[count] = add;           /* 把旧数组的值全部赋给新数组 */                for(int i = 0; i &lt; arr1.length; i++)&#123;                    tem[i] = arr1[i];                &#125;           /* 把新数组保存下来，输出现在的数组 */                arr1 = tem;                count++;                System.out.println(&quot;\n\n当前数组为：&quot;);                for(int i = 0; i &lt; arr1.length; i++)&#123;                    System.out.print(arr1[i] + &quot; &quot;);                &#125;           /* 询问是否继续添加，输入n跳出，否则循环 */                System.out.println(&quot;\n\n是否继续添加？（Y/N）&quot;);                yN = inP.next().charAt(0);        &#125;while(yN != &#39;N&#39; &amp;&amp; yN != &#39;n&#39;);    &#125;&#125;JAVA</code></pre><h2><span id="52-二维数组">5.2 二维数组</span></h2><pre><code>int[][] ints;// 声明一个二维数组int[] ints2[];// 也能这样声明int ints3[][];// 这样也行int[] x,y[];// 声明了两个数组，一个是 int[] x 一个是 int[][] y                                // 把 int[] 视作一个类型，就能很好地理解这个写法JAVA</code></pre><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。</p><p>数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><p><strong>二维数组构造方法：</strong></p><ul><li><p>构造方法1：动态初始化</p><pre><code>int[][] many_ints = new int[3][4]// 创建 有3个 包含4个元素的一维数组 的二维数组JAVA</code></pre></li><li><p>构造方法2：动态初始化</p><pre><code>double[][] many_doubles;// 先声明变量many_doubles = new double[3][4];// 再开辟空间JAVA</code></pre></li><li><p>构造方法3：动态初始化-列数不确定</p><pre><code>char[][] many_chars = new char[3][];// 创建一个三行列数不确定的二维数组for (int i = 0; i &lt; 3; i++) &#123;    many_chars[i] = new char[i + 1];// 此时，每个数组空间依次增大&#125;JAVA</code></pre></li><li><p>构造方法4：静态初始化</p><pre><code>int[][] many_many = &#123;&#123;1, 3&#125;, &#123;4, 10, 2&#125;, &#123;95&#125;&#125;;JAVA</code></pre></li></ul><p><strong>二维数组使用方法：</strong></p><ul><li><code>ints.length</code>：该二维数组的长度，这里是 3</li><li><code>ints[0]</code>：该二维数组的第一个子数组</li><li><code>ints[0].length</code>：该二维数组的第一个子数组的长度，这里是 4</li><li><code>ints[1][0]</code>：该二维数组第二个子数组的第一个元素的值，这里是 21</li></ul><p><del>这是一维数组：int[] a、这是二维数组：int[][] b。好了，现在来写一个堆排序吧</del></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String深入理解</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3String/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3String/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>String str &#x3D; “a” + “b” + “c”到底创建了几个对象？这是我们在讨论中最经常遇到的一个问题同时也是面试题。我们都知道在Java中从”.java”文件编译成”.class”文件的过程，会有一个优化器去优化我们的代码。这个问题需要分成三种情况去考虑，下面我们就来分析这三种情况！！</p></blockquote><p><strong>前言</strong><br>在<a href="https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020">JVM</a>(JDK8)的内存结构中有一块区域叫作字符串常量池，这块区域存储了两样东西，分别是“字面量”和“符号引用”。字面量也就是一串字，例如String str &#x3D; “abc” 这里的”abc”就是字面量。符号引用是用于定位引用指向的问题。(JDK8完完全全把字符串常量池从方法区搬到堆中了)</p><p><strong>一、第一种情况（常量相加）</strong></p><blockquote><p>String str &#x3D; “a” + “b” + “c</p></blockquote><p>因为这种情况是常量之间相加，经过编译器优化成了String str &#x3D; “abc”，所以答案是创建了一个对象。“a”、“b”、”c”这些都是常量，因为它们是final修饰放在<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>常量池中的对象(注意：字面量也是对象)</p><p>我们通过javac编译，然后反编译后的结果和内存分配情况如下</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.soft.wesker;public class Test &#123;    public Test() &#123;    &#125;    public static void main(String[] var0) &#123;        String var1 = &quot;abc&quot;;    &#125;&#125;</code></pre><p>​    </p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310022218765.png"><br><strong>二、第二种情况（变量相加)</strong></p><blockquote><p>String a &#x3D; “a”;<br>String b &#x3D; “b”;<br>String c &#x3D; “c”;<br>String str &#x3D; a + b + c;</p></blockquote><p>因为这种情况是变量之间相加，已经不是之前的常量相加了，经过编译器优化成了StringBuilder，所以答案是创建了三个对象。new StringBuilder()、new String()、“abc”，&#x3D;&#x3D;因为最终会通过StringBuilder()里面的toString()方法进行new String(“abc”)类型转换&#x3D;&#x3D;。&#x3D;&#x3D;”abc”：这是 StringBuilder 的 toString 方法返回的新字符串对象&#x3D;&#x3D;</p><p>&#x3D;&#x3D;注意：str接收的是toString返回的对象，而不是在toString里创建的对象&#x3D;&#x3D;</p><p>源码：</p><pre><code class="java"> @Override    public String toString() &#123;        // Create a copy, don&#39;t share the array        return new String(value, 0, count);    &#125;</code></pre><p>我们通过javac编译，然后反编译后的结果和内存分配情况如下</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.soft.wesker;public class Test &#123;    public Test() &#123;    &#125;    public static void main(String[] var0) &#123;        String var1 = &quot;a&quot;;        String var2 = &quot;b&quot;;        String var3 = &quot;c&quot;;        (new StringBuilder()).append(var1).append(var2).append(var3).toString();    &#125;&#125;</code></pre><p>​    </p><p><img src="https://img-blog.csdnimg.cn/0744c08f8cb04be58cf0408b6bc55df4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODQyMDkz,size_16,color_FFFFFF,t_70"> </p><p>&#x3D;&#x3D;在这里字符串常量池其实还没有“abc”,在堆中虽然创建了这个字符串，<strong>只有字符串字面量和调用intern()方法的字符串才会被添加到字符串常量池</strong>。其他通过new String()或者字符串连接等方式创建的字符串，都是在堆上创建的，不会被添加到字符串常量池，除非你显式地调用intern()方法。&#x3D;&#x3D;<br><strong>三、第三种情况（无优化)</strong></p><blockquote><p>String str &#x3D; “a” + “b” + “c</p></blockquote><p>如果不考虑优化的情况下，这一共是创建了5个对象的，因为一个双引号就是一个字面量(对象)，这里创建了5个对象，分别是”a”、“b”、“c”、“ab”、“abc”。</p><p>下面是内存分配情况<br><img src="https://img-blog.csdnimg.cn/5c80178feb494e7ea3bc502601556f65.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODQyMDkz,size_16,color_FFFFFF,t_70">  </p><p><strong>最后我们还需要考虑一个问题，在创建字面量的时候，JVM会先从字符串常量池中寻找是否已经存在，如果已经存在则直接返回引用，不存在就会先创建一个字面量，然后再返回引用。所以就会出现创建了0个对象的问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 字符串 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17 IO流</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/17%20IO%E6%B5%81/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/17%20IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="17-io流">17 IO流</span></h1><h2><span id="171-文件">17.1 文件</span></h2><blockquote><p>文件就是保存数据的地方。</p><p>文件流：文件 在 程序 中是以 流 的形式来操作的。</p><p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p><p>输入流：数据从数据源到程序的路径</p><p>输出流：数据从程序到数据源的路径</p></blockquote><h3><span id="1711-常用的文件操作">17.1.1 常用的文件操作</span></h3><blockquote><p>Java 提供了 File 类，用于处理文件相关的操作</p></blockquote><ol><li><p>创建文件对象相关构造器和方法</p><ul><li><p><code>new File(String pathname)</code>：根据路径创建一个 File 对象</p><blockquote><pre><code class="java">String path1 = &quot;d:/test.jpg&quot;;String path2 = &quot;d:\\test.jpg&quot;;File file1 = new File(path1);File file2 = new File(path2);//此时只是在内存中产生了一个对象</code></pre></blockquote></li><li><p><code>new File(File parent, String child)</code>：根据父目录文件 + 子路径构建</p><blockquote><pre><code class="java">File parentFile1 = new File(&quot;d:\\&quot;);//目录是特殊的文件String fileName1 = &quot;test.txt&quot;;File file3 = new File(parentFile1, fileName1);</code></pre></blockquote></li><li><p><code>new File(String parent, String child)</code>：根据父路径 + 子路径构建</p></li><li><p><code>creatNewFile()</code>：创建新文件</p><blockquote><pre><code class="java">try &#123; file.createNewFile();//这个场合，内存对象才写入磁盘&#125; catch (IOException e) &#123; e.printStackTrace();&#125;</code></pre></blockquote></li></ul></li><li><p>获取文件相关信息</p><ul><li><p><code>getName()</code>：获取名称</p></li><li><p>&#x3D;&#x3D;<code>getAbsolutePath()</code>：获取文件绝对路径&#x3D;&#x3D;</p></li><li><p><code>getParent()</code>：获取文件父级目录</p></li><li><p><code>long length()</code>：获取文件大小（字节）</p></li><li><p><code>exists()</code>：文件是否存在，返回boolean类型。</p></li><li><p><code>isFile()</code>：是不是一个文件</p></li><li><p><code>isDirectory()</code>：是不是一个目录</p></li><li><p><code>isAbsolute()</code>：是不是绝对路径</p></li><li><p><code>canRead()</code>：是否可读</p><p>  <code>canWirte()</code>：是否可写</p></li><li><p><code>long lastModified()</code>：最后修改时间</p></li><li><p><code>String[] list()</code>：列出符合模式的文件名</p></li></ul></li><li><p>目录的操作和文件删除</p><ul><li><code>mkdir</code>：创建一级目录，返回boolean类型</li><li><code>mkdirs</code>：创建多级目录</li><li><code>delete</code>：删除空目录或文件</li><li><code>boolean renameTo(File newName)</code>：更改文件名</li></ul><p> 其实目录（在内存看来）就是特殊的文件</p></li></ol><p>注意事项：</p><ul><li>File 类可以获取文件的各种相关属性，可以对其进行改名，甚至删除。但除了文件名外的属性没有修改方法</li><li>File 类可以用来描述一个目录，但不能改变目录名，也不能删除目录</li></ul><h2><span id="172-io流">17.2 IO流</span></h2><ol><li>I &#x2F; O 是 Input &#x2F; Output 的缩写。IO 技术是非常实用的技术，用于处理数据传输。如 读 &#x2F; 写 文件，网络通讯等。</li><li>Java 程序中，对于数据的 输入 &#x2F; 输出 操作以 “流（stream）”的方式进行</li><li><code>java.io</code> 包下提供了各种 “流” 类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li><li>输入（input）：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li><li>输出（output）：将程序（内存）数据输出到外部存储</li></ol><h3><span id="1721-io流的分类">17.2.1 IO流的分类</span></h3><ul><li><p>按操作数据单位不同分为：</p><ul><li>字节流（8 bit）：二进制文件用该方法，&#x3D;&#x3D;能确保文件无损&#x3D;&#x3D;</li><li>字符流（按照字符，字符的字节数由编码决定）：文本文件，&#x3D;&#x3D;效率更高&#x3D;&#x3D;</li></ul></li><li><p>按数据流的流向不同分为：</p><ul><li>输入流：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li><li>输出流：将程序（内存）数据输出到外部存储(&#x3D;&#x3D;不只是硬件存储设备，可以是数据库、网络等&#x3D;&#x3D;)</li></ul></li><li><p>按流的角色不同分为：</p><ul><li>节点流</li><li>处理流 &#x2F; 包装流</li></ul><table><thead><tr><th>（抽象基类）</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table></li></ul><p>Java 的 IO流 总共涉及 40多个类，实际上都是上述 4 类的<strong>抽象基类</strong>(不能实例化)派生的</p><p>由这 4 个类派生的子类名称都是以其父类名作为子类名后缀</p><h3><span id="1722-io流-常用类">17.2.2 IO流 常用类</span></h3><h4><span id="17221-fileinputstream文件字节输入流">17.2.2.1 <code>FileInputStream</code>：文件字节输入流</span></h4><ul><li><p>构造器：</p><blockquote><pre><code class="java">new FileInputStream(File file);//通过一个 File 的路径指定创建new FileInputStream(String path);//通过一个路径指定创建new FileInputStream(FileDescriptor fdObj);//通过文件描述符创建</code></pre></blockquote></li><li><p>方法：</p><ul><li><p>&#x3D;&#x3D;<code>available()</code>：返回目前可以从流中读取的字节数&#x3D;&#x3D;</p><p>  实际操作时，读取的字节数可能大于这个返回值</p></li><li><p><code>close()</code>：关闭文件输入流，释放资源</p></li><li><p><code>finalize()</code>：确保在不引用文件输入流时调用其 <code>close()</code> 方法</p></li><li><p><code>getChannel()</code>：返回与此流有关的唯一的 <code>FileChannel</code> 对象</p></li><li><p><code>getFD()</code>：返回描述符</p></li><li><p><code>read()</code>：从该输入流中读取一个数据字节，&#x3D;&#x3D;返回对应的int值。&#x3D;&#x3D;</p><p>  如果没有输入可用，该方法会被阻止。返回 -1 的场合，说明到达文件的末尾。</p><blockquote><pre><code class="java">File file = new File(&quot;d:\\test&quot;);FileInputStream fileInputStream = null;int read;try &#123;     fileInputStream = new FileInputStream(file);     while ((read = fileInputStream.read()) != -1)&#123;         System.out.print((char) read); &#125;&#125; catch (IOException e) &#123;     e.printStackTrace();&#125; finally &#123; try &#123;         fileInputStream.close(); &#125; catch (IOException e) &#123;         e.printStackTrace();     &#125;&#125;//真 TM 复杂。throw 了算了</code></pre><p>这个场合，效率较低</p></blockquote><p>  <code>read(byte[] b)</code>：从该输入流中把最多 b.length 个字节的数据读入一个 byte 数组</p><p>  读取正常的场合，返回实际读取的字节数。</p><blockquote><pre><code class="java">...byte[] b = new byte[8];//一次读取 8 字节try &#123; fileInputStream = new FileInputStream(file); while ((read = fileInputStream.read(b)) != -1)&#123;     System.out.print(new String(b, 0, read));                                     //这一句看不懂请看[12.2 - 4] &#125;catch ...finally...</code></pre></blockquote><p>  <code>read(byte[] b, int off, int len)</code>：从该输入流中读取 len 字节数据，从数组下标 off 处起写入</p></li><li><p><code>skip(long n)</code>：从该输入流中跳过并去丢弃 n 个字节的数据</p></li><li><p><code>mark(int markArea)</code>：标记数据量的当前位置，并划出一个缓冲区。缓冲区大小至少为 markArea</p><p>  <code>reset()</code>：将输入流重新定位到对此流最后调用 <code>mark()</code> 方法时的位置</p><p>  <code>markSupported()</code>：测试数据流是否支持 <code>mark()</code> 和 <code>reset()</code> 操作</p></li></ul></li></ul><h4><span id="17222-fileoutputstream文件字节输出流">17.2.2.2 <code>FileOutputStream</code>：文件字节输出流</span></h4><ul><li><p>构造器：</p><blockquote><pre><code class="java">new FileOutputStream(File file);//通过一个 File 的路径指定创建new FileOutputStream(File file, boolean append);                            //append = false，写入采用 覆盖原文件 方式                            //append = true 的场合，写入采用 末尾追加 方式new FileOutputStream(String path);//通过一个路径指定创建new FileOutputStream(String path, boolean append);new FileOutputStream(FileDescriptor fdObj);//通过文件描述符创建</code></pre></blockquote><ul><li><p>覆盖</p><ul><li><pre><code class="java">  //下1面这种情况也是覆盖，只是一次写入没有完成会造成追加的假象，每次重新写入时会再次将原来的覆盖掉。  try&#123;     filewriter = new Filewirter(filepath)  &#125;catch&#123;      filewriter.write(&#39;H&#39;);      filewriter.write(&#39;e&#39;);       filewriter.write(&#39;l&#39;);  &#125;finally&#123;      ...//关闭流的操作  &#125;  </code></pre></li></ul></li></ul></li><li><p>方法：</p><ul><li><p><code>close()</code>：关闭文件输入流，释放资源</p></li><li><p><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节，&#x3D;&#x3D;对于字符流，一般写入的时候想要马上看到一般需要flush()&#x3D;&#x3D;</p></li><li><p><code>finalize()</code>：确保在不引用文件输入流时调用其 <code>close()</code> 方法</p></li><li><p><code>getChannel()</code>：返回与此流有关的唯一的 <code>FileChannel</code> 对象</p></li><li><p><code>getFD()</code>：返回描述符</p></li><li><p><code>write(byte[] b)</code>：将 b.length 个字节从指定 byte 数组写入此文件输出流</p><blockquote><pre><code class="java">File file = new File(&quot;d:\\test1&quot;);FileOutputStream fileOutputStream = null;try &#123; fileOutputStream = new FileOutputStream(file);                                     //此时，若文件不存在会被创建 fileOutputStream.write(&#39;a&#39;); String str = &quot;Melody&quot;; fileOutputStream.write(str.getBytes());&#125; catch...finally...</code></pre></blockquote><p>  <code>write(byte[] b， int off, int len)</code>：将指定 byte 数组中下标 off 开始的 len 个字节写入此文件输出流</p><p>  <code>write(int b)</code>：将指定字节写入此文件输出流</p></li></ul></li></ul><h4><span id="17223-filereader文件字符输入流">#17.2.2.3 <code>FileReader</code>：文件字符输入流</span></h4><blockquote><p>与其他程序设计语言使用 ASCII 码不同，Java 使用 Unicode 码表示字符串和字符。ASCII 码的字符占用 1 字节，可以认为一个字符就是一个字节。但 Unicode 码用 2 字节表示 1 个字符，此时字符流和字节流就不相同。</p></blockquote><ul><li><p>构造器：</p><blockquote><pre><code class="java">new FileRaeder(File file);new FileRaeder(String string);</code></pre></blockquote></li><li><p>方法：</p><ul><li><code>read()</code>：读取单个字符。</li><li><code>read(char[])</code>：批量读取多个字符到数组。</li></ul></li></ul><h4><span id="17223-filewriter文件字符输出流">#17.2.2.3 <code>FileWriter</code>：文件字符输出流</span></h4><ul><li><p>构造器：</p><blockquote><pre><code class="java">new FileWriter(File path);new FileWriter(String path2);new FileWriter(File path3, boolean append);new FileWriter(String path4, boolean append);</code></pre></blockquote></li><li><p>方法：</p><ul><li><code>write(int)</code>：写入单个字符</li><li><code>write(char[])</code>：写入指定数组</li><li><code>write(char[], off, len)</code>：写入指定数组的指定部分</li><li><code>write(string)</code>：写入字符串</li><li><code>write(string, off, len)</code>：写入字符串的指定部分</li><li><code>flush()</code>：刷新该流的缓冲。&#x3D;&#x3D;如果没有执行，内容就不会写入文件&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<code>close()</code>：等于 <code>flush()</code> + 关闭&#x3D;&#x3D;</li></ul></li></ul><p>&#x3D;&#x3D;使用FileWriter后，如果有没有执行flush或close，将一直在内存中，而不会写入文件。&#x3D;&#x3D;</p><p><strong>注意！<code>FileWriter</code> 使用后，必须关闭（close）或刷新（flush），否则无法真正写入</strong></p><h4><span id="17224-转换流-inputstreamreader-和-outputstreamwriter">#17.2.2.4 转换流 <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code></span></h4><ol><li><code>InputStreamReader</code> 是 <code>Reader</code> 的子类。可以把 <code>InputStream</code>（字节流）转换成 <code>Reader</code>（字符流）</li><li><code>OutputStreamWriter</code> 是 <code>Writer</code> 的子类。可以把 <code>OutputStream</code>（字节流）转换成 <code>Writer</code>（字符流）</li><li>处理纯文本数据时，如果使用字符流效率更高，并能有效解决中文问题，建议将字节流转换成字符流。</li><li>可以在使用时指定编码格式（UTF -8、GBK 等）</li></ol><ul><li><p>构造器</p><blockquote><pre><code class="java">InputStreamReader isr = new InputStreamReader(fileInputStream, &quot;UTF-8&quot;);                                        //传入 字节流 和 编码类型BufferedReader br = new Bufferedreader(isr);                                        //用另一个处理流包装</code></pre></blockquote></li></ul><h3><span id="1723-节点流和处理流">17.2.3 节点流和处理流</span></h3><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310201816224.png" alt="image-20231020181607114"></p><ol><li>节点流：从一个特定数据源读写数据。</li><li>处理流（包装流）：是 “连接” 在已存在的流（节点流或处理流）上，为程序提供更强大的读写功能。</li></ol><h4><span id="节点流和处理流的区别和联系">#节点流和处理流的区别和联系</span></h4><ol><li>节点流是 底层流 &#x2F; 低级流。直接和数据源相接。</li><li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法完成输入输出</li><li>&#x3D;&#x3D;处理流对<strong>节点流</strong>进行包装，使用了<strong>修饰器设计模式</strong>。<u>不会直接与数据源相连(只是调用)</u>&#x3D;&#x3D;</li><li>处理流的功能主要体现在</li></ol><ul><li>性能的提高：以增加缓冲的方式提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷方法来一次性输入大量数据，使用更加灵活方便</li></ul><ol start="5"><li>&#x3D;&#x3D;关闭时关闭外层流即可&#x3D;&#x3D;</li></ol><h4><span id="x3dx3d17231-缓冲区流x3dx3d">&#x3D;&#x3D;17.2.3.1 缓冲区流&#x3D;&#x3D;</span></h4><blockquote><p>缓冲区流是一种包装流。缓冲区字节流有 BufferedInputStream 和 BufferedOutputStream；缓冲区字符流有 BufferedWriter 和 BufferedReader。他们是在数据流上加了一个缓冲区。读写数据时，数据以块为单位进入缓冲区，其后的读写操作则作用于缓冲区。</p><p>这种方式能降低不同硬件设备间的速度差异，提高 I&#x2F;O 效率。</p></blockquote><p>构造器：</p><pre><code class="java">new BufferedReader(reader);//传入一个 Reader，也可以时Reader的子类，相当于向上转型new BufferedReader(reader, 1024);//传入 Reader 并指定缓冲区大小new BufferedWriter(writer);//传入一个 Writernew BufferedWriter(writer, 1024);//传入 Writer 并指定缓冲区大小                                            //追加还是覆盖，取决于 writer</code></pre><p>方法：</p><ul><li><p><code>bufferedReader.readLine()</code>：按行读取（不含换行符）。</p><p>会返回一个字符串。返回 null 时，表示读取完毕。</p><blockquote><pre><code class="java">String line;//readline()是拓展的按行读取文件的方法while (line = bufferedReader.readLine() != null)&#123; ...&#125;bufferedReader.close();//关闭外部处理流，在底层会关闭传入的结点流</code></pre></blockquote></li><li><p><code>bufferedWriter.write(String str)</code>：插入字符串</p></li><li><p><code>bufferedWriter.newLine()</code>：插入一个（和系统相关的）换行</p></li></ul><h4><span id="17232-数据数据流">17.2.3.2 数据数据流</span></h4><blockquote><p>除了字节或字节数组外，处理的数据还有其他类型。为解决此问题，可以使用 DataInputStream 和 DataOutputStream。它们允许通过数据流来读写 Java 基本类型，如布尔型（boolean）、浮点型（float）等</p></blockquote><p>构造器：</p><pre><code class="java">new DataInputStream(inputStream);new DataOutputStream(outputStream);</code></pre><p>方法：</p><ul><li><p><code>byte readByte()</code>：读取下一个 byte</p><p>  <code>int readInt()</code>、<code>double readDouble()</code>、<code>String readUTF()</code>……</p></li><li><p><code>void writeByte(byte b)</code>：写入一个 byte</p><p>  <code>void writeInt(int n)</code>、<code>void writeUTF(String str)</code>……</p><p>  虽然有对字符串的读写方法，但应避免使用这些方法，转而使用字符输入&#x2F;输出流。</p></li></ul><h4><span id="x3dx3d17233-对象流x3dx3d">&#x3D;&#x3D;17.2.3.3 对象流&#x3D;&#x3D;</span></h4><blockquote><p>当我们保存数据时，同时也把 数据类型 或 对象 保存。</p><p>以上要求，就是能够将 基本数据类型 或 对象 进行 序列化·反序列化 操作</p></blockquote><p><strong>序列化和反序列化</strong></p><ol><li>把<u>对象转成字符序列</u>的过程称为<strong>序列化</strong>。保存数据时，保存数据的值和数据类型</li><li>把字符序列转成对象的过程称为反序列化。恢复数据时，恢复数据的值和数据类型</li><li>需要让某个对象支持序列化机制，则必须让其类是 可序列化的。由此，该类必须实现下列接口之一<ul><li>&#x3D;&#x3D;<code>Serializable</code>：推荐。因为是标记接口，没有方法&#x3D;&#x3D;</li><li><code>Externalizable</code>：该接口有方法需要实现，一般使用Serializable接口</li></ul></li></ol><p><strong>transient 关键字</strong></p><ol><li>有一些对象状态不具有可持久性（如 Thread 对象或流对象），这样的成员变量必须用 transient 关键字标明。任何标有 transient 关键字的成员变量都不会被保存。</li><li>一些需要保密的数据，不应保存在永久介质中。为保证安全，这些变量前应加上 transient 关键字。</li></ol><ul><li><p>构造器：</p><blockquote><pre><code class="java">new ObjectInputStream(InputStream inputStream);new ObjectOutputStream(OutputStream outputStream);</code></pre></blockquote></li><li><p>方法：</p><p>反序列化顺序需要和序列化顺序一致，否则出现异常。</p><ul><li><p><code>writeInt(Integer)</code>：写入一个 int</p><p>  <code>readInt()</code>：读取一个 int</p></li><li><p><code>writeBoolean(Boolaen)</code>：写入一个 boolean</p><p>  <code>readBoolean()</code>：读取一个 boolean</p></li><li><p><code>writeChar(Character)</code>：写入一个 char</p><p>  <code>readChar()</code>：读取一个 char</p></li><li><p><code>writeDouble(Double)</code>：写入一个 double</p><p>  <code>readDouble()</code>：读取一个 double</p></li><li><p><code>writeUTF(String)</code>：写入一个 String</p><p>  <code>readUTF()</code>：读取一个 String</p></li><li><p><code>writeObject(Serializable)</code>：写入一个 Obj</p><p>  <code>readObject()</code>：读取一个 Obj</p><p>  读取的场合，如果想要调用方法，需要向下转型。</p><p>  为此，&#x3D;&#x3D;需要该类其引入。该类必须是公共的可访问的类&#x3D;&#x3D;</p></li></ul></li><li><p>&#x3D;&#x3D;<strong>注意事项</strong>&#x3D;&#x3D;</p><ol><li><p>&#x3D;&#x3D;读写顺序要一致,(序列化时的写入顺序和反序列化的读取顺序)&#x3D;&#x3D;</p></li><li><p>实现序列化或反序列化的对象，要实现 <code>Serializable</code> 或 <code>Externalizable</code> 接口</p></li><li><p>序列化的类中建议添加 <code>SerialVersionUID</code> 以提高版本兼容性</p><blockquote><pre><code class="java">private static final long serialVersionUID = 1L;//序列化的版本号</code></pre></blockquote></li></ol><p>  有此序列号的场合，后续修改该类，&#x3D;&#x3D;系统会认为只是版本修改，而非新的类&#x3D;&#x3D;</p></li></ul><ol start="4"><li><p>序列化对象时，默认将其中所有属性进行序列化（除了 <code>static</code> 和 <code>tansient</code> 修饰的成员）</p></li><li><p>&#x3D;&#x3D;序列化对象时，要求其属性(尤其是当属性为自定义类型的时候)也实现序列化接口&#x3D;&#x3D;</p></li><li><p>序列化具备可继承性。某类若实现可序列化，则其子类也可序列化</p></li></ol><p><strong>序列化Dog对象</strong></p><pre><code class="java">        //序列化：        FileOutputStream fileOutputStream = new FileOutputStream(&quot;f:\\dog.dat&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);        objectOutputStream.writeObject(dog);        objectOutputStream.close();        //反序列化：        FileInputStream fileInputStream = new FileInputStream(&quot;f:\\dog.dat&quot;);        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);        try &#123;            Dog dog1 = (Dog)objectInputStream.readObject();//这里回返回一个Object，可以强转为需要的类型。抛出一个异常。        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        objectInputStream.close();</code></pre><h4><span id="x3dx3d17234-标准输入-x2f-输出流x3dx3d">&#x3D;&#x3D;17.2.3.4 标准输入 &#x2F; 输出流&#x3D;&#x3D;</span></h4><table><thead><tr><th>Σ( ° △ °lll）</th><th>编译类型</th><th>运行类型</th><th>默认设备</th></tr></thead><tbody><tr><td><code>System.in</code>：标准输入流</td><td><code>InputStream</code></td><td><code>BufferedInputStream</code></td><td>键盘</td></tr><tr><td><code>System.out</code>：标准输出流</td><td><code>PaintStream</code></td><td><code>PaintStream</code></td><td>显示器</td></tr></tbody></table><h4><span id="17235-打印流-printstream-和-printwriter">#17.2.3.5 打印流 <code>PrintStream</code> 和 <code>PrintWriter</code></span></h4><blockquote><p>打印流只有输出流，没有输入流</p></blockquote><ol><li><p><code>PrintStream</code> 是 <code>OutputStream</code> 的子类。<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p></li><li><p>默认情况下，<code>System.out</code> 输出位置是 标准输出（即：显示器）</p><p> 修改默认输出位置：</p><blockquote><pre><code class="java">System.setOut(new PrintStream(path));System.out.println(&quot;hello&quot;);//这次会输出到path的文件中</code></pre></blockquote></li></ol><pre><code class="java">Printwriter printwriter =new PrintWriter(System.out);//System.out是一个PrintStream流printwriter.print(&quot;hello&quot;);//打印到控制台</code></pre><h4><span id="x3dx3d17236-properties-类x3dx3d">&#x3D;&#x3D;17.2.3.6 <code>Properties</code> 类&#x3D;&#x3D;</span></h4><ol><li><p><code>Properties</code> 是专门用于读写配置文件的集合类</p><p> 底层维护了一个 <code>Entry</code> 数组</p></li><li><p>配置文件格式：</p><pre><code>键=值键=值…ABNF</code></pre><p> <strong>注意：键值对不需要空格，值不需要引号（值默认 <code>String</code>）</strong></p></li><li><p>常见方法：</p><ul><li><p><code>load(InputStream)</code></p><p>  <code>load(Reader)</code>：加载配置文件的键值对到 <code>Properties</code> 对象</p><blockquote><pre><code class="java">Properties properties = new Properties();properties.load(new FileReader(&quot;d:\\data.data&quot;));</code></pre></blockquote></li><li><p><code>list(PrintStream)</code></p><p>  <code>list(PrintWriter)</code>：将数据显示到指定设备</p><blockquote><pre><code class="java">properties.list(System.out);//在控制台显示</code></pre></blockquote></li><li><p><code>getProperty(key)</code>：根据键获取值</p><blockquote><pre><code class="java">properties.get(&quot;IQ&quot;);</code></pre></blockquote></li><li><p><code>setProperty(key, value)</code>：设置键值对到 <code>Properties</code> 对象</p><p>  如果没有该 key，就是创建。如有，就是替换。</p><blockquote><pre><code class="java">properties.set(&quot;IQ&quot;, 0);properties.set(&quot;Balance&quot;, 0);</code></pre></blockquote></li><li><p><code>store(Writer, String)</code></p><p>  <code>store(OutputStream, String)</code>：把 <code>Properties</code> 中的键值对存储到配置文件。</p><p>  后面的 <code>String</code> 是注释。如有，会被用 <code>#</code> 标记并写在文件最上方。注释可以为 null。</p><p>  IDEA 中，如果含有中文，会储存为 unicode 码</p></li></ul><p> <strong>读取配置文件创建对象。</strong></p><ol><li><pre><code class="java"> public class Homework03 &#123;     public static void main(String[] args) throws IOException &#123;         Properties properties = new Properties();         properties.load(new FileReader(&quot;src\\dog.properties&quot;));         String name =  properties.get(&quot;name&quot;)+&quot;&quot;;//任何对象和字符串相加都会转换为字符串         int age = Integer.parseInt(properties.get(&quot;age&quot;)+&quot;&quot;);         String color =  properties.get(&quot;color&quot;)+&quot;&quot;;         //读取配置文件信息创建对象         Dog dog = new Dog(name, age, color);         System.out.println(dog);     &#125; &#125;  class Dog implements Serializable &#123;     private String name;     private int age;     private String color;      public Dog(String name, int age, String color) &#123;         this.name = name;         this.age = age;         this.color = color;     &#125;     //实现了tostring方法和getter、setter方法     ... &#125;</code></pre></li></ol><p> <a href="http://tool.chinaz.com/tools/unicode.aspx">查询 unicode 码</a></p></li></ol><h4><span id="17237-随机访问文件">#17.2.3.7 随机访问文件</span></h4><blockquote><p>程序阅读文件时不仅要从头读到尾，还要实现每次在不同位置进行读取。此时可以使用 RandomAccessFile</p></blockquote><p>构造器：</p><pre><code>new RandomAccessFile(String name, String mode);//通过文件名new RandomAccessFile(File file, String mode);//通过文件对象JAVA</code></pre><blockquote><p>参数 mode 决定以只读方式 <code>mode = &quot;r&quot;</code> 还是读写方式 <code>mode = &quot;rw&quot;</code> 访问文件。</p></blockquote><p>方法：</p><ul><li><p><code>long getFilePointer()</code>：返回文档指针的当前位置</p></li><li><p><code>void seek(long pos)</code>：将文档指针置于指定的绝对位置 pos</p><p>  文档指针的位置从文档开始的字符处开始计算，<code>pos = 0L</code> 表示文档的开始</p></li><li><p><code>long length()</code>：返回文件长度</p></li></ul><h4><span id="x3dx3d17238-节点流和处理流复制文件x3dx3d">&#x3D;&#x3D;17.2.3.8 节点流和处理流复制文件：&#x3D;&#x3D;</span></h4><h5><span id="节点流复制">节点流复制</span></h5><pre><code class="java"> @Test    public void copy()&#123;        FileInputStream fileInputStream = null;//扩大作用域，可以在finally中关闭流        FileOutputStream outputStream = null;        String filepath = &quot;f:\\k-on.png&quot;;//复制图片        String despath = &quot;f:\\k-on2.png&quot;;        byte[] buffer = new byte[1024];        int readlen = 0;        try &#123;            fileInputStream = new FileInputStream(filepath);            outputStream = new FileOutputStream(despath);            while ((readlen = fileInputStream.read(buffer))!=-1)&#123;                outputStream.write(buffer,0,readlen);//这里必须用这个形式，如果只传一个buffer，                // 那么每次读完小于1024的数据时下次读取会导致数据丢失，因为上一次数据的残留数据还在buffer数组的末尾。            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;finally &#123;            try &#123;                if(fileInputStream!=null) &#123;                    fileInputStream.close();                &#125;                if(outputStream!=null)&#123;                    outputStream.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><h5><span id="处理流复制">处理流复制</span></h5><pre><code class="java">/** *处理二进制文件，也可以处理文本文件，相比使用节点流处理文本文件在控制台输出不会报乱码。 **/@Testpublic void copy_2()&#123;    String srcpath = &quot;f:\\hello.txt&quot;;    String despath = &quot;f:\\hello2.txt&quot;;    BufferedInputStream bufferedInputStream =null;    BufferedOutputStream bufferedOutputStream = null;    byte[] buffer = new byte[1024];    int readlen =0;    try &#123;        bufferedInputStream = new BufferedInputStream(new FileInputStream(srcpath));        bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(despath));        while ((readlen=bufferedInputStream.read(buffer))!=-1)&#123;            bufferedOutputStream.write(buffer,0,readlen);            System.out.println(new String(buffer,0,readlen));        &#125;        System.out.println(&quot;文件复制成功...&quot;);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;finally &#123;        try &#123;            if(bufferedInputStream!=null)&#123;                bufferedInputStream.close();            &#125;            if (bufferedOutputStream!=null)&#123;                bufferedOutputStream.close();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><pre><code class="java">/**     * 处理流复制文件,不要处理二进制文件，可能造成文件损坏     */    @Test    public void copy()&#123;        BufferedReader br=null;        BufferedWriter bw=null;        String srcPath = &quot;f:\\hello.txt&quot;;        String desPath = &quot;f:\\hello3.txt&quot;;        String line;//文本行数        try &#123;            br = new BufferedReader(new FileReader(srcPath));            bw = new BufferedWriter(new FileWriter(desPath));            while ((line=br.readLine())!=null)&#123;                bw.write(line);                bw.newLine();//插入换行，否则都将在同一行            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;finally &#123;            try &#123;                if(br!=null) &#123;                    br.close();                &#125;                if(bw!=null) &#123;                    bw.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre><blockquote><p><code>if (br != null)</code> 的目的是检查 <code>BufferedReader</code> 对象 <code>br</code> 是否已经被成功初始化，因为在 <code>try</code> 块内部的 <code>br</code> 对象可能会在打开文件时发生异常而变为 <code>null</code>。如果 <code>br</code> 没有被初始化，调用 <code>br.close()</code> 就会导致 <code>NullPointerException</code> 异常。因此，在 <code>finally</code> 块中使用 <code>if (br != null)</code> 来检查 <code>br</code> 是否非空，以确保在关闭文件之前先检查它是否已经初始化。</p><p>同样的逻辑也适用于 <code>bw.close()</code>，为了代码的健壮性，通常会在关闭资源之前检查资源是否已经被成功初始化。这是一种防御性编程的做法，有助于避免潜在的异常情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19 网络编程</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/19%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="19-网络编程">19 网络编程</span></h1><p>网络通信：两台设备之间通过网络实现数据传输。</p><p><code>java.net</code> 包下提供了一系列类或接口，供程序员使用，完成网络通信</p><h2><span id="191-网络的相关概念">19.1 网络的相关概念</span></h2><p><strong>网络</strong></p><p>网络：两台或多台设备通过一定物理设备连接起来构成了网络</p><p>根据网络覆盖范围的不同，对网络进行分类：</p><ul><li>局域网：覆盖范围最小，仅覆盖一个教室·机房</li><li>城域网：覆盖范围较大，可覆盖一个城市</li><li>广域网：覆盖范围最大，可以覆盖全国，甚至全球。万维网 是广域网的代表</li></ul><p><strong>IP 地址</strong></p><p>IP 地址：用于唯一标识网络中的每台计算机 &#x2F; 主机</p><p>查看 IP 地址：<code>ipconfig</code></p><p>IPv4 是 4 个字节（32位）表示。每个字节范围是 [0,255]</p><p>IP 地址的表示形式：点分十进制（xx.xx.xx.xx），每个十进制数范围是 [0,255]</p><p>IP 地址的组成 &#x3D; 网络地址 + 主机地址</p><ul><li>A类：0 + 7 位网络号 + 24 位主机号（0.0.0.0 ~ 127.255.255.255）</li><li>B类：1 + 0 + 14 位网络号 + 16 位主机号（128.0.0.0 ~ 191.255.255.255）</li><li>C类：1 + 1 + 0 + 21 位网络号 + 8 位主机号（192.0.0.0 ~ 223.255.255.255）</li><li>D类：1 + 1 + 1 + 0 + 28 位多播组号（224.0.0.0 ~ 239.255.255.255）</li><li>E类：1 + 1 + 1 + 1 + 0 + 27 位（留待后用）（240.0.0.0 ~ 247.255.255.255）</li></ul><p>IPv6 是互联网工程任务组设计的用于替代 IPv4 的下一代 IP 协议。其地址数量可以为全世界每一粒沙子编上一个地址</p><p>IPv4 最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6 的使用，不仅能解决网络地址资源数量的问题，也解决了多种接入设备接入互联网的障碍</p><p>IPv6 使用 16 个字节（128 位）表示地址。</p><p>表示形式有：</p><ul><li><p>冒分十六进制表示法： （X:X:X:X:X:X:X:X）</p><p>  <code>:</code> 之间的部分，出现 0 开头的场合，那些 0 可以省略</p></li><li><p>0 位压缩表示法：把连续的 <code>0</code> 压缩为 <code>::</code>，这个压缩只能出现一次（X::X:X）</p></li><li><p>内嵌 IPv4 地址表示法：前 96位 用冒分十六进制表示，后面 32位 用 IPv4 的点分十进制（X:X:X:X:X:XX:d.d.d.d）</p></li></ul><p><strong>子网掩码</strong></p><p>只用一个 IP 地址，无法分辨网络部分与主机部分的分界线。因此，使用子网掩码来表示分界线。</p><p>这个场合，对应的网络部分的子网掩码的二进制数字设为 1</p><p><a href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg=="><img src="https://i-melody.github.io/img/Java_InputImage/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E5%9B%BE_19.1.webp" alt="img"></a><br><em>(子网掩码图_19.1)</em></p><p>此外，还能把子网掩码与 IP 地址组合</p><ul><li>在 IP 地址后加斜线及网络部分二进制数字数（IPV4）：192.168.15.1&#x2F;16</li><li>IPv6：X:X:X:X:X:X:X:X&#x2F;64</li></ul><p>通过更改子网掩码，可以细分网络为多个子网。</p><p><a href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg=="><img src="https://i-melody.github.io/img/Java_InputImage/%E5%AD%90%E7%BD%91%E5%9B%BE_19.1.webp" alt="img"></a><br><em>(子网图_19.1)</em></p><p><strong>保留地址</strong></p><p>IP 还定义了一套特殊的地址格式，称为保留地址，这些保留地址不分配给任何主机。</p><table><thead><tr><th align="center">网络号</th><th align="center">主机号</th><th align="center">地址类型</th><th align="center">举例</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">全 0</td><td align="center">全 0</td><td align="center">本机地址</td><td align="center">0.0.0.0</td><td align="center">启动时使用</td></tr><tr><td align="center">任意</td><td align="center">全 0</td><td align="center">网络地址</td><td align="center">61.0.0.0</td><td align="center">标识一个网络</td></tr><tr><td align="center">任意</td><td align="center">全 1</td><td align="center">直接广播地址</td><td align="center">129.21.255.255</td><td align="center">在特定网络上广播</td></tr><tr><td align="center">全 1</td><td align="center">全 1</td><td align="center">有线广播地址</td><td align="center">255.255.255.255</td><td align="center">在本网段上广播</td></tr><tr><td align="center">第一段为 127</td><td align="center">任意</td><td align="center">回送地址</td><td align="center">127.0.0.1</td><td align="center">测试</td></tr></tbody></table><p><strong>私有地址</strong></p><p>私有地址：与 IP 地址（全局地址）相比，在不同的网络中可以重复的地址。</p><p>私有地址是以下范围中的地址。这些地址不能作为全局地址使用：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>将私有地址连接到全局地址的方法：</p><ul><li>NAT：一种私有地址与全局地址一一对应的机制</li><li>NAPT：一种用一个全局地址连接多个计算机的机制</li></ul><p><strong>域名</strong></p><p>示例：<a href="http://bbs.tianya.cn/post-house-252774-1.shtml">http://bbs.tianya.cn/post-house-252774-1.shtml</a></p><p>为了方便记忆，解决记忆 IP 的困难</p><p>IP 地址根据 HTTP 协议 映射成域名</p><p>通过 DNS（Domain Name System）服务将域名转化为 IP 地址</p><p><strong>端口号</strong></p><p>用于标识计算机上某个特定的网络程序</p><p>表示形式：以整数形式，范围 [0,65535]</p><p>&#x3D;&#x3D;0 ~ 1024 已经被占用，不要使用。比如 ssh 22、ftp 21、smtp 25、http 80&#x3D;&#x3D;</p><p>&#x3D;&#x3D;常见的网络程序端口号：&#x3D;&#x3D;</p><ul><li>tomcat：8080</li><li>mysql：3306</li><li>oracle：1521</li><li>sqlserver：1433</li></ul><p><strong>网络通信协议</strong></p><p>协议（TCP&#x2F;IP）</p><p>TCP&#x2F;IP：传输控制协议 &#x2F; 因特网互联协议（Transmission Control Protocol &#x2F; Internet Protocol），又叫 网络通讯协议。这个协议是 Internet 最基本的协议、Internet 国际互联网络的基础。简单来讲，就是由 网络层的 IP 协议 和传输层的 TCP 协议 组成</p><p><a href="https://i-melody.github.io/img/Java_InputImage/%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E5%9B%BE_19.1.webp"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" alt="img"></a></p><p><em>(数据封装图_19.1)</em></p><table><thead><tr><th>OSI 模型（理论）</th><th>TCP&#x2F;IP 模型（实际使用）</th><th>TCP&#x2F;IP 模型各层对应协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP、ftp、telent、DNS……</td></tr><tr><td>表示层</td><td>应用层</td><td>同上</td></tr><tr><td>会话层</td><td>应用层</td><td>同上</td></tr><tr><td>传输层</td><td>传输层（TCP）</td><td>TCP、UDP……</td></tr><tr><td>网络层</td><td>网络层（IP）</td><td>IP、ICMP、ARP……</td></tr><tr><td>数据链路层</td><td>物理 + 数据链路层</td><td>Link</td></tr><tr><td>物理层</td><td>物理 + 数据链路层</td><td>同上</td></tr></tbody></table><h3><span id="1911-tcp-和-udp">19.1.1 TCP 和 UDP</span></h3><p><strong>TCP</strong></p><p>传输控制协议</p><ol><li>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道。TCP 通信是一对一通信</li><li>传输前，采用 “三次握手” 方式，&#x3D;&#x3D;是可靠的&#x3D;&#x3D;</li><li>TCP 协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输。传输前，先确认要交流的数据量。那个数据量、数据窗口取较小方的数值。</li><li>发送方没有收到接收方的确认应答时，（在一定次数内）会再次发送数据包</li><li>传输完毕，需释放已建立的连接，效率低</li></ol><p><strong>UDP</strong></p><p>用户数据协议</p><ol><li>将 数据、源、目的 封装成数据包，不需要建立连接。可以同时向多个接收方发送</li><li>&#x3D;&#x3D;每个数据包大小限制在 64K 以内，不适合传输大量数据&#x3D;&#x3D;</li><li>因无需连接，所以&#x3D;&#x3D;是不可靠的&#x3D;&#x3D;</li><li>接收方无需发送确认应答</li><li>发送数据结束时无需释放资源（因为不是面向连接的），速度快</li></ol><h2><span id="192-inetaddress-类">19.2 <code>InetAddress</code> 类</span></h2><p><strong>相关方法</strong></p><ul><li><code>getLocalHost</code>：获取本机 <code>InetAddress</code> 对象&#x2F;&#x2F;静态方法</li><li><code>getByName</code>：根据指定主机名 &#x2F; 域名获取 IP 地址对象&#x2F;&#x2F;静态方法</li><li><code>getHostName</code>：获取 <code>InetAddress</code> 对象的主机名&#x2F;域名</li><li><code>getHostAddress</code>：获取 <code>InetAddress</code> 对象的地址</li></ul><h2><span id="193-socket">19.3 Socket</span></h2><ol><li>套接字（Socket）开发网络应用程序被广泛采用，以至于成为了事实上的标准</li><li>通信的两端都要有 Socket，是两台机器间通信的端点</li><li><u>网络通信其实就是 Socket 间的通信</u></li><li>Socket 允许程序把网络连接当成一个流，数据在两个 Socket 间通过 IO 传输</li><li>一般主动发起通信的应用程序属于客户端，等待通信请求的为服务端</li></ol><h3><span id="1931-tcp-网络通信编程">19.3.1 TCP 网络通信编程</span></h3><ol><li>基于客户端——服务端的网络通信</li><li>底层使用的是 TCP &#x2F; IP 协议</li><li>应用场景距离：客户端发送数据，服务端接收并显示</li><li>基于 Socket 的 TCP 编程</li></ol><p><strong>下面，示范一个 服务端</strong></p><pre><code class="java">public void server() throws IOException&#123; ServerSocket serverSocket = new ServerSocket(9000);//[1] Socket clientSocket = serverSocket.accept();   //[2] //下面是输入流，不解释了 InputStream inputStream = clientSocket.getInputStream(); System.out.println(clientSocket.getInetAddress()); int n; byte[] b = new byte[1024]; byte[] B = new byte[0]; while ((n = inputStream.read(b, 0, 1024)) != -1) &#123;     B = Arrays.copyOf(B, B.length + n);     for (int i = 0; i &lt; n; i++) &#123;         B[B.length - n + i] = b[i];     &#125; &#125;                                 System.out.println(new String(B)); InputStream.close(); Socket.close(); serverSocket.close();//[3]&#125;</code></pre><ol><li><code>ServerSocket serverSocket = new ServerSocket(9000);</code></li></ol><p>  这个语句用以监听 9000 这个端口，且&#x3D;&#x3D;只会监听一次&#x3D;&#x3D;</p><p>  如果想要一直保持监听状态,像下面的案例，&#x3D;&#x3D;将会一直在设置的端口监听，每次循环都会返回一个socket。&#x3D;&#x3D;</p><pre><code class="java">while (true) &#123;//不停监听9000接口            System.out.println(&quot;服务端等待接收消息...&quot;);            Socket socket = serverSocket.accept()                        ...//对返回的socket进行处理&#125;</code></pre><p>  细节：这里要求该端口没有被其他服务占用。</p><ol start="2"><li><p><code>Socket clientSocket = serverSocket.accept();</code></p><p> &#x3D;&#x3D;这个语句用以接收连接的 <code>Socket</code>。没有连接时，程序会阻塞在这里。&#x3D;&#x3D;</p><p> &#x3D;&#x3D;细节：此处 <code>accept()</code> 可以返回多个 <code>Socket</code>，即多并发&#x3D;&#x3D;</p></li><li><p><code>serverSocket.close();</code></p><p> 结束监听后，务必关闭！</p></li></ol><p><strong>下面，示范一个客户端</strong></p><pre><code class="java">public void client() throws IOException&#123; String serverIP = &quot;192.168.3.16&quot;;//[1] Socket socket = new Socket(serverIP, 9000);//[2] OutputStream outputStream = socket.getOutputStream(); outputStream.write(&quot;hello,Server!&quot;.getBytes(StandardCharsets.UTF_8)); socket.shutdownOutput();//[3] outputStream.close(); socket.close();&#125;</code></pre><ol><li><p>这个 IP 是我的本机地址。代表的是 服务端 地址</p></li><li><p><code>Socket socket = new Socket(serverIP, 9000);</code></p><p> 表示访问指定 IP 的 9000 端口</p></li><li><p>&#x3D;&#x3D;<code>socket.shutdownOutput();</code>&#x3D;&#x3D;</p><p> 这里是输出一个结束标记。若不如此做，socket 就不知道是否数据发送完成</p><p> &#x3D;&#x3D;特别的，由 字节流 输出的场合，<code>writer.newLine()</code> 可以替代结束标记，后面要使用<code>writer.flush()</code>。但是这个场合，接收必须是 读取单行<code>reader.readLine()</code>&#x3D;&#x3D;,不支持while循环读取，while读取场合还是需要使用&#x3D;&#x3D;<code>socket.shutdownOutput();</code>&#x3D;&#x3D;</p></li></ol><p>案例：</p><p>1.编写一个服务端，和一个客户端<br>2.服务器端在8888端口监听<br>3.客户端连接到服务端，发送一张图片eqie.png<br>4.服务器端接收到客户端发送的图片，保存到sc下，发送”收到图片”再退出<br>5.客户端接收到服务端发送的”收到图片”，再退出<br>6.该程序要求使用StreamUtils..java</p><pre><code class="java">public class TCPFileUploadClient &#123;    public static void main(String[] args) throws Exception &#123;        //客户端连接服务端 8888，得到Socket对象        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);        //创建读取磁盘文件的输入流        //String filePath = &quot;e:\\qie.png&quot;;        String filePath = &quot;e:\\abc.mp4&quot;;        BufferedInputStream bis  = new BufferedInputStream(new FileInputStream(filePath));        //bytes 就是filePath对应的字节数组        byte[] bytes = StreamUtils.streamToByteArray(bis);        //通过socket获取到输出流, 将bytes数据发送给服务端        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());        bos.write(bytes);//将文件对应的字节数组的内容，写入到数据通道        bis.close();        socket.shutdownOutput();//设置写入数据的结束标记        //=====接收从服务端回复的消息=====        InputStream inputStream = socket.getInputStream();        //使用StreamUtils 的方法，直接将 inputStream 读取到的内容 转成字符串        String s = StreamUtils.streamToString(inputStream);        System.out.println(s);        //关闭相关的流        inputStream.close();        bos.close();        socket.close();    &#125;&#125;</code></pre><pre><code class="java">public class TCPFileUploadServer &#123;    public static void main(String[] args) throws Exception &#123;        //1. 服务端在本机监听8888端口        ServerSocket serverSocket = new ServerSocket(8888);        System.out.println(&quot;服务端在8888端口监听....&quot;);        //2. 等待连接        Socket socket = serverSocket.accept();        //3. 读取客户端发送的数据        //   通过Socket得到输入流        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());        byte[] bytes = StreamUtils.streamToByteArray(bis);        //4. 将得到 bytes 数组，写入到指定的路径，就得到一个文件了        String destFilePath = &quot;src\\abc.mp4&quot;;        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath));        bos.write(bytes);        bos.close();        // 向客户端回复 &quot;收到图片&quot;        // 通过socket 获取到输出流(字符)        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        writer.write(&quot;收到图片&quot;);        writer.flush();//把内容刷新到数据通道，对于字符流，一般写入的时候想要马上看到一般需要flush()        socket.shutdownOutput();//设置写入结束标记        //关闭其他资源，一般和socket有关的都放在最后        writer.close();        bis.close();        socket.close();        serverSocket.close();    &#125;&#125;</code></pre><pre><code class="java">/** * 此类用于演示关于流的读写方法 */public class StreamUtils &#123;    /**     * 功能：将输入流转换成byte[]， 即可以把文件的内容读入到byte[]     * @param is     * @return     * @throws Exception     */    public static byte[] streamToByteArray(InputStream is) throws Exception&#123;        ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象        byte[] b = new byte[1024];//字节数组        int len;        while((len=is.read(b))!=-1)&#123;//循环读取            bos.write(b, 0, len);//把读取到的数据，写入bos        &#125;        byte[] array = bos.toByteArray();//然后将bos 转成字节数组        bos.close();        return array;    &#125;    /**     * 功能：将InputStream转换成String     * @param is     * @return     * @throws Exception     */    public static String streamToString(InputStream is) throws Exception&#123;        BufferedReader reader = new BufferedReader(new InputStreamReader(is));        StringBuilder builder= new StringBuilder();        String line;        while((line=reader.readLine())!=null)&#123;            builder.append(line+&quot;\r\n&quot;);        &#125;        return builder.toString();    &#125;&#125;</code></pre><h4><span id="19311-netstat-指令">#19.3.1.1 netstat 指令</span></h4><ol><li><p><code>netstat -an</code> 可以查看当前主机网络情况，包括端口监听情况和网络连接情况</p></li><li><p><code>netstat -an | more</code> 可以分页显示</p></li><li><p><code>netstat -anb</code> 可以显示占用端口的应用</p></li><li><p>要求在 dos 控制台下执行</p></li><li><p>Listening 表示某个端口在监听。</p><p> 如果有一个外部程序连接到该端口，就会显示一条连接信息 Established</p></li></ol><h4><span id="19312-tcp-连接秘密">#19.3.1.2 TCP 连接秘密</span></h4><p><strong>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的。这个端口由 TCP&#x2F;IP 来分配，是不确定的，随机的。</strong></p><h3><span id="1932-udp-网络通信编程">19.3.2 UDP 网络通信编程</span></h3><ol><li>类 <code>DatagramSocket</code> 和 <code>DatagramPacket</code> 实现了基于 UDP 协议网络程序</li><li>没有明确的服务端和客户端，演变成数据的发送端和接收端</li><li>UDP 数据报通过数据报套接字 <code>DatagramSocket</code> 发送和接收。系统不保证 UDP 数据报一定能安全送到目的地，也不能确定什么时候能抵达</li><li><code>DatagramPacket</code> 对象封装了 UDP 数据报，在数据报中包含了发送端的 IP 地址和端口号以及接收端的 IP 地址和端口号</li><li>接收到 <code>DtagramPacket</code> 对象时，需要进行拆包，取出数据</li><li><code>DatagramSocket</code> 可以指定在哪个端口接收数据</li><li>UDP 协议中每个数据报都给出了完整的地址信息，因此&#x3D;&#x3D;无需发送方和接收方的连接&#x3D;&#x3D;</li></ol><p><strong>下面，示范一个接收端</strong></p><pre><code class="java">DatagramSocket ds = new DatagramSocket(9000);//[1]byte[] bytes = new byte[1024];DatagramPacket dp = new DatagramPacket(bytes, bytes.length);//[2]System.out.println(&quot;萝茵 聆听中……&quot;);ds.receive(dp);//[3]int len = dp.getLength();bytes = dp.getData();System.out.println(&quot;萝茵听到了如下内容：\n&quot; + new String(bytes, 0, len));ds.close();//[4]</code></pre><ol><li><p><code>DatagramSocket ds = new DatagramSocket(9000);</code></p><p> 以 9000 这个端口作为监听端口</p></li><li><p><code>DatagramPacket dp = new DatagramPacket(bytes, bytes.length);</code></p><p> 构建 <code>DatagramPacket</code> 对象，准备接收数据</p></li><li><p><code>ds.receive(dp);</code></p><p> 监听信息，放到刚刚创建的 <code>DatagramPacket</code> 对象，&#x3D;&#x3D;如果没有发送端发送消息，会导致阻塞&#x3D;&#x3D;</p></li><li><p><code>ds.close()</code></p><p> 要记得关闭呦 ★ ~</p></li></ol><p><strong>下面，示范一个发送端</strong></p><pre><code class="java">System.out.println(&quot;萝茵，大声喊道：你好，世界！&quot;);DatagramSocket ds = new DatagramSocket(8000);//[1]InetAddress ia = InetAddress.getByName(serverIP);byte[] bytes = &quot;你好，世界&quot;.getBytes(StandardCharsets.UTF_8);DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ia, 9001);                                                                //[2]ds.send(dp);//[3]System.out.println(&quot;声音在虚无中回荡着……&quot;);ds.close();//[4]</code></pre><ol><li><p><code>DatagramSocket ds = new DatagramSocket(8000);</code></p><p> 以 8000 这个端口作为发送端口</p></li><li><p><code>DatagramPacket dp = new DatagramPacket(bytes, bytes.length, ia, 9001);</code></p><p> 把要发送的数据、数据长度、对象地址、对象端口 放到包里</p></li><li><p><code>ds.send(dp);</code></p><p> 走你 ★ ~</p></li><li><p><code>ds.close();</code></p><p> 鸟尽弓藏</p></li></ol><p><em><strong>A和B端都可以是接收端或发送端，没有客户端和服务器的概念。</strong></em></p><pre><code class="java">public class DatagramSocketA &#123;    public static void main(String[] args) throws IOException &#123;        DatagramSocket socket = new DatagramSocket(6666);        byte[] bytes = new byte[1024];        DatagramPacket data = new DatagramPacket(bytes,bytes.length);        socket.receive(data);//【1】如果没有发送端发送信息，将会导致阻塞，即代码不会进行下去。        int len = data.getLength();        bytes = data.getData();        System.out.println(new String(bytes,0,len));        byte[] buffer = &quot;好的，明天见&quot;.getBytes();        DatagramPacket datagramPacket = new DatagramPacket(buffer,0,buffer.length,                InetAddress.getByName(&quot;DESKTOP-DP2R4CS&quot;),5555);        socket.send(datagramPacket);        socket.close();        System.out.println(&quot;A端退出...&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class DatagramSocketB &#123;    public static void main(String[] args) throws IOException &#123;        DatagramSocket socket = new DatagramSocket(5555);        byte[] bytes = &quot;hello,明天吃火锅&quot;.getBytes();        DatagramPacket packet = new DatagramPacket(bytes,0,bytes.length,                InetAddress.getByName(&quot;DESKTOP-DP2R4CS&quot;),6666);        socket.send(packet);        byte[] buffer = new byte[1024];        DatagramPacket datagramPacket = new DatagramPacket(buffer,buffer.length);        socket.receive(datagramPacket);        int length = datagramPacket.getLength();        byte[] data = datagramPacket.getData();        System.out.println(new String(data,0,length));        socket.close();        System.out.println(&quot;B端退出...&quot;);    &#125;&#125;</code></pre><h2><span id="附录">附录</span></h2><h3><span id="项目开发流程">项目开发流程</span></h3><h4><span id="1-需求分析">#1 需求分析</span></h4><p><strong>需求分析师（懂技术 + 懂行业）</strong></p><ol><li><p>需求分析报告</p><ul><li>项目功能</li><li>客户要求</li></ul></li></ol><h4><span id="2-设计阶段">#2 设计阶段</span></h4><p><strong>架构师 &#x2F; 项目经理</strong></p><ol><li><p>设计工作</p><ul><li>UML 类图</li><li>流程图</li><li>模块设计</li><li>数据库设计</li><li>架构</li></ul></li><li><p>原型开发</p></li><li><p>组建团队</p></li></ol><h4><span id="3-实现阶段">#3 实现阶段</span></h4><p><strong>程序员 &#x2F; 码农</strong></p><ol><li>完成架构师的模块功能</li><li>测试自己的模块</li></ol><h4><span id="4-测试阶段">#4 测试阶段</span></h4><p><strong>测试工程师</strong></p><ol><li>单元测试</li><li>测试用例</li><li>白盒测试</li><li>黑盒测试</li><li>集成测试</li></ol><h4><span id="5-实施阶段">#5 实施阶段</span></h4><p><strong>实施工程师（开发能力 &#x2F; 环境配置部署能力）</strong></p><ol><li>把项目正确地部署到客户的平台，并保证运行正常</li><li>身体好</li></ol><h4><span id="6-维护阶段">#6 维护阶段</span></h4><ol><li>发现 bug 并解决</li><li>项目升级</li></ol><h1><span id="项目-多用户即时通信系统"></span></h1>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 面向对象编程（中级）</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E4%B8%AD%E7%BA%A7)/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E4%B8%AD%E7%BA%A7)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="7-面向对象编程中级">7 面向对象编程（中级）</span></h1><h2><span id="72-包">7.2 包</span></h2><blockquote><p>包的作用：1. 区分相同名字的类 2. 当类很多时，便于管理 3. 控制访问范围</p><p>语法：<code>package com.name</code> 其中 <code>com</code> <code>name</code> 分别是 一级 和 二级目录，用 <code>.</code> 分隔</p><p>包的本质：就是创建不同 文件夹&#x2F;目录 来保存 类 文件</p></blockquote><p><strong>命名规则：</strong></p><ul><li>只能包含 数字 <code>1 2 3</code>、字母 <code>a b A b</code>、下划线 <code>_</code>、小圆点 <code>.</code></li><li>不能用 数字 开头。每级目录都不能。</li></ul><p><strong>命名规范：</strong></p><ul><li>全小写字母 + 小圆点</li><li><code>com.公司名.项目名.业务模块名</code></li></ul><p><strong>常用的包：</strong></p><p><code>java.lang</code>：基本包，默认引入，不需要再引入</p><p><code>java.util</code>：系统提供的工具包。工具类。</p><p><code>java.net</code>：网络包，网络开发。</p><p><code>java.awt</code>：Java 的界面开发，GUI。</p><p><strong>引入包：</strong></p><ul><li>只引入该包下的一个类：<code>import java.util.Scanner</code></li><li>引入该包的所有内容（不建议）：<code>import java.util.*</code></li></ul><p><strong>使用细节：</strong></p><ol><li><p><code>package</code> 的作用是声明当前类所在的包，要放在 类 的 最上面。一个 类 中最多有一句 <code>package</code></p></li><li><p><code>import</code> 放在 <code>package</code> 下面，类定义 前面。可以有多条语句，且没有顺序要求</p></li><li><p>&#x3D;&#x3D;编译器编译时 <strong>不会</strong> 检查目录结构。&#x3D;&#x3D;</p><p> &#x3D;&#x3D;即使一个包处于错误的目录下（只要其不依赖其他包）也可能通过编译。&#x3D;&#x3D;</p><p> &#x3D;&#x3D;但是，虚拟机会找不到该包，最终程序无法运行。&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;从 1.2 版本开始，用户不能再把包放在 java. 开头的目录下了。若如此做，这些包会被禁止加载&#x3D;&#x3D;</p></li></ol><h2><span id="73-访问修饰符">7.3 访问修饰符</span></h2><h3><span id="731-访问权限特点">7.3.1 访问权限特点</span></h3><p>Java 提供 4 种 访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）</p><ul><li><p>公开级别：<code>public</code>，对外公开。</p></li><li><p>受保护级别：<code>protected</code>，对 子类 和 同一个包中的类 公开。</p><p>  <em><strong>——什么是 子类？详见 [[ 7.5 继承 ]](<a href="https://i-melody.github.io/2021/12/05/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/7">https://i-melody.github.io/2021/12/05/Java/入门阶段/7</a> 面向对象编程（中级）&#x2F;#7-5-继承（重点）)</strong></em></p></li><li><p>默认级别：没有修饰符号，向 同一个包的类 公开。</p></li><li><p>私有级别：<code>private</code>，只有 同类 可以访问，不对外公开。</p></li></ul><table><thead><tr><th>(⌐■_■)</th><th align="center">默认（无修饰符）</th><th align="center">private</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类</td><td align="center">可</td><td align="center">可</td><td align="center">可</td><td align="center">可</td></tr><tr><td>同包中的子类</td><td align="center">可</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td></tr><tr><td>同包的非子类</td><td align="center">可</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td></tr><tr><td>其他包的子类</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td></tr><tr><td>其他包的非子类</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">可</td></tr></tbody></table><h3><span id="732-使用说明">7.3.2 使用说明</span></h3><ol><li>修饰符可以修饰类中的 属性、成员方法 及 类</li><li>&#x3D;&#x3D;只有 默认 和 <code>public</code> 才能修饰 类，并遵循上述访问权限特点&#x3D;&#x3D;</li><li>成员方法 的访问规则和 属性 相同</li><li>private 修饰的变量可以被 任意本对象同类的对象访问</li></ol><h2><span id="74-封装">7.4 封装</span></h2><blockquote><p>封装（encapsulation）就是把抽象出的 数据[属性] 和对数据的 操作[方法] 封装在一起。数据 被保护在内部，程序的其他部分只有通过被授权的 操作[方法]，才能对数据进行操作。</p></blockquote><p>封装的好处：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ul><p><strong>实现步骤：</strong></p><ol><li>将属性私有化 <code>private</code></li><li>提供一个公共的 <code>set</code> 方法，用于对属性判断并赋值</li><li>提供一个公共的 <code>get</code> 方法，用于获取属性的值</li></ol><p><strong>编译多个源文件：</strong></p><pre><code class="cmd">javac MyClass.java</code></pre><p>该文件中使用了其他类时，Java 编译器会查找对应名称的 .class 文件。没有找到的场合，转而寻找 .java 文件，并对其编译。倘若 .java 文件相较原有 .class 文件更新，编译器也会自动重新编译该文件。</p><h3><span id="x3dx3d741-静态导入x3dx3d">&#x3D;&#x3D;7.4.1 静态导入&#x3D;&#x3D;</span></h3><blockquote><p>有一种 import 语句允许导入静态方法和字段，而不只是类</p></blockquote><p>比如：</p><pre><code>import static java.lang.Math.*;</code></pre><p>这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。</p><pre><code>double n = pow(10, 5);// &lt;———— 本来是 double n = Math.pow(10, 5);double pi = PI;// &lt;———— 本来是 double pi = Math.PI;JAVA</code></pre><p><em><strong>—— 上述方法、字段见 [12.5 Math 类]</strong></em></p><h3><span id="x3dx3d742-jar-文件x3dx3d">&#x3D;&#x3D;7.4.2 JAR 文件&#x3D;&#x3D;</span></h3><blockquote><p>为了避免向用户提供包含大量类文件的复杂目录结构，可以将 Java 程序打包成 JAR （Java 归档）文件。</p><p>一个 JAR 文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。</p><p>JAR 文件是压缩的。其使用了 ZIP压缩格式。</p></blockquote><p><strong>创建 JAR：</strong></p><p>使用 jar 工具以制作 JAR 文件。该工具在 jdk&#x2F;bin 目录下</p><pre><code class="java">jar cvf 包名 文件名1 文件名2 ...</code></pre><p>关于 jar 工具的各种指令，还是自己去百度一下吧</p><h2><span id="75-继承">7.5 继承</span></h2><blockquote><p>继承：<u>能解决代码复用，让我们的编程更接近人类思维</u>。当多个类存在相同的 属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类&#x2F;超类）。在 父类 中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过 <code>extends</code> 来声明继承父类即可。</p><p>&#x3D;&#x3D;通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。&#x3D;&#x3D;</p></blockquote><pre><code class="java">public class Son extends Father &#123;&#125;;// Son 类继承了 Father 类</code></pre><p>定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object 类。</p><p>所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object 本身没有父类。</p><h3><span id="751-使用细节">7.5.1 使用细节</span></h3><ol><li>子类 继承了所有属性和方法，<u>但私有（<code>private</code>）的 属性·方法 不能在 子类 直接访问。要调用父类提供的 公共（<code>public</code>）等方法 访问。</u></li><li>&#x3D;&#x3D;子类 必须调用 父类 的 构造器，完成 父类 的 初始化。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;当创建 子类对象 时，<font color="red">不管使用 子类的哪个构造器，默认情况下总会调用 父类的无参构造器</font>。如果 父类 没有提供 无参构造器，则必须在 子类的构造器 中用 <code>super</code> 去指定使用 父类的哪个构造器 完成 对父类的初始化。否则编译不能通过。&#x3D;&#x3D;</li><li>如果希望指定调用 父类的某构造器，则显式地调用一下：<code>super(形参列表);</code></li><li><code>super</code> 在使用时，必须放在构造器第一行。</li><li>由于 <code>super</code> 与 <code>this</code> 都要求放在第一行，所以此两个方法不能同时存在于同一构造器。</li><li>Java 所有的类都是 <code>Object</code> 的子类。换言之，<code>Object</code> 是所有类的父类。</li><li>&#x3D;&#x3D;父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类 <code>Object</code>&#x3D;&#x3D;</li><li>子类 最多只能直接继承 一个 父类。即，Java 中是 单继承机制。</li><li>&#x3D;&#x3D;不能滥用继承。子类 和 父类 之间必须满足 is - a 的逻辑关系。&#x3D;&#x3D;</li></ol><blockquote><p>is-A继承关系：“表示类与类之间的继承关系、接口与接口之间的继承的关系以及类对接口实现的关系”。<br>has-A合成关系：“是关联关系的一种，是整体和部分（通常为一个私有的变量）之间的关系，并且代表的整体对象负责构建和销毁代表部分对象，代表部分的对象不能共享”</p><p>is_a是继承关系.<br>has_a是组合关系（描述一个类中有另一个类型的实例）</p></blockquote><h3><span id="x3dx3d752-继承的本质x3dx3d">&#x3D;&#x3D;7.5.2 继承的本质&#x3D;&#x3D;</span></h3><ul><li>内存布局：<ol><li>在 <strong>方法区</strong>，<u>自顶级父类起，依次加载 类信息。</u></li><li>在 堆 中开辟一个空间，自顶级父类起，依次创建并初始化各个类包含的所有属性信息。</li><li>在 栈 中存放该空间的 地址。</li></ol></li><li>如何查找信息？<ol><li>查看该子类是否有该属性。如果该子类有这个属性且可以访问，则返回信息。</li><li>子类没有该属性的场合，查看父类是否有该属性。如有且可访问，则返回信息。如不可访问，则报错。</li><li>父类也没有该属性的场合，继续查找上级父类，直到顶级父类（Object）。</li><li>如需调用某个特定类包含的特定信息，可以调用该类提供的方法。</li></ol></li></ul><h3><span id="x3dx3d753-super-关键字x3dx3d">&#x3D;&#x3D;7.5.3 <code>super</code> 关键字&#x3D;&#x3D;</span></h3><blockquote><p><code>super</code> 代表父类的引用。用于访问父类的 属性、方法、构造器。</p></blockquote><p><strong>super 的使用：</strong></p><ul><li><code>super.属性名</code>：访问父类的属性。<u>不能访问父类的私有（private）属性。</u></li><li><code>super.方法名(形参列表)</code>：访问父类的方法。<u>不能访问父类的私有（private）方法。</u></li><li><code>super(参数列表);</code>：访问父类的构造器。此时，super 语句必须放在第一句。</li></ul><p><strong>使用细节：</strong></p><ol><li>&#x3D;&#x3D;调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;子类中由和父类中成员（属性和方法）重名时，要调用父类成员必须用 <code>super</code>。没有重名的场合，<code>super</code>、<code>this</code> 及直接调用的效果相同。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<code>super</code> 的访问不限于直接父类。&#x3D;&#x3D;如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。</li></ol><h3><span id="754-方法重写-x2f-覆盖">7.5.4 方法重写 &#x2F; 覆盖</span></h3><blockquote><p>方法重写&#x2F;覆盖（Override）：如若子类有一个方法，和父类的某方法的 名称、返回类型、参数 一样，那么我们就说该子类方法 覆盖 了那个父类方法。</p></blockquote><p><strong>使用细节：</strong></p><ol><li>子类方法的参数，方法名称，要和父类方法完全一致。</li><li>&#x3D;&#x3D;子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。&#x3D;&#x3D;，向下兼容。</li><li>子类方法 <strong>不能缩小</strong> 父类方法的访问范围（访问修饰符）</li></ol><h3><span id="阻止继承final类-方法和域">阻止继承：final类、方法和域</span></h3><p>经过final修饰的类不可拓展，除了域，它的方法也为final的。</p><h2><span id="x3dx3d76-多态x3dx3d">&#x3D;&#x3D;7.6 多态&#x3D;&#x3D;</span></h2><blockquote><p>多态：方法 或 对象 有多种形态。多态 是面向对象的第三大特征，是建立在 封装 和 继承 的基础之上的</p></blockquote><h3><span id="x3dx3d761-多态的体现x3dx3d">&#x3D;&#x3D;7.6.1 多态的体现&#x3D;&#x3D;</span></h3><ol><li><p>方法的多态：重写 和 重载 体现了 方法的多态。</p></li><li><p><strong>对象的多态：</strong></p><ul><li><p>一个对象的 编译类型 和 运行类型 可以不一致。</p><p>  <code>Animal animal = new Dog();</code></p><p>  上例，编译类型是 <code>Animal</code>，运行类型是子类 <code>Dog</code>。要理解这句话，请回想 [[6.1.4 类与对象的内存访问机制]](<a href="https://i-melody.github.io/2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6">https://i-melody.github.io/2021/11/29/Java/入门阶段/6</a> 面向对象编程（基础）&#x2F;#6-1-4-类与对象的内存访问机制)：<code>animal</code> 是对象的<strong>引用</strong>。</p></li><li><p>编译类型在定义对象时就确定了，不能改变。</p></li><li><p>运行类型是可以变化的。</p><p>  上例中，再让 <code>animal = new Cat();</code>，这样，运行类型变为了 <code>Cat</code></p></li><li><p>编译类型看定义时 <code>=</code> 的左边，运行类型看 <code>=</code> 的右边。</p></li></ul></li></ol><h3><span id="x3dx3d762-使用细节x3dx3d">&#x3D;&#x3D;7.6.2 使用细节&#x3D;&#x3D;</span></h3><ol><li><p>&#x3D;&#x3D;多态的前提：两个对象 &#x2F; 类存在继承关系。&#x3D;&#x3D;</p></li><li><p>多态的向上转型：</p></li></ol><ul><li>本质：父类的引用指向了子类的对象。（如 [ 7.6.1.2 ]）</li><li>语法：<code>父类类型 引用名 = new 子类类型(参数列表);</code></li><li>编译类型看左边，运行类型看右边。</li><li>&#x3D;&#x3D;可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。&#x3D;&#x3D;</li><li>最终的运行结果要看子类的具体实现。即从子类起向上查找方法调用（与 [ 7.5.2 ] 规则相同）。</li></ul><blockquote><p>向上转型的好处：</p><ol><li><p>提高代码的灵活性：通过向上转型，可以将不同的子类对象转换为其父类对象，从而可以使用统一的接口来操作这些对象，减少了代码的复杂性和冗余性。</p></li><li><p>提高代码的扩展性：当需要增加新的子类对象时，只需要在父类对象的基础上进行扩展即可，而不需要对原有的代码进行重构，从而降低了代码的维护成本。</p></li><li><p>提高代码的可维护性：在向上转型的情况下<strong>，只需要关注父类对象的行为，而不需要关注子类对象的具体实现细节</strong>，从而提高了代码的可维护性。</p><p> 例如:</p><pre><code class="java">class A&#123;    public void play()&#123;...&#125;&#125;class B extend A&#123;    @Override    public void play()&#123;...&#125;&#125;class C extend A&#123;    @Override    public void play()&#123;...&#125;&#125;//如果我们想要调用某个类的paly方法，无需像这样实现：public void show(B b)&#123;    b.paly();&#125;public void show(C c)&#123;    c.paly();&#125;//而是这样：public void show(A a)&#123;    a.paly();&#125;</code></pre><p> <a href="https://juejin.cn/post/6993341672755036173">聊聊java的向上转型和向下转型</a></p><p> &#x3D;&#x3D;如果是访问成员变量，编译的话就是看父类，运行同样是看父类。&#x3D;&#x3D;<br> 如果访问的方法，编译就看父类，运行则看子类。<br> <u>如果是静态方法，编译和运行都是看父类。</u></p><p> 总结：只有方法才有多态的特性</p></li></ol></blockquote><ol start="3"><li>多态的向下转型：</li></ol><ul><li><p>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></p><p>  [7.6.2.2] 的例子里，向下转型。这个语法其实和 [2.8.2 强制类型转换] 很像。</p><p>  <code>Dog dog = (Dog)animal;</code></p></li><li><p>只能强转父类的引用，不能强转父类的对象。只有引用子类对象的父类引用才能被向下转型为子类对象。</p><p>  也就是说，&#x3D;&#x3D;向下转型之前，必须先向上转型。&#x3D;&#x3D;</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象。即上例中的 <code>animal</code> 运行类型需是 <code>Dog</code></p></li><li><p>&#x3D;&#x3D;向下转型后，可以调用子类类型中的所有成员。&#x3D;&#x3D;</p></li></ul><ol start="4"><li><p>&#x3D;&#x3D;属性没有重写一说。<strong>和 方法 不同，属性的值 看编译类型。</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<code>instanceof</code> 比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是 <strong>运行类型</strong>。&#x3D;&#x3D;</p><pre><code class="java">//向下转型的时候比较常见,可以防止意外的类型转换异常。A a = new B();if(B instanceof A)&#123;    B b = (B)a;&#125;</code></pre></li></ol><h3><span id="x3dx3d763-理解方法调用x3dx3d">&#x3D;&#x3D;7.6.3 理解方法调用&#x3D;&#x3D;</span></h3><p>在对象上调用方法的过程如下：</p><ol><li><p>编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举。</p><p> 至此，编译器已经知道所有可能被调用的方法。</p></li><li><p>编译器确认方法调用中提供的参数类型。</p><p> 那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。</p><p> &#x3D;&#x3D;没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错&#x3D;&#x3D;</p><p> 至此，编译器已经知道要调用方法的名字和参数类型</p></li><li><p>如若是 private 方法、static 方法、final 方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为 <strong>静态绑定</strong></p><p> 与之相对的，&#x3D;&#x3D;如果调用方法依赖于隐式参数类型，那么必须在运行时 <strong>动态绑定</strong>&#x3D;&#x3D;</p></li><li><p>程序运行并采取动态绑定方法时，JVM 将调用那个 <strong>实际类型</strong> 对应的方法。</p></li></ol><p>倘若每次调用方法都进行以上搜索，会造成庞大的时间开销。为此，JVM 预先为每个类计算了 <strong>方法表</strong>。</p><p>方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可。</p><p>特别地，使用 super 关键字时，JVM 会查找其父类的方法表。</p><p><strong>&#x3D;&#x3D;动态绑定机制&#x3D;&#x3D;：</strong></p><blockquote><p>在运行时能够自动选择调用的方法的现象称为动态绑定</p></blockquote><ul><li>当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址&#x2F;运行类型绑定。</li><li>当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用。</li></ul><h2><span id="77-object-类">7.7 Object 类</span></h2><blockquote><p>Object 类是所有类的超类。Java 中所有类默认继承该类。</p></blockquote><h3><span id="x3dx3dequals-方法x3dx3d">&#x3D;&#x3D;equals 方法&#x3D;&#x3D;</span></h3><pre><code class="java">boolean equals(Object obj)</code></pre><p><u>用于检测一个对象是否等于另一对象</u>。</p><p>在 Object 中，该方法的实现是比较 形参 与 隐式参数 的对象引用是否一致。</p><p><strong>与 <code>==</code> 的区别：</strong></p><ul><li><p><code>==</code>：既可以判断基本类型，也可以判断引用类型。如果判断基本类型，判断的是值是否相等。如果判断引用类型，判断的是地址是否相等。</p></li><li><p>equals 方法：&#x3D;&#x3D;是 Object 中的方法，只能判断引用类型。这个场合下，和<code>==</code>一样&#x3D;&#x3D;，默认判断地址是否相等，但子类中往往重写该代码，以判断内容是否相等。</p><p>  &#x3D;&#x3D;在子类中定义 equals 方法时，首先调用超类的 equals 方法。那个一致时，再比较子类中的字段。&#x3D;&#x3D;</p></li></ul><p><strong>Java 语言规范要求 equals 方法具有如下特性：</strong></p><ul><li><p><em>自反性</em>：对于任何非空引用 x，<code>x.equals(x)</code> 应返回 true</p></li><li><p><em>对称性</em>：对于任何引用 x 和 y，当且仅当 <code>x.equals(y)</code> 为 true 时，<code>y.equals(x)</code> 为 true</p><p>  &#x3D;&#x3D;如果所有的子类具有相同的相等性语义（判断相等的条件具有泛用性），可以使用 <code>instanceof</code> 检测其类型。否则，最好使用 <code>getClass</code> 方法比较类型。&#x3D;&#x3D;</p></li><li><p><em>传递性</em>：对于任何引用 x、y、z，如果 <code>x.equals(y)</code> 为 true ，<code>y.equals(z)</code> 为 true，那么 <code>x.equals(z)</code> 也应该为 true</p></li><li><p><em>一致性</em>：如果 x 和 y 的引用没有发生变化，反复调用 <code>x.equals(y)</code> 应该返回相同的结果</p></li><li><p>对于任何非空引用 x，<code>x.equals(null)</code> 应该返回 false</p></li></ul><h3><span id="x3dx3dhashcode-方法x3dx3d">&#x3D;&#x3D;hashCode 方法&#x3D;&#x3D;</span></h3><pre><code class="java">int hashCode()</code></pre><p>返回对象的 散列码值。</p><p>散列码值是由对象导出的一个整型值。散列码是无规律的。如果 x 与 y 是不同对象，两者的散列码基本上不会相同。</p><p><u><strong>字符串</strong>的散列码是由其内容导出的，而<strong>其他引用对象</strong>的散列码是根据存储地址得出的。</u></p><p><strong>散列码的作用：</strong></p><ol><li>提高哈希结构的容器的效率。</li><li>&#x3D;&#x3D;两个引用，若是指向同一对象，则哈希值一般不同。&#x3D;&#x3D;</li><li><u>哈希值是根据地址生成的，因而，哈希值不能等同于地址</u></li></ol><p><strong>相关方法：</strong></p><ul><li><p><code>Objects.hashCode(Object obj)</code></p><p>  这是一个 null 安全的返回散列值的方法。传入 null 时会返回 0</p></li><li><p>&#x3D;&#x3D;<code>Objects.hash(Object... values)</code>&#x3D;&#x3D;</p><p>  组合所有传入参数的散列值</p></li><li><p><code>Integer.hashCode(int value)</code></p><p>  返回给定基本数据类型的散列值。所有包装类都有该静态方法</p></li><li><p><code>Arrays.hashCode(xxx[] a)</code></p><p>  计算数组的散列码。数组类型可以是 Object 或基本数据类型</p></li></ul><p>空对象调用 hashCode 方法会抛出异常。</p><p>&#x3D;&#x3D;hashCode 与 equals 的定义必须相符。如果 <code>x.equals(y)</code> 返回 true，那么 <code>x.hashCode()</code> 与 <code>y.hashCode()</code> 应该返回相同的值。&#x3D;&#x3D;</p><h3><span id="x3dx3dtostring-方法x3dx3d">&#x3D;&#x3D;toString 方法&#x3D;&#x3D;</span></h3><pre><code class="java">String toString()</code></pre><p>返回表示对象的一个字符串。Object 的默认实现如下</p><pre><code class="java">public String toString() &#123;    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;</code></pre><ul><li><p><code>Class getClass()</code></p><p>  返回包含对象信息的 Class 对象。</p></li><li><p><code>String getName()</code></p><p>  由 Class 类实例调用。返回这个类的全类名</p><p>  全类名：即包名 + 类名。比如 <code>com.prictice.codes.Person</code></p></li><li><p><code>Class getSuperClass()</code></p><p>  由 Class 类实例调用。以 Class 形式返回其父类</p><p>  Object 使用时返回 null</p></li><li><p><code>Integer.toHexString(int val)</code></p><p>  返回一个数字的十六进制表示的字符串</p></li></ul><p>toString 方法非常实用。Java 标准类库中的很多类重写了该方法，以便用户能获得一些有关对象状态的信息。</p><p>&#x3D;&#x3D;打印对象 或 使用 <code>+</code>操作符拼接对象 时，都会自动调用该对象的 toString 方法。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;当直接调用对象时，也会默认调用该方法。&#x3D;&#x3D;</p><h3><span id="finalize-方法">finalize 方法</span></h3><ol><li>当对象被回收时，系统会自动调用该对象的 <code>finalize</code> 方法。子类可以重写该方法，做一些释放资源的操作。</li><li>何时被回收：当某对象没有任何引用时，JVM 就认为该对象是一个垃圾对象，就会（在算法决定的某个时刻）使用垃圾回收机制来销毁该对象。在销毁该对象前，会调用 <code>finalize</code> 方法。</li><li>垃圾回收机制的调用，是由系统决定。也可以通过 <code>System.gc();</code> 主动触发垃圾回收机制。这个方法一经调用就会继续执行余下代码，而不会等待回收完毕。</li><li>实际开发中，几乎不会运用该方法。</li></ol><h2><span id="78-断点调试debug">7.8 断点调试（Debug）</span></h2><blockquote><p>断点调试：在程序某一行设置一个断点，调试时，代码运行至此就会停住，然后可以一步一步往下调试。调试过程中可以看各个变量当前的值。如若出错，则测试到该出错代码行即显示错误并停下。进行分析从而找到这个 Bug。</p><p>调试过程中是运行状态，所以，是以对象的 运行类型 执行。</p><p>断点调试是程序员必须掌握的技能，能帮助我们查看 Java 底层源代码的执行过程，提高程序员 Java 水平。</p></blockquote><p>快捷键如下</p><ul><li>跳入：<code>F7</code></li><li>跳过：<code>F8</code></li><li>跳出：<code>shift + F8</code></li><li>resume，执行到下一个断点：<code>F9</code></li></ul><h2><span id="附录">附录</span></h2><h3><span id="零钱通程序">零钱通程序</span></h3><ul><li><p><strong>Wallet.java</strong></p><pre><code class="java">package com.the_wallet;public class Wallet &#123;    public static void main(String[] args) &#123;        Data p1 = new Data(&quot;Melody&quot;);        p1.menu();        System.out.println(&quot;再见~&quot;);    &#125;&#125;</code></pre></li><li><p>Data.java</p></li></ul><pre><code class="java">package com.the_wallet;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;public class Data &#123;    private String name = &quot;user&quot;;    private double balance = 0;    private String[][] detail = new String[1][5];    private Data() &#123;        detail[0][0] = &quot;项目\t&quot;;        detail[0][1] = &quot;\t\t&quot;;        detail[0][2] = &quot;时间&quot;;        detail[0][3] = &quot; &quot;;        detail[0][4] = &quot; &quot;;    &#125;    public Data(String name) &#123;        this();        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void menu() &#123;        char inp = &#39;a&#39;;        double inpD;        Scanner scanner = new Scanner(System.in);        while (inp != &#39;y&#39; &amp;&amp; inp != &#39;Y&#39;) &#123;            System.out.print(&quot;\n===============零钱通菜单===============&quot;                    + &quot;\n\t\t\t1.零钱通明细&quot;                    + &quot;\n\t\t\t2.收益入帐&quot;                    + &quot;\n\t\t\t3.消费入账&quot;                    + &quot;\n\t\t\t4.退   出&quot;                    + &quot;\n请选择（1-4）：&quot;);            inp = scanner.next().charAt(0);            System.out.println(&quot;======================================&quot;);            switch (inp) &#123;                case &#39;4&#39;:                    System.out.println(&quot;确定要退出吗？（y/n）：&quot;);                    inp = scanner.next().charAt(0);                    while (inp != &#39;y&#39; &amp;&amp; inp != &#39;n&#39; &amp;&amp; inp != &#39;Y&#39; &amp;&amp; inp != &#39;N&#39;) &#123;                        System.out.println(&quot;请输入“y”或者“n”！听话！&quot;);                        inp = scanner.next().charAt(0);                    &#125;                    break;                case &#39;1&#39;:                    showDetail();                    break;                case &#39;2&#39;:                    System.out.println(&quot;请输入收益数额：&quot;);                    inpD = scanner.nextDouble();                    if (inpD &lt;= 0) &#123;                        System.out.print(&quot;收益需要为正，记录消费请选择“消费入账”&quot;);                        break;                    &#125;                    earning(inpD);                    break;                case &#39;3&#39;:                    System.out.println(&quot;请输入支出数额：&quot;);                    inpD = scanner.nextDouble();                    if (inpD &lt; 0) &#123;                        inpD = -inpD;                    &#125;                    if (balance &lt; inpD) &#123;                        System.out.println(&quot;您的余额不足！&quot;);                        break;                    &#125;                    System.out.println(&quot;请输入支出项目：&quot;);                    spending(inpD, scanner.next());                    break;                case &#39;g&#39;:                    break;                default:                    System.out.print(&quot;错误。请输入数字（1-4）&quot;);            &#125;        &#125;    &#125;    private void earning(double earn) &#123;        String[][] temp = new String[this.detail.length + 1][5];        record(detail, temp);        this.balance += earn;        tidy(&quot;收益入账&quot;, earn, true, temp);        showDetail();        System.out.println(&quot;\n收益记录完成&quot;);    &#125;    private void spending(double spend, String title) &#123;        String[][] temp = new String[this.detail.length + 1][5];        record(detail, temp);        this.balance -= spend;        tidy(title, spend, false, temp);        showDetail();        System.out.println(&quot;\n消费记录完成&quot;);    &#125;    private void record(String[][] detail, String[][] temp) &#123;        for (int i = 0; i &lt; detail.length; i++) &#123;            for (int j = 0; j &lt; 5; j++) &#123;                temp[i][j] = detail[i][j];            &#125;        &#125;    &#125;    private void tidy(String title, double num, boolean isPos, String[][] temp) &#123;        Date date = new Date();        SimpleDateFormat sDate = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        if (title.length() &lt;= 2) &#123;            temp[temp.length - 1][0] = title + &quot;\t\t&quot;;        &#125; else &#123;            temp[temp.length - 1][0] = title + &quot;\t&quot;;        &#125;        String sign = isPos ? &quot;+&quot; : &quot;-&quot;;        temp[temp.length - 1][1] = sign + num + &quot;&quot;;        temp[temp.length - 1][2] = sDate.format(date);        temp[temp.length - 1][3] = &quot;余额：&quot;;        temp[temp.length - 1][4] = balance + &quot;&quot;;        detail = temp;    &#125;    private void showDetail() &#123;        System.out.println(&quot;--------------------------------------&quot;);        for (int i = 0; i &lt; detail.length; i++) &#123;            System.out.println(detail[i][0] + detail[i][1] + &quot;\t&quot; + detail[i][2] + &quot;\t\t&quot; + detail[i][3] + detail[i][4]);        &#125;        System.out.println(&quot;--------------------------------------&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1 类变量和类方法</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E9%AB%98%E7%BA%A7)/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/9%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E9%AB%98%E7%BA%A7)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="91-类变量和类方法">9.1 类变量和类方法</span></h2><h3><span id="911-类变量">9.1.1 类变量</span></h3><blockquote><p>类变量：也叫 静态变量&#x2F;静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。</p><p>语法（推荐）：<code>访问修饰符 static 数据类型 变量名;</code></p><p>或者也可以：<code>static 访问修饰符 数据类型 变量名;</code></p><p>&#x3D;&#x3D;根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中。&#x3D;&#x3D;</p></blockquote><ol><li><p>什么时候需要用类变量：</p><p> 当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p></li><li><p>类变量 与 实例变量（普通属性）的区别：</p><p> 类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的</p></li><li><p>加上 <code>static</code> 称为 类变量 或 静态变量。否则称为 实例变量&#x2F;普通变量&#x2F;非静态变量</p></li><li><p>静态变量 可以通过 <code>类名.类变量名;</code> 或 <code>对象名.类变量名;</code> 来访问。但 Java 设计者推荐我们用 <code>类名.类变量名;</code> 来访问。（需满足访问权限和范围）</p></li><li><p>&#x3D;&#x3D;类变量 是在加载类时就初始化了。&#x3D;&#x3D;所以，没有创建对象实例也能访问。</p></li><li><p>&#x3D;&#x3D;类变量 的生命周期是随着 类的加载 开始，随着 类的消亡 而销毁。&#x3D;&#x3D;</p></li><li><p>特别地：**<font color="red">一个 null 对象也可以访问静态变量 &#x2F; 静态方法</font>**</p><pre><code class="java">public class Test&#123;    static int n = 0;    static void met() &#123;        System.out.println(++n);    &#125;        public static void main(String[] args)&#123;        Test t = null;        System.out.println(t.n);//这样不会报错        t.met();//这样也不会报错    &#125;&#125;</code></pre></li></ol><h3><span id="912-类方法">9.1.2 类方法</span></h3><blockquote><p>当方法使用 <code>static</code> 修饰后，就是 静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。</p></blockquote><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在 方法区。</li><li>类方法中不允许使用和对象有关的关键字。所以，类方法没有 <code>this</code> 或 <code>super</code></li><li>类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。</li><li>&#x3D;&#x3D;类方法 中只能访问 类变量 或 类方法&#x3D;&#x3D;</li><li>&#x3D;&#x3D;普通方法既可以访问普通方法也可以访问类方法&#x3D;&#x3D;</li></ol><h2><span id="92-理解-main-方法语法">9.2 理解 <code>main</code> 方法语法</span></h2><blockquote><pre><code class="java">public static void main(String[] args)&#123;...&#125;</code></pre></blockquote><ol><li><p><code>main</code> 方法 <strong>是 JVM 调用的方法</strong>。所以该方法的 访问权限 必须为 <code>public</code></p></li><li><p><strong>JVM 在执行 <code>main</code> 方法时不必创建对象，所以 <code>main</code>方法 必须为 <code>static</code></strong></p></li><li><p>&#x3D;&#x3D;该方法接收 <code>String</code> 类型的数组参数。该数组中保存执行 Java 命令 时传递给所运行的类的参数。&#x3D;&#x3D;</p><blockquote><p>工作台中：<code>javac 执行的程序.java</code></p><p> <code>java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) ..</code></p><p><a href="https://www.bilibili.com/video/BV1fh411y7R8?p=385&t=129.5">IDEA中怎么做？</a></p></blockquote></li><li><p>在 <code>main</code> 方法 中，我们可以直接调用 <code>main</code> 方法 所在类的静态方法或静态属性。</p><p> 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员。</p><pre><code class="java">例如：public class Hello&#123;    private String str = &quot;hello&quot;;    public static void main(String args[])&#123;        //System.out.println(str);//这样做是错的，静态方法不能访问静态域        //1.创建此属性的一个实例        Hello hello =  new Hello();        System.out.println(hello.str);//这样间接访问了str&#125;&#125;</code></pre></li></ol><h2><span id="x3dx3d93-代码块x3dx3d">&#x3D;&#x3D;9.3 代码块&#x3D;&#x3D;</span></h2><blockquote><p>代码块：又称为 初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过 <code>&#123; &#125;</code> 包围起来。</p><p>和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类 显式调用，而是&#x3D;&#x3D;加载类时，或创建对象时 隐式调用。&#x3D;&#x3D;</p><p>语法：<code>[修饰符]&#123;代码&#125;;</code></p></blockquote><ol><li>修饰符 是可选项，可不写。要写的话，只能写 <code>static</code></li><li>代码块分为两类：<ul><li>静态代码块：有 <code>static</code></li><li>普通代码块：无 <code>static</code></li></ul></li><li>逻辑语句可以为任意的逻辑语句。</li><li><code>;</code> 可以写，也可以省略。建议写上。</li><li>&#x3D;&#x3D;代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作&#x3D;&#x3D;</li><li>&#x3D;&#x3D;如果多个构造器中都有重复语句，就可以抽取到初始化块中，<strong>提高代码复用率。</strong>这样，不管用哪个构造器，都会执行代码块。&#x3D;&#x3D;</li></ol><h3><span id="931-使用细节">9.3.1 使用细节</span></h3><ol><li><code>static</code> 代码块：作用是对类进行初始化。**<font color="red">随着 类的加载 会且只会执行一次</font><strong>。相对的：</strong>普通代码块每创建一个对象就执行一次。**</li></ol><ul><li><p>**类什么时候被加载？ **</p><ul><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会加载</li><li>使用类的静态成员时（父类也会加载）</li></ul><p>  以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。</p></li></ul><ol><li><p>创建一个对象时，在 <strong>一个类里</strong> 调用顺序是：</p><ul><li>调用静态代码块 和 静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。</li><li>调用普通代码块 和 普通属性初始化。这两者优先级也相同。</li><li>调用构造器。</li></ul></li><li><p>&#x3D;&#x3D;<code>构造器</code> 的最前面其实隐含了 <code>super();</code> 和 <code>调用普通代码块</code>。&#x3D;&#x3D;而静态相关的代码块，属性初始化，在类加载时就执行完毕了。</p><p> 这样，创建一个对象时，在 <strong>有继承关系的多个类里</strong> 调用顺序是：</p><ul><li>父类 静态代码块 和 静态初始化</li><li>子类 静态代码块 和 静态初始化</li><li>父类 普通代码块 和 普通初始化</li><li>父类 构造器</li><li>子类 普通代码块 和 普通初始化</li><li>子类 构造器</li></ul></li><li><p>静态代码块 只能调用 静态成员。普通代码块 能调用 任意成员。</p></li></ol><h2><span id="x3dx3d94-单例设计模式x3dx3d">&#x3D;&#x3D;9.4 单例设计模式&#x3D;&#x3D;</span></h2><blockquote><p>什么是设计模式：设计模式是在大量的实践中总结和理论化后优选的代码结构、编程风格、解决问题的思考方式。设计模式就像是经典的棋谱，免去我们自己再思考和摸索。</p></blockquote><p>单例设计模式：采取一定的方法，保证再整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p><h3><span id="941-应用实例">9.4.1 应用实例</span></h3><blockquote><p>后面会学更多，这里先展示两种：饿汉式、懒汉式</p></blockquote><h4><span id="9411-饿汉式">#9.4.1.1 饿汉式</span></h4><p>步骤如下：</p><ol><li><p>构造器私有化（防止用户直接 new）</p></li><li><p>类的内部创建对象</p></li><li><p>向外暴露一个静态的公共方法</p></li><li><p>代码实现</p><blockquote><pre><code class="java">class GF&#123;       private String name;    private static GF gf = new GF(&quot;萝茵&quot;);       private GF(String name)&#123;           this.name = name;       &#125;       public static GF getGF()&#123;           return gf;       &#125; &#125;</code></pre><p>对象，通常都是重量级的对象</p><p>有时，我们用不到这个创建的对象，那个场合，会造成资源浪费。</p></blockquote></li></ol><h4><span id="9412-懒汉式">#9.4.1.2 懒汉式</span></h4><p>步骤如下：</p><ol><li><p>构造器私有化</p></li><li><p>定义一个静态属性对象</p></li><li><p>提供一个静态的公共方法，可以返回对象。如果静态对象为空，则创建对象</p></li><li><p>代码实现</p><blockquote><pre><code class="java">  &gt;class GF&#123;   private String name;private static GF gf;   private GF(String name)&#123;       this.name = name;   &#125;   public static GF getGF()&#123;       if(gf == null)&#123;           gf = new GF(&quot;萝茵&quot;);       &#125;       return gf;   &#125;   &gt;&#125;</code></pre></blockquote></li></ol><h4><span id="9413-两种方法对比">#9.4.1.3 两种方法对比</span></h4><ol><li>二者创建对象的时机不同。饿汉式在加载类信息时创建，懒汉式在使用时才创建</li><li>&#x3D;&#x3D;饿汉式可能造成资源浪费，懒汉式可能存在线程安全问题（学习[线程]后会进行完善）。&#x3D;&#x3D;</li><li>Java SE 标准类中 java.lang.Runtime 就是一个单例模式。</li></ol><h2><span id="x3dx3d95-final-关键字x3dx3d">&#x3D;&#x3D;9.5 <code>final</code> 关键字&#x3D;&#x3D;</span></h2><blockquote><p><code>final</code> 可以修饰 类、属性、方法、局部变量</p><p>以下情况下，可能用到 <code>final</code></p><ol><li><code>final</code> 修饰类：该类不能被继承</li><li><code>final</code> 修饰方法：该方法不能被重写</li><li><code>final</code> 修饰值：该值不能被修改</li></ol></blockquote><h3><span id="951-使用细节">9.5.1 使用细节</span></h3><ol><li><p><code>final</code> 修饰的属性又叫常量，一般用 XX_XX_XX 来命名（全大写字母+下划线）</p></li><li><p>&#x3D;&#x3D;<code>final</code> 修饰的属性在定义时，<strong>必须赋初始值</strong>，且之后不能再修改。&#x3D;&#x3D;赋值可以在下列位置之一：</p><ul><li>定义时</li><li>构造器中</li><li>代码块中</li></ul><p> 注意：如果 <code>final</code> 修饰的属性是静态的，则只能在以下位置赋值。</p><ul><li>定义时</li><li>静态代码块中</li></ul></li><li><p><code>final</code> 类不能继承，但能实例化对象。对的，是可以的。</p></li><li><p>&#x3D;&#x3D;如果不是 <code>final</code> 类，但含有 <code>final</code> 方法，虽然该方法不能重写，但能被继承。&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<code>final</code> 类可以有 <code>final</code> 方法。可以，但没必要&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<code>final</code> 不能修饰构造方法。&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<code>final</code> 和 <code>static</code> 搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 <code>static</code> 在前）。底层编译器做了优化处理。这样做，调用 <strong>属性（定义时赋值）</strong> 时居然 <strong>不会造成类的加载！</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;包装类（Integer、Double、Float、Boolean、String等）都是 <code>final</code> 类，都不能被继承。&#x3D;&#x3D;</p></li></ol><h2><span id="x3dx3d96-抽象类x3dx3d">&#x3D;&#x3D;9.6 抽象类&#x3D;&#x3D;</span></h2><blockquote><p>当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。那个场合，要将该类声明为 <code>abstract</code> 类。</p><p>&#x3D;&#x3D;抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。&#x3D;&#x3D;</p></blockquote><blockquote><p>定义抽象类：<code>访问修饰符 abstract 类名&#123;...&#125;</code></p><p>定义抽象方法（注意：无方法体<code>&#123;&#125;</code>）：<code>访问修饰符 abstract 返回值 方法名(形参列表);</code></p></blockquote><h3><span id="961-使用细节">9.6.1 使用细节</span></h3><ol><li>抽象类<u>不能被实例化</u></li><li><strong>抽象类不一定包含抽象方法。</strong>也就是说，抽象类可以没有 <code>abstract</code>方法</li><li><strong>一旦包含 <code>abstract</code> 方法，则该类一定要声明为 <code>abstract</code></strong>,&#x3D;&#x3D;一个抽象类包含一个或多个抽象方法，并不是全部都是抽象方法&#x3D;&#x3D;</li><li><strong><code>abstract</code> 只能修饰 类 和 方法</strong>，不能修饰其他。</li><li>&#x3D;&#x3D;抽象类可以有任意成员（非抽象方法、构造器、静态属性等）&#x3D;&#x3D;。即，抽象类本质还是类。</li><li>抽象方法不能有主体。即，抽象方法不能实现。</li><li>&#x3D;&#x3D;如果一个类继承了 <code>abstract</code> 类，则其必须实现所有 <code>abstract</code> 方法，除非其自己也是 <code>abstract</code> 类。&#x3D;&#x3D;</li><li><strong>抽象方法不能用 <code>private</code> <code>final</code> <code>static</code> 来修饰。</strong>因为，这些关键词都和 重写 相违背。</li></ol><h3><span id="x3dx3d962-抽象类最佳实践-模板设计模式x3dx3d">&#x3D;&#x3D;9.6.2 抽象类最佳实践-模板设计模式&#x3D;&#x3D;</span></h3><blockquote><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p></blockquote><p>模板设计模式能解决的问题：</p><ol><li>当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li><li>编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。</li></ol><p><strong>最佳实践</strong></p><ol><li>有多个类，完成不同的任务job</li><li>要求统计得到各自完成任务的时间</li><li>实现TestTemple.java</li></ol><pre><code class="java">package com.hspedu.abstract_;abstract public class Template &#123; //抽象类-模板设计模式    public abstract void job();//抽象方法    public void calculateTime() &#123;//实现方法，调用job方法        //得到开始的时间        long start = System.currentTimeMillis();        job(); //动态绑定机制，调用的是运行类型的job方法(是谁就用谁的)        //得的结束的时间        long end = System.currentTimeMillis();        System.out.println(&quot;任务执行时间 &quot; + (end - start));    &#125;&#125;</code></pre><pre><code class="java">package com.hspedu.abstract_;public class AA extends Template &#123;    //计算任务    //1+....+ 800000    @Override    public void job() &#123; //实现Template的抽象方法job        long num = 0;        for (long i = 1; i &lt;= 800000; i++) &#123;            num += i;        &#125;    &#125;//    public void job2() &#123;//        //得到开始的时间//        long start = System.currentTimeMillis();//        long num = 0;//        for (long i = 1; i &lt;= 200000; i++) &#123;//            num += i;//        &#125;//        //得的结束的时间//        long end = System.currentTimeMillis();//        System.out.println(&quot;AA 执行时间 &quot; + (end - start));//    &#125;&#125;</code></pre><pre><code class="java">package com.hspedu.abstract_;public class BB extends Template&#123;    public void job() &#123;//这里也去，重写了Template的job方法        long num = 0;        for (long i = 1; i &lt;= 80000; i++) &#123;            num *= i;        &#125;    &#125;&#125;</code></pre><pre><code class="java">package com.hspedu.abstract_;public class TestTemplate &#123;    public static void main(String[] args) &#123;        AA aa = new AA();        aa.calculateTime(); //这里还是需要有良好的OOP基础，对多态        BB bb = new BB();        bb.calculateTime();    &#125;&#125;</code></pre><h2><span id="97-接口">9.7 接口</span></h2><blockquote><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。</p><p>语法：<code>interface 接口名&#123;...&#125;</code></p><pre><code>class 类名 implements 接口名&#123;...必须实现接口的抽象方法...&#125;</code></pre><p>注意：JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0 后，接口可以有静态（<code>static</code>）方法、默认（<code>default</code>）方法。</p><p>在接口中，抽象方法可以省略 <code>abstract</code></p></blockquote><p>接口中可以存在：</p><ul><li>属性（只有静态 <code>static</code> 属性，可以不加 <code>static</code> 关键字）</li><li>方法（抽象 <code>abstract</code> 方法、默认 <code>default</code> 实现方法、静态 <code>static</code> 方法）</li></ul><h3><span id="971-使用细节">9.7.1 使用细节</span></h3><ol><li>接口 不能被实例化。</li><li><strong>接口中所有方法都是 <code>public</code> 方法。</strong>接口中的 抽象方法 可以不用 <code>abstract</code> 修饰。</li><li>一个普通类实现接口，就必须把该接口所有方法都实现。（快捷键<code>alt + enter</code>）</li><li><strong>抽象类实现接口，可以不用实现接口的方法。</strong></li><li>一个类可以同时实现多个接口。<code>class Name implements In1,In2&#123;...&#125;</code></li><li>&#x3D;&#x3D;接口中的属性只能是 <code>final</code> 的，并且是 <code>public static final</code> 修饰符。修饰符就算不写，还是这样。&#x3D;&#x3D;</li><li>接口中属性的访问形式：<code>接口名.属性名</code></li><li>接口不能 <strong>继承</strong> 其他的类，但可以 <strong>继承</strong> 多个别的接口。（不是也不能 实现 别的接口）</li><li>&#x3D;&#x3D;接口的修饰符<strong>只能是 <code>public</code> 和 默认</strong>。这点和类的修饰符相同。&#x3D;&#x3D;</li></ol><h3><span id="972-实现接口-vs-继承类">9.7.2 实现接口 vs 继承类</span></h3><ol><li>当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。</li><li>可以认为，接口 是对于 Java 单继承机制的补充。</li><li>继承的价值主要在于：解决代码的复用性和可维护性。</li><li>接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。</li><li>接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足 like - a 关系。</li><li>&#x3D;&#x3D;接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）&#x3D;&#x3D;</li></ol><h3><span id="973-接口的多态特性">9.7.3 接口的多态特性</span></h3><ol><li><p>多态参数（接口的引用可以指向实现了接口的类的对象）</p><blockquote><p><code>viod work(Inerface01 i1)&#123;...&#125;</code> 参数可以传入任意实现该接口的类。</p></blockquote></li><li><p>多态数组</p></li><li><p>接口存在多态传递现象</p><blockquote><p>&#x3D;&#x3D;如果有A、B两个接口，B继承了A接口，而C类实现了B接口，那么等同于间接也实现了A接口。&#x3D;&#x3D;</p><p>这样c类的实例也可以赋给A类的接口。</p></blockquote></li></ol><h2><span id="98-内部类">9.8 内部类</span></h2><blockquote><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。</p><pre><code class="java">class Outer&#123;//外部类    class Inner&#123;//内部类    &#125;&#125;class Other&#123;//外部其他类&#125;</code></pre><p>内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p></blockquote><h3><span id="981-四种内部类">9.8.1 四种内部类</span></h3><p>分别是：</p><ul><li>定义在外部类的局部位置上<ul><li>局部内部类：有 类名</li><li><strong>匿名内部类：无 类名</strong></li></ul></li><li>定义在外部类的成员位置上<ul><li>成员内部类：无 <code>static</code> 修饰</li><li>静态内部类： <code>static</code> 修饰的类</li></ul></li></ul><h3><span id="982-局部内部类">9.8.2 局部内部类</span></h3><blockquote><p>局部内部类：定义在外部类的局部位置上，并且有类名。（局部位置？比如：方法&#x2F;代码块里）</p><pre><code class="java">class Outer &#123;//外部类    public void tools01() &#123;        class Inner &#123;//局部内部类        &#125;    &#125;&#125;</code></pre></blockquote><h4><span id="9821-使用细节">#9.8.2.1 使用细节</span></h4><ol><li><p>定义在外部类的局部位置上，并且有类名。</p></li><li><p>&#x3D;&#x3D;可以访问外部类的所有成员，<strong>包含私有成员</strong>&#x3D;&#x3D;</p></li><li><p>局部内部类可以 直接访问 外部类的成员。</p></li><li><p>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></p></li><li><p>&#x3D;&#x3D;作用域 仅仅在定义它的方法或代码块中&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;外部类 在方法中，可以创建 局部内部类 的对象实例，然后调用方法。&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;外部其他类 不能访问 局部内部类&#x3D;&#x3D;</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></p><p> <code>外部类名.this</code> 本质就是 外部类的对象。即，调用了该方法（上例的 <code>tools01</code> ）的对象</p><p> 还不懂的话，看一下 <a href="https://www.bilibili.com/video/BV1fh411y7R8?p=415&t=289.9">这个视频</a> 悟一悟</p></li></ol><h3><span id="x3dx3d983-匿名内部类x3dx3d">&#x3D;&#x3D;9.8.3 匿名内部类&#x3D;&#x3D;</span></h3><blockquote><p>匿名内部类：定义在外部类的局部位置，且没有类名</p><pre><code class="java">&gt;new 类/接口 (参数列表) &#123;   类体&gt;&#125;</code></pre><p>匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。</p><p>可以用匿名内部类简化开发</p></blockquote><blockquote><p>一个例子</p><pre><code class="java">&gt;class Outer &#123;//外部类   public void tools01() &#123;       Inter whatEver = new Inter()&#123;//匿名内部类                   &#125;;   &#125;&gt;&#125;&gt;interface Inter&#123;&gt;&#125;</code></pre><p>其实，这个匿名内部类 <code>new Inter()&#123;&#125;</code> 的运行类型就是 <code>class XXXX implements Inter</code>。系统自动分配的名字是 <code>Outer$1</code>（<code>whatEver.getClass = &quot;Outer$1&quot;</code>）</p><p>JDK 在创建匿名内部类 <code>Outer$1</code> 时，立即创建了一个对象实例，并将地址返回给了 <code>whatEver</code></p><p>匿名内部类使用一次后就不能再次使用（<code>Outer$1</code> 就这一个了）</p></blockquote><h4><span id="9831-使用细节">#9.8.3.1 使用细节</span></h4><ol><li>匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有 定义类的特征，也有 创建对象的特征。</li><li>可以访问外部类的所有成员，包括私有的。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></li><li>作用域：仅仅在定义它的方法或方法快中</li><li>外部其他类 不能访问 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h4><span id="9832-使用场景">#9.8.3.2 使用场景</span></h4><ol><li><p>当作实参直接传递，简洁高效</p><blockquote><pre><code class="java">public class Homework1 &#123;    public static void main(String[] args) &#123;        new Cellphone().clock(new Bell() &#123;//看这里看这里            @Override            public void belling() &#123;                System.out.println(&quot;小懒猪起床了！&quot;);            &#125;        &#125;);    &#125;&#125;interface Bell &#123;    void ringing();&#125;class Cellphone&#123;    public void clock(Bell bell)&#123;        bell.ringing();    &#125;&#125;</code></pre></blockquote></li></ol><h3><span id="984-成员内部类">9.8.4 成员内部类</span></h3><blockquote><p>成员内部类：定义在外部类的成员位置，并且没有 <code>static</code> 修饰。</p><pre><code class="java">class Outer&#123;    class Inner&#123;    &#125;&#125;</code></pre></blockquote><h4><span id="9841-使用细节">#9.8.4.1 使用细节</span></h4><ol><li>可以直接访问外部类的所有成员，包括私有的</li><li>可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。</li><li>作用域 和外部类其他成员相同，为整个类体。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问成员内部类</li><li>外部其他类访问成员内部类<ul><li><code>Outer.Inner name = Outer.new Inner(); </code>下个方法的缩写</li><li><code>Outer.Inner name = new Outer().new Inner();</code></li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例（就是对象的 getter）</li></ul></li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h3><span id="985-静态内部类">9.8.5 静态内部类</span></h3><blockquote><p>静态内部类：定义在外部类的成员位置，经由 <code>static</code> 修饰。</p><pre><code class="java">class Outer&#123;    static class Inner&#123;    &#125;&#125;</code></pre></blockquote><h4><span id="9851-使用细节">#9.8.5.1 使用细节</span></h4><ol><li>可以直接访问外部类的所有 <strong>静态</strong> 成员，包括私有的。但不能访问非静态成员</li><li>可以添加访问修饰符。因为，静态内部类的地位就是一个成员。</li><li>作用域 和其他成员相同，为整个类体。</li><li>静态内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问静态内部类</li><li>外部其他类访问静态内部类<ul><li><code>Outer.Inner name = new Outer.Inner();</code> 即通过类名直接访问</li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.变量名</code>。<em>（怎么不一样了呢？因为静态内部类访问的都是静态成员）</em></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12 常用类</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/12%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="12-常用类">12 常用类</span></h1><h2><span id="121-包装类">12.1 包装类</span></h2><blockquote><p>包装类（Wrapper）：针对 八种基本数据类型 相应的 引用类型</p><p>有了类的特点，就可以调用类中的方法</p></blockquote><table><thead><tr><th>基本数据类型</th><th>包装类</th><th>父类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>void</td><td>Void</td><td>Object</td></tr></tbody></table><h3><span id="1211-装箱和拆箱">12.1.1 装箱和拆箱</span></h3><ul><li><p><strong>手动装箱和拆箱（JDK 5 以前）</strong></p><pre><code>int n1 = 100;Integer integer = new Integer(n1);// 手动装箱Integer integer2 = Integer.valueOf(n1);// 手动装箱int i = integer.intValue();// 手动拆箱JAVA</code></pre></li><li><p><strong>自动装箱和拆箱（JDK 5 以后）</strong></p><pre><code>n2 = 200;Integer integer3 = n2;// 自动装箱int j = integer3;// 自动拆箱JAVA</code></pre><p>  虽然可以自动装箱、拆箱，但使用 &#x3D;&#x3D; 直接比较两个包装类时，仍然是比较其地址。以下比较通常会失败：</p><pre><code>Integer ia = 1000;Integer ib = 1000;System.out.print(ia == ib);// falseJAVA</code></pre><p>  但，Java 实现仍有可能使其成立。Byte、Boolean 以及 Short、Integer 中 [-128, 127] 间的值已被包装到固定的对象中。对他们的比较可以成功。</p><pre><code>Integer ia = 127;Integer ib = 127;System.out.print(ia == ib);// trueJAVA</code></pre><p>  由此可见，使用 &#x3D;&#x3D; 直接比较两个包装类会带来不确定性。<strong>尽量使用 equals 方法对包装类进行比较。</strong></p></li></ul><p>装箱与拆箱是 <strong>编译器</strong> 的工作。在生成可执行的字节码文件时，编译器已经插入了必要的方法调用。</p><h3><span id="1212-包装类和-string-的相互转换">12.1.2 包装类和 <code>String</code> 的相互转换</span></h3><ul><li><p>包装类转 <code>String</code>：</p><blockquote><pre><code>&gt;Integer integer = 100;&gt;String str1 = integer + &quot;&quot;;//方法1（自动拆箱）&gt;String str2 = integer.toString();//方法2（toString方法）&gt;String str3 = String.valueOf(integer);//方法3（自动拆箱）JAVA</code></pre></blockquote></li><li><p><code>String</code> 转包装类：</p><blockquote><pre><code>String str4 = &quot;100&quot;;Integer integer2 = Integer.parseInt(str4);//方法1（自动装箱）Integer integer3 = new Integer(str4);//方法2（构造器）JAVA</code></pre></blockquote></li></ul><h3><span id="1213-包装类的常用方法">12.1.3 包装类的常用方法</span></h3><ul><li><p><code>Integer.MIN_VALUE</code>：返回最大值</p></li><li><p><code>Double.MAX_VALUE</code>：返回最小值</p></li><li><p><code>byteValue()</code>、<code>doubleValue()</code>、<code>floatValue()</code>、<code>intValue()</code>、<code>longValue()</code></p><p>  按各种基本数据类型返回该对象的值</p></li><li><p><code>Character.isDigit(int)</code>：判断是不是数字</p><p>  <code>Character.isLetter(int)</code>：判断是不是字母</p><p>  <code>Character.isUpperCase(int)</code>：判断是不是大写字母</p><p>  <code>Character.isLowerCase(int)</code>：判断是不是小写字母</p><p>  <code>Characher.isWhitespace(int)</code>：判断是不是空格</p></li><li><p><code>Character.toUpperCase(int)</code>：转成大写字母</p><p>  <code>Character.toLowerCase(int)</code>：转成小写字母</p></li><li><p><code>Integer.parseInt(string)</code>：将 String 内容转为 int</p><p>  <code>Double.parseDouble(string)</code></p></li><li><p><code>Integer.toBinaryString(int)</code>：将数字转为 2 进制表示的字符串</p><p>  <code>Integer.toHexString(int)</code>：将数字转为 16 进制表示的字符串</p><p>  <code>Integer.toOctalString(int)</code>：将数字转为 8 进制表示的字符串</p><p>  特别地，浮点数类型的包装类只有转成 16 进制的方法。而 Short、Byte 及其他包装类无此方法</p></li><li><p><code>int Integer.bitCount(i int)</code>：统计指定数字的二进制格式中 1 的数量</p></li></ul><h3><span id="1214-strictfp-关键字">12.1.4 strictfp 关键字</span></h3><blockquote><p>由于不同处理器对于浮点数寄存采取不同策略（有些处理器使用 64 位寄存 double，有些则是 80 位），对于浮点数的运算在不同平台上可能出现不同结果。</p></blockquote><p>使用 strictfp 关键字标记的方法或类中，所有指令都会使用严格统一的浮点数运算。</p><p>比如，把 main 方法标记为 strictfp</p><pre><code>public static strictfp void main(String[] args) &#123;    double ᓚᘏᗢ = 1 / 13.97;    System.out.println(ᓚᘏᗢ);&#125;JAVA</code></pre><h2><span id="122-string-类">12.2 <code>String</code> 类</span></h2><ol><li><p><code>String</code> 对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量对象是用双引号扩起的字符序列。例如 <code>&quot;你好&quot;</code></p></li><li><p>字符串的字符使用 Unicode 字符编码。一个字符（不论字母汉字）占 2 字节</p></li><li><p>常用构造器：</p><ul><li><p><code>String str1 = new String();</code></p></li><li><p><code>String str2 = new String(String original);</code></p></li><li><p><code>String str3 = new String(char[] a);</code></p></li><li><p><code>String str4 = new String(char[] a, int startIndex, int count);</code></p><p>  这句意思是：<code>char[]</code> 从 <code>startIndex</code> 起的 <code>count</code> 个字符</p></li></ul></li><li><p><code>String</code> 实现了接口 <code>Serializable</code> 和 <code>Comparable</code> ，可以 串行化和 比较大小</p><p> <em><strong>串行化：即，可以被网络传输，也能保存到文件</strong></em></p></li><li><p><code>String</code> 是 <code>final</code> 类，不能被继承</p></li><li><p><code>String</code> 有属性 <code>private final char[] value;</code> 用于存放字符串内容。</p><p> <code>value</code> 是 <code>final</code> 属性。其在栈中的地址不能修改，但堆中的内容可以修改。</p></li></ol><h3><span id="1221-string-构造方法">12.2.1 <code>String</code> 构造方法</span></h3><ul><li><p>直接指定</p><pre><code>String str1 = &quot;哈哈哈&quot;;JAVA</code></pre><p>  该方法：先从常量池看是否有 <code>&quot;哈哈哈&quot;</code> 数据空间。有的场合，指向那个空间；否则重新创建然后指向。</p><p>  这个方法，<code>str1</code> 指向 常量池中的地址。</p></li><li><p>构造器</p><pre><code>String str2 = new String(&quot;嘿嘿嘿&quot;);JAVA</code></pre><p>  该方法：先在堆中创建空间，里面维护一个 <code>value</code> 属性，指向 或 创建后指向 常量池的 <code>&quot;嘿嘿嘿&quot;</code> 空间。</p><p>  这个方法，<code>str2</code> 指向 堆中的地址</p></li></ul><h3><span id="1222-字符串的特性">12.2.2 字符串的特性</span></h3><ul><li><p>常量相加，看的是池</p><pre><code>String str1 = &quot;aa&quot; + &quot;bb&quot;;//常量相加，看的是池JAVA</code></pre><blockquote><p>上例由于构造器自身优化，相当于 <code>String str1 = &quot;aabb&quot;;</code></p></blockquote></li><li><p>变量相加，是在堆中</p><pre><code>String a = &quot;aa&quot;;String b = &quot;bb&quot;;String str2 = a + b;//变量相加，是在堆中JAVA</code></pre><blockquote><p>上例的底层是如下代码</p><pre><code>StringBuilder sb = new StringBuilder();sb.append(a);sb.append(b);str2 = sb.toString();//sb.toString()：return new String(value, 0, count);JAVA</code></pre></blockquote></li></ul><h3><span id="1223-string-的常用方法">12.2.3 <code>String</code> 的常用方法</span></h3><p>以下方法不需死记硬背，手熟自然牢记</p><ul><li><p><code>boolean equals(String s)</code>：区分大小写，判断内容是否相等</p><p>  <code>boolean equalsIgnoreCase(String s)</code>：判断内容是否相等（忽略大小写）</p></li><li><p><code>boolean empty()</code>：返回是否为空</p></li><li><p><code>int charAt(int index)</code>：获取某索引处的字符（代码单元）。</p><p>  必须用 <code>char c = str.charAt(15);</code>，不能用 <code>char c = str[15];</code></p><p>  <code>int codePointAt(int index)</code></p><p>  <code>int length()</code>：获取字符（<strong>代码单元</strong>）的个数</p><p>  <em><strong>—— 代码单元，见 [[2.6.2.4 字符本质与编码表]](<a href="https://i-melody.github.io/2021/11/22/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/2">https://i-melody.github.io/2021/11/22/Java/入门阶段/2</a> 变量&#x2F;#2-6-2-字符本质与编码表)</strong></em></p><p>  <code>IntStream codePoints()</code>：返回字符串中全部码点构成的流</p><p>  <code>long codePoints().count()</code>：返回真正长度（码点数量）</p><p>  <em><strong>—— 流，见 [[27.4 Stream API]](<a href="https://i-melody.github.io/2022/03/09/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/27">https://i-melody.github.io/2022/03/09/Java/入门阶段/27</a> Java 8 新特性&#x2F;#27-4-Stream-API)</strong></em></p></li><li><p><code>int indexOf(String str)</code>：获取字符（串）在字符串中第一次出现的索引。如果找不到，返回 -1</p><p>  <code>int indexOf(int char)</code> 参数也可以传入一个 int。由于自动类型转换的存在，也能填入 char</p><p>  <code>int indexOf(String str, int index)</code>：从 index 处（包含）开始查找指定字符（串）</p><p>  <code>int lastIndexOf(String str)</code>：获取字符在字符串中最后一次出现的索引。如果找不到，返回 -1</p></li><li><p><code>String substring(int start, int end)</code>：返回截取指定范围 [start, end) 的 <strong>新</strong> 字符串</p><p>  <code>String substring(int index)</code>：截取 index（包含）之后的部分</p></li><li><p><code>String trim()</code>：返回去前后空格的新字符串</p></li><li><p><code>String toUperCase()</code>：返回字母全部转为大写的新字符串</p><p>  <code>String toLowerCase()</code>：返回字母全部转为小写的新字符串</p></li><li><p><code>String concat(String another)</code>：返回拼接字符串</p></li><li><p><code>String replace(char oldChar, char newChar)</code>：替换字符串中的元素</p><pre><code>String str1 = &quot;Foolish cultists&quot;;String str2 = str1.replace(&quot;cultists&quot;, &quot;believers&quot;);//str1不变，str2为改变的值JAVA</code></pre></li><li><p><code>String[] split(String regex)</code>：分割字符串。</p><p>  对于某些分割字符，我们需要转义</p><pre><code>String str1 = &quot;aaa,bbb,ccc&quot;;String[] strs1 = str1.split(&quot;,&quot;);//这个场合，strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;4String str2 = &quot;aaa\bbb\ccc&quot;;String[] strs2 = str2.split(&quot;\\&quot;);//&quot;\&quot; 是特殊字符，需要转义为 &quot;\\&quot;JAVA</code></pre></li><li><p><code>int compareTo(String another)</code>：按照字典顺序比较两个字符串（的大小）。</p><p>  返回出现第一处不同的字符的编号差。前面字符相同，长度不同的场合，返回那个长度差。</p><pre><code>String str1 = &quot;ccc&quot;;String str2 = &quot;ca&quot;;String str3 = &quot;ccc111abc&quot;;int n1 = str1.compareTo(str2);//此时 n1 = &#39;c&#39; - &#39;a&#39; = 2int n2 = str1.compareTo(str3);//此时 n2 = str1,length - str3.length = -6int n3 = str1.compareTo(str1);//此时 n3 = 0JAVA</code></pre></li><li><p><code>char[] toCharArray()</code>：转换成字符数组</p><p>  <code>byte[] getBytes()</code>：字符串转为字节数组</p></li><li><p><code>String String.format(String format, Object... args)</code>：（静态方法）格式字符串</p><pre><code>String name = &quot;Roin&quot;;String age = &quot;1M&quot;;String state = &quot;computer&quot;;String formatStr = &quot;I am %s, I am %s old, I am a %s&quot;;String str = String.format(formatStr, name, age, state);//其中 %s 是占位符。此时，str = &quot;I am Roin, I am 1M old, I am a computer&quot;;//%s 表示字符串替换；%d 表示整数替换；#.2f 表示小数（四舍五入保留2位）替换；%c 表示字符替换JAVA</code></pre></li><li><p><code>String join(deli, ele...)</code>：拼接字符串（<code>ele...</code>），以 <code>deli</code> 间隔。</p></li><li><p><code>boolean startsWith(str)</code>：测试 str 是否为当前字符串的前缀</p></li><li><p><code>String repeat(int n)</code>：返回该字符串重复 n 次的结果</p></li></ul><h2><span id="123-stringbuffer-类">12.3 <code>StringBuffer</code> 类</span></h2><blockquote><p><code>java.lang.StringBuffer</code> 代表可变的字符序列。可以对字符串内容进行增删。</p><p>很多方法和 <code>String</code> 相同，但 <code>StringBuffer</code> 是可变长度。同时，<code>StringBuffer</code> 是一个容器</p></blockquote><ol><li><code>StringBuffer</code> 的直接父类是 <code>AbstractStringBuffer</code></li><li><code>StringBuffer</code> 实现了 <code>Serialiazable</code>，可以串行化</li><li>在父类中，<code>AbstractStringBuffer</code> 有属性 <code>char[] value</code> 不是 <code>final</code></li><li><code>StringBuffer</code> 是一个 <code>final</code> 类，不能被继承</li></ol><p><strong><code>String</code> 对比 <code>StringBuffer</code></strong></p><ul><li><code>String</code> 保存字符串常量，其中的值不能更改。每次更新实际上是更改地址，效率较低</li><li><code>StringBuffer</code> 保存字符串变量，里面的值可以更改。每次更新是更新内容，不用每次更新地址。</li></ul><h3><span id="1231-stringbuffer-构造方法">12.3.1 <code>StringBuffer</code> 构造方法</span></h3><ol><li><p>无参构造</p><pre><code>StringBuffer strb1 = new StringBuffer();JAVA</code></pre><blockquote><p>创造一个 16 位容量的空 <code>StringBuffer</code></p></blockquote></li><li><p>传入字符串构造</p><pre><code>String str1 = &quot;abcabc&quot;;StringBuffer strb2 = new StringBuffer(str1);JAVA</code></pre><blockquote><p>（上例）创造一个 str1.length + 16 容量的 <code>StringBuffer</code></p></blockquote></li><li><p>指定容量构造</p><pre><code>StringBuffer strb3 = new StringBuffer(3);JAVA</code></pre><blockquote><p>（上例）创造一个 3 容量的空 <code>StringBuffer</code></p></blockquote></li></ol><h3><span id="1232-string-和-stringbuffer的转换">12.3.2 <code>String</code> 和 <code>StringBuffer</code>的转换</span></h3><ol><li><p>转 <code>StringBuffer</code></p><pre><code>String str1 = &quot;abcabc&quot;;StringBuffer strb1 = new StringBuffer(str1);//方法1（构造器）StringBuffer strb1 = new StringBuffer();strb1 = strb1.append(str1);//方法2（先空再append）JAVA</code></pre></li><li><p>转 <code>String</code></p><pre><code>String str2 = strb1.toString();//方法1（toString）String str3 = new String(strb1);//方法2（构造器）JAVA</code></pre></li></ol><h3><span id="1233-stringbuffer-的常用方法">12.3.3 <code>StringBuffer</code> 的常用方法</span></h3><ul><li><p><code>append(char c)</code>：增加</p><p>  <code>append(String s)</code> 参数也能是字符串</p><p>  特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>delete(start, end)</code>：删减 [start, end) 的内容</p></li><li><p><code>replace(start, end, string)</code>：将 start 与 end 间的内容替换为 string</p></li><li><p><code>indexOf</code>：查找指定字符串第一次出现时的索引。没找到的场合返回 -1</p></li><li><p><code>insert</code>：在指定索引位置之前插入指定字符串</p></li><li><p><code>length()</code>：返回字符长度</p><p>  <code>capacity()</code>：返回当前的容量</p><p>  String 类对象分配内存时，按照对象中所含字符个数等量分配。</p><p>  StringBuffer 类对象分配内存时，除去字符所占空间外，会另加 16 字符大小的缓冲区。</p><p>  对于 <code>length()</code> 方法，返回的是字符串长度。对于 <code>capacity()</code> 方法，返回的是 字符串 + 缓冲区 的大小。</p></li></ul><h2><span id="124-stringbuilder-类">12.4 <code>StringBuilder</code> 类</span></h2><blockquote><p>一个可变的字符序列。此类提供一个与 <code>StringBuffer</code> 兼容的 API，但不保证同步（有线程安全问题）。该类被设计成 <code>StringBuffer</code> 的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>。如果可能，建议优先使用该类。因为在大多数实现中，它比起 <code>StringBuffer</code> 要快。</p><p>在 <code>StringBuilder</code> 是的主要操作是 <code>append</code> 和 <code>insert</code> 方法。可以重载这些方法，以接受任意类型的数据。</p></blockquote><ol><li><code>StringBuilder</code> 也继承了 <code>AbstractStringBuffer</code></li><li><code>StringBuilder</code> 也实现了 <code>Serialiazable</code>，可以串行化</li><li>仍然是在父类中有属性 <code>char[] value</code> ，而且不是 <code>final</code></li><li><code>StringBuilder</code> 也是一个 <code>final</code> 类，不能被继承</li><li><code>StringBuilder</code> 的方法，没有做互斥的处理（没有 <code>synchronize</code>），故而存在线程安全问题</li></ol><h3><span id="1241-string-stringbuffer-stringbuilder-的对比">12.4.1 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的对比</span></h3><ol><li><p><code>StringBuilder</code> 和 <code>StringBuffer</code> 类似，均代表可变字符序列，而且方法也一样</p></li><li><p><code>String</code>：不可变字符序列，效率低，但复用率高</p></li><li><p><code>StringBuffer</code>：可变字符序列，效率较高，线程安全</p></li><li><p><code>StringBuilder</code>：可变字符序列，效率最高，存在线程安全问题</p></li><li><p><code>String</code> 为何效率低：</p><blockquote><pre><code>String str1 = &quot;aa&quot;;//创建了一个字符串for(int n = 0; n &lt; 100; n++)&#123;    str1 += &quot;bb&quot;;//这里，原先的字符串被丢弃，创建新字符串&#125;//多次执行后，大量副本字符串留在内存中                                    //导致效率降低，也会影响程序性能JAVA</code></pre><p>如上，对 <code>String</code> 大量修改的场合，不要使用 <code>String</code></p></blockquote></li></ol><h2><span id="125-math-类">12.5 <code>Math</code> 类</span></h2><ul><li><p><code>Math.multiplyExact(int n1, int n2)</code>：进行乘法运算，返回运算结果</p><p>  通常的乘法 <code>n1 * n2</code> 在结果大于那个数据类型存储上限时，可能返回错误的值。</p><p>  使用此方法，结果大于那个数据类型存储上限时，会抛出异常</p><p>  <code>Math.addExact(int n1, int n2)</code>：加法</p><p>  <code>Math.subtractExact(int n1, int n2)</code>：减法</p><p>  <code>Math.incrementExact(int n1)</code>：自增</p><p>  <code>Math.decrementExact(int n1)</code>：自减</p><p>  <code>Math.negateExact(int n1, int n2)</code>：改变符号</p></li><li><p><code>Math.abs(n)</code>：求绝对值，返回 |n1|</p></li><li><p><code>Math.pow(n, i)</code>：求幂，返回 n3 ^ i</p></li><li><p><code>Math.ceil(n)</code>：向上取整，返回 &gt;&#x3D; n3 的最小整数（转成double）</p></li><li><p><code>Math.floor(n)</code>：向下取整，返回 &lt;&#x3D;n4 的最小整数（转成double）</p></li><li><p><code>Math.floorMod(int n1, int n2)</code>：返回 n1 除以 n2 的余数</p><p>  <code>n1 % n2</code> 的场合，返回的可能是负数，而不是数学意义上的余数</p></li><li><p><code>Math.round(n)</code>：四舍五入，相当于 <code>Math.floor(n5 + 0.5)</code></p></li><li><p><code>Math.sqrt(n)</code>：求开方。负数的场合，返回 <code>NaN</code></p></li><li><p><code>Math.random()</code>：返回一个 [0, 1) 区间的随机小数</p></li><li><p><code>Math.sin(n)</code>：正弦函数</p><p>  <code>Math.cos(n)</code>：余弦函数</p><p>  <code>Math.tan(n)</code>、<code>Math.atan(n)</code>、<code>Math.atan2(n)</code></p><p>  要注意，上述方法传入的参数是 <strong>弧度值</strong>。</p><p>  要得到一个角度的弧度值，应使用：<code>Math.toRadians(n)</code></p></li><li><p><code>Math.exp(n)</code>：e 的 n 次幂</p><p>  <code>Math.log10(n)</code>：10 为底的对数</p><p>  <code>Math.log()</code>：自然对数</p></li><li><p><code>Math.PI</code>：圆周率的近似值</p><p>  <code>Math.E</code>：e 的近似值</p></li></ul><h2><span id="126-arrays-类">12.6 <code>Arrays</code> 类</span></h2><ul><li><p><code>Arrays.toString()</code>：返回数组的字符串形式</p><blockquote><pre><code>int[] nums = &#123;0, 1, 33&#125;;String str = Array.toString(nums);//此时，str = &quot;[0, 1, 33]&quot;JAVA</code></pre><p>特别的，输入为 null 时返回 “null”</p></blockquote></li><li><p><code>Arrays.sort(arr)</code>：排序</p><p>  因为数组是引用类型，使用 sort 排序后，会直接影响到实参。</p><p>  默认（自然排序）从小到大排序。</p><p>  <code>Arrays.sort(arr, Comparator c)</code>：按照传入的比较器决定排序方法</p><pre><code>Integer[] nums;...Comparator&lt;Integer, Integer&gt; c = new Comparator&lt;Integer, Integer&gt;()&#123;    @Override    public int compare(Integer o1, Integer o2)&#123;        return n2 - n1;// 这个场合，变成从大到小排序    &#125;&#125;Arrays.sort(nums, c);JAVA</code></pre></li><li><p><code>Arrays.binarySearch(array, num)</code>：通过二分搜索法查找。前提是必须先排序。</p><p>  找不到的场合，返回 - (low + 1)。即，其应该在的位置的负值</p><pre><code>Integer[] nums2 = &#123;-10, -5, -2, 0, 4, 5, 9&#125;;int index = Arrays.binarySearch(nums2, 7);// 此时 index = -7                                            // 如果 7 存在，应该在第 7 个位置JAVA</code></pre></li><li><p><code>Arrays.copyOf(arr, n)</code>：从 <code>arr</code> 中，复制 n 个元素（成为新的数组）。</p><p>  n &gt; arr.length 的场合，在多余的位置添加 <code>null</code>。n &lt; 0 的场合，抛出异常。</p><p>  该方法的底层使用的是 <code>System.arraycopy</code></p></li><li><p><code>Arrays.fill(arr, o)</code>：用 o 填充 <code>num</code> 的所有元素。</p></li><li><p><code>Arrays.equals(arr1, arr2)</code>：比较两个数组元素是否完全一致（<code>true</code>&#x2F;<code>false</code>）</p></li><li><p><code>Arrays.asList(a, b, c, d)</code>：将输入数据转成一个 <code>List</code> 集合</p></li></ul><h2><span id="127-system-类">12.7 <code>System</code> 类</span></h2><ul><li><p><code>System.exit(0)</code>：退出当前程序。0 表示一个状态，正常状态是 0</p></li><li><p><code>System.arraycopy(arr, 0, newArr, 0 ,3)</code>：复制数组元素。</p><p>  上例是：arr 自下标 0 起开始，向 newArr 自下标 0 开始，依次拷贝 3 个值</p><p>  这个方法比较适合底层调用。我们一般使用 <code>Arrays.copyOf</code> 来做</p></li><li><p><code>System.currentTimeMillis</code>：返回当前时间距离 1970 - 1 - 1 的毫秒数</p></li><li><p><code>System.gc</code>：运行垃圾回收机制</p></li></ul><h2><span id="128-biginteger-和-bigdecimal-类">12.8 <code>BigInteger</code> 和 <code>BigDecimal</code> 类</span></h2><blockquote><p><code>BigInteger</code>：适合保存更大的整数</p><p><code>BigDecimal</code>：适合保存精度更大的浮点数</p></blockquote><pre><code>//用引号把大数变成字符串BigInteger bigNum = new BigInteger(&quot;100000000000000000000000&quot;);JAVA</code></pre><p><strong>构造方法：</strong></p><ul><li><code>new BigInteger(String intStr)</code>：通过一个字符串构建大数</li><li><code>BigInteger BigInteger.valueOf(1)</code>：通过静态方法，让整数类型转成大数</li></ul><p>另外，在对 <code>BigInteger</code> 和 <code>BigDecimal</code> 进行加减乘除的时候，需要使用对应方法</p><p>不能直接用 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p><p><strong>常用方法：</strong></p><ul><li><p><code>BigInteger add(BigInteger)</code>：加法运算。返回新的大数</p></li><li><p><code>BigInteger subtract(BigInteger)</code>：减法</p></li><li><p><code>BigInteger multiply(BigInteger)</code>：乘法</p></li><li><p><code>BigInteger divide(BigInteger)</code>：除法运算</p><p>  该方法可能抛出异常。因为可能产生是无限长度小数。</p><p>  解决方法（保留分子精度）：<code>bigDecimal.divide(bD3, BigDecimal.ROUND_CELLING)</code></p></li><li><p>一些常量：</p><p>  <code>BigInteger.ONE</code>、<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code> 分别是 1、0、10</p><p>  one 就是英文的 1，zero 就是英文的 0……这个大家都懂的吧？</p></li></ul><h2><span id="129-日期类">12.9 日期类</span></h2><h3><span id="1291-第一代日期类">12.9.1 第一代日期类</span></h3><blockquote><p>Date：精确到毫秒，代表特定瞬间。这里的是 java.util.Date</p><p>SimpleDateFormat：格式和解析日期的类</p></blockquote><ol><li><p><code>Date d1 = new Date();</code>：调用默认无参构造器，获取当前系统时间。</p><p> 默认输出日期格式是国外的格式，因此通常需要进行格式转换</p><pre><code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy.MM.dd HH.mm.ss&quot;);String dateFormated = sdf.(d1);//日期转成指定格式。JAVA</code></pre></li><li><p>通过指定毫秒数得到时间：</p><pre><code>Date d2 = new Date(10000000000);JAVA</code></pre></li><li><p>把一个格式化的字符串转成对应的 Date：</p><pre><code>SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH点mm分 E&quot;);Date d3 = sdf2.parse(&quot;2021年12月22日 00点03分 星期三&quot;);JAVA</code></pre><p> 这个场合，给定的字符串格式应和 <code>sdf2</code> 格式相同，否则会抛出异常</p></li></ol><h3><span id="1292-第二代日期类">12.9.2 第二代日期类</span></h3><blockquote><p>Calendar：构造器是私有的，要通过 getInstance 方法获取实例</p></blockquote><ol><li><p>Calendar 是一个抽象类，其构造器私有</p><pre><code>Calendar c1 = Calendar.genInstance();//获取实例的方法JAVA</code></pre></li><li><p>提供大量方法和字段提供给程序员使用</p><ul><li><p><code>c1.get(Calendar.YEAR)</code>：获取年份数</p></li><li><p><code>c1.get(Calendar.MONTH)</code>：获取月份数</p><p>  特别的，实际月份是 返回值 +1。因为 Calendar 的月份是从 0 开始编号的</p></li><li><p><code>c1.get(Calendar.DAY_OF_MONTH)</code>：获取日数</p></li><li><p><code>c1.get(Calendar.HOUR)</code>：获取小时数（12小时制）</p><p>  <code>c1.get(Calendar.HOUR_OF_DATE)</code>：获取小时数（24小时制）</p></li><li><p><code>c1.get(Calendar.MINUTE)</code>：获取分钟数</p></li><li><p><code>c1.get(Calendar.SECOND)</code>：获取秒数</p></li></ul><p> Calendar 没有专门的格式化方法，需要程序员自己组合来显示</p></li></ol><h3><span id="1293-第三代日期类">12.9.3 第三代日期类</span></h3><blockquote><p>JDK 1.0 加入的 Date 在 JDK 1.1 加入 Calendar 后已被弃用</p><p>然而，Calendar 也存在不足：</p><ol><li>可变性：像日期和实际这样的类应该是不可改变的</li><li>偏移性：年份都是从 1900 年开始，月份都是从 0 开始</li><li>格式化：只对 Date 有用，对 Calendar 没用</li><li>其他问题：如不能保证线程安全，不能处理闰秒（每隔 2 天多 1 秒）等</li></ol><p>于是，在 JDK 8 加入了以下新日期类：</p><ul><li>LocalDate：只包含 日期（年月日），可以获取 日期字段</li><li>LocalTime：只包含 时间（时分秒），可以获取 时间字段</li><li>LocalDateTime：包含 日期 + 时间，可以获取 日期 + 时间字段</li><li>DateTimeFormatter：格式化日期</li><li>Instant：时间戳</li></ul></blockquote><ol><li><p>使用 <code>now()</code> 方法返回当前时间的对象</p><pre><code>LocalDateTime ldt = LocalDateTime.now();//获取当前时间JAVA</code></pre></li><li><p>获取各字段方法：</p><ul><li><p><code>ldt.getYear();</code>：获取年份数</p></li><li><p><code>ldt.getMonth();</code>：获取月份数（英文）</p><p>  <code>ldt.getMonthValue();</code>：获取月份数（数字）</p></li><li><p><code>ldt.getDayOfMonth();</code>：获取日数</p></li><li><p><code>LocalDateTime ldt2 = ldt.plusDays(100);</code>：获取 ldt 时间 100 天后的时间实例</p></li><li><p><code>LocalDateTime ldt3 = ldt.minusHours(100);</code>：获取 ldt 时间 100 小时前的时间实例</p></li><li><p>…</p></li></ul></li><li><p>格式化日期：</p><pre><code>DateTimeFormatter dtf = new DateTimeFormatter(&quot;yyyy.MM.dd HH.mm.ss&quot;);String date = dtf.format(ldt);//获取格式化字符串JAVA</code></pre></li><li><p><code>Instant</code> 和 <code>Date</code> 类似</p><ul><li>获取当前时间戳：<code>Instant instant = Instant.now();</code></li><li>转换为 <code>Date</code>：<code>Date date = Date.form(instant);</code></li><li>由 <code>Date</code> 转换：<code>Instant instant = date.toInstant;</code></li></ul></li></ol><h1><span id="12-泛型">12 泛型</span></h1><h2><span id="1210-泛型">12.10 泛型</span></h2><blockquote><p>泛型（generic）：又称 参数化类型。是JDK 5 出现的新特性。解决数据类型的安全性问题。</p><p>在类声明或实例化时只要制定好需要的具体类型即可。</p></blockquote><p>举例说明：</p><pre><code class="java">Properties&lt;Person&gt; prop = new Properties&lt;Person&gt;();</code></pre><blockquote><p>上例表示存放到 <code>prop</code> 中的必须是 <code>Person</code> 类型。</p><p>如果编译器发现添加类型不符合要求，即报错。</p><p>遍历时，直接取出 <code>Person</code> 而非 <code>Object</code></p></blockquote><ol><li><p>编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生 ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。</p></li><li><p>&#x3D;&#x3D;也减少了向下转型的次数，提高了效率。&#x3D;&#x3D;</p></li><li><pre><code class="java"> //案例1 //需要在for增强循环中如果要对特定集合内的对象的属性进行遍历  //没有引入泛型需要这样: /*   Set set = new HashSet();   for(Objecto o: set)&#123;//只能定义为Object类型      Stu stu = (Stu) o;//每次循环都进行一次类型转换,效率低.      System.out.prinln(stu.getName);   &#125; */  //如果在创建集合时这样做(添加类型参数): Set&lt;Stu&gt; set = new HashSet&lt;Stu&gt;();  for (Stu stu :set) &#123;//在这里原本只能放Object类型的stu,现在引入泛型后可以指定类型了,不用向下转型了.     System.out.println(stu.getName()); &#125;</code></pre></li><li><pre><code class="java"> //案例2 //迭代器,在没有引出泛型的代码如下,在右边还是要强制转型.因为返回的是个Object类型的对象,泛型后则直接返回一个指定类型的对象,所以无需强转,直接接收. while (iterator.hasNext()) &#123;         Map.Entry e =  (Map.Entry)iterator.next();//右边强转类型         Stu stu =  (Stu) e.getValue();//右边强转类型         System.out.println(stu.getName()+stu.getAge()); &#125; //引入后(添加&lt;Map.Entry&lt;k,v&gt;&gt;并指定类型),直接可以省去向下转型的操作   Set&lt;Map.Entry&lt;String,Stu&gt;&gt; entrySet = hashMap.entrySet();  Iterator&lt;Map.Entry&lt;String,Stu&gt;&gt; iterator = entrySet.iterator();  while (iterator.hasNext()) &#123;         Map.Entry&lt;String, Stu&gt; next = iterator.next();//无需转类型         Stu stu = next.getValue();//无需转类型         System.out.println(stu.getName()+stu.getAge()); &#125;</code></pre></li><li><p>泛型的作用是：&#x3D;&#x3D;可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。&#x3D;&#x3D;</p></li></ol><pre><code class="java">class P&lt;E&gt; &#123;    E e;//E 表示 e 的数据类型，在定义 P类 时指定。在编译期间即确认类型    public P(E e)&#123;//可作为参数类型        this.e = e;    &#125;    public E doSth()&#123;//可作为返回类型        return this.e;    &#125;&#125;</code></pre><p>  实例化时指定 E 的类型，编译时上例所有 E 会被编译器替换为那个指定类型</p><h4><span id="使用方法">使用方法：</span></h4><ul><li><p><strong>声明泛型：</strong></p><pre><code class="java">interface InterfaceName&lt;T&gt; &#123;...&#125;class ClassName&lt;A, B, C, D&gt; &#123;...&#125;</code></pre><p>  上例 T、A、B、C、D 不是值，而是类型。可以用任意字母代替</p></li><li><p><strong>实例化泛型：</strong></p><pre><code class="java">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Integer&gt; iterator = vector.interator&lt;Integer&gt;();</code></pre><p>  类名后面指定类型参数的值</p></li></ul><p><strong>注意细节：</strong></p><ol><li><p>泛型只能是引用类型</p></li><li><p>指定泛型具体类型后，&#x3D;&#x3D;可以传入该类型或其子类类型&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;在实际开发中往往简写泛型&#x3D;&#x3D;</p></li></ol><pre><code class="java">List&lt;String&gt; strList = new ArrayList&lt;&gt;();</code></pre><p>  &#x3D;&#x3D;编译器会进行类型推断，右边 <code>&lt; &gt;</code> 内容可以省略&#x3D;&#x3D;</p><ol start="4"><li><p>实例化不写泛型的场合，相当于默认泛型为 <code>Object</code></p><pre><code class="java">ArrayList arrayList = new ArrayList();//等价于ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();可以传入任意类型</code></pre></li></ol><h4><span id="自定义泛型类-接口">自定义泛型类 · 接口：</span></h4><pre><code class="java">class Name&lt;A, B...&gt; &#123;...&#125;//泛型标识符 可有多个，一般是单个大写字母表示</code></pre><ol><li><p>普通成员可以使用泛型（属性、方法）</p></li><li><p>&#x3D;&#x3D;泛型类的类型，是在创建对象时确定的。&#x3D;&#x3D;</p></li></ol><p>  因此：&#x3D;&#x3D;静态方法中不能使用类的泛型&#x3D;&#x3D;,但可以定义为我泛型方法；&#x3D;&#x3D;使用泛型的数组，也不能初始化。&#x3D;&#x3D;</p><pre><code class="java">public static void m1(T a)&#123;&#125;;//错误用法，静态方法是和类相关的，在类加载时对象还没有创建。而泛型在类创建对象的时候才会指定。</code></pre><pre><code class="java">T[] ts = new T[3]//错误用法，不允许初始化。</code></pre><ol start="3"><li><p>创建对象时不指定的场合，默认 Object。建议还是写上 <code>&lt;Object&gt;</code>，大气，上档次</p></li><li><p>自定义泛型接口</p><pre><code class="java">interface Name&lt;T, R...&gt; &#123;...&#125;</code></pre><p> &#x3D;&#x3D;泛型接口，其泛型在 继承接口 或 实现接口 时确定&#x3D;&#x3D;。</p><pre><code class="java">//继承接口：interface A extends Name&lt;String,Intager&gt;&#123;...&#125;//指定了泛型//实现接口：class B implements Name&lt;String,Intager&gt;&#123;...&#125;//指定了泛型</code></pre></li></ol><h4><span id="自定义泛型方法">#自定义泛型方法：</span></h4><pre><code class="java">修饰符 &lt;T, R...&gt; 返回类型 方法名(形参) &#123;...&#125;</code></pre><ol><li><p>&#x3D;&#x3D;可以定义在普通类中，也可以定义在泛型类中&#x3D;&#x3D;</p><pre><code class="java">//在泛型中class F&lt;T,R&gt;&#123;    public&lt;U,M&gt; void eat(U u,M m)&#123;...&#125;//调用时传入的类型指定了U，M&#125;</code></pre></li><li><p>当泛型方法被&#x3D;&#x3D;调用时，类型会根据传入的数据确定&#x3D;&#x3D;</p></li><li><p>以下场合</p></li></ol><blockquote><pre><code class="java">Class C&lt;T&gt; &#123;    public void cMethord(T t)&#123;...&#125;&#125;</code></pre></blockquote><p>  注意！！！&#x3D;&#x3D;没有 <code>&lt; &gt;</code>，不是泛型方法，而是使用了泛型的普通方法&#x3D;&#x3D;</p><h4><span id="泛型继承">#泛型继承：</span></h4><ol><li><p>泛型&#x3D;&#x3D;不具有继承性&#x3D;&#x3D;</p></li><li><p><code>&lt;?&gt;</code>：&#x3D;&#x3D;支持任意泛型类型&#x3D;&#x3D;</p></li><li><p><code>&lt;? extends A&gt;</code>：&#x3D;&#x3D;支持 A 及 A的子类，规定了泛型的上限（后续还可以增加传入的对象，只要继承了A类）&#x3D;&#x3D;，只有A和A的子类可以传入</p><pre><code class="java">public static void printCollection(List&lt;? extend A&gt; c)&#123;...&#125;//一个打印list集合数据的方法，List指定了只能传入A和A的子类。</code></pre></li><li><p><code>&lt;? super A&gt;</code>：&#x3D;&#x3D;支持 A及 A 的父类，不限于直接父类，规定了泛型的下限（固定住了）&#x3D;&#x3D;，只有A和A的父类可以使用泛型。</p></li></ol><h4><span id="课后练习">课后练习</span></h4><pre><code class="java">public class GenericExercise02 &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Employee&gt; employees = new ArrayList&lt;&gt;();        employees.add(new Employee(&quot;tom&quot;, 20000, new MyDate(1980,12,11)));        employees.add(new Employee(&quot;jack&quot;, 12000, new MyDate(2001,12,12)));        employees.add(new Employee(&quot;tom&quot;, 50000, new MyDate(1980,12,10)));        System.out.println(&quot;employees=&quot; + employees);        employees.sort(new Comparator&lt;Employee&gt;() &#123;            @Override            public int compare(Employee emp1, Employee emp2) &#123;                //先按照name排序，如果name相同，则按生日日期的先后排序。【即：定制排序】                //先对传入的参数进行验证                if(!(emp1 instanceof  Employee &amp;&amp; emp2 instanceof Employee)) &#123;                    System.out.println(&quot;类型不正确..&quot;);                    return 0;                &#125;                //比较name                int i = emp1.getName().compareTo(emp2.getName());                if(i != 0) &#123;                    return i;                &#125;                //下面是对birthday的比较，因此，我们最好把这个比较，放在MyDate类完成                //封装后，将来可维护性和复用性，就大大增强.                return emp1.getBirthday().compareTo(emp2.getBirthday());            &#125;        &#125;);        System.out.println(&quot;==对雇员进行排序==&quot;);        System.out.println(employees);    &#125;&#125;/** * 定义Employee类 * 1) 该类包含：private成员变量name,sal,birthday，其中 birthday 为 MyDate 类的对象； * 2) 为每一个属性定义 getter, setter 方法； * 3) 重写 toString 方法输出 name, sal, birthday * 4) MyDate类包含: private成员变量month,day,year；并为每一个属性定义 getter, setter 方法； * 5) 创建该类的 3 个对象，并把这些对象放入 ArrayList 集合中（ArrayList 需使用泛型来定义），对集合中的元素进行排序，并遍历输出： * * 排序方式： 调用ArrayList 的 sort 方法 , * 传入 Comparator对象[使用泛型]，先按照name排序，如果name相同，则按生日日期的先后排序。【即：定制排序】 * 有一定难度 15min , 比较经典 泛型使用案例 GenericExercise02.java */</code></pre><pre><code class="java">public class MyDate implements Comparable&lt;MyDate&gt;&#123;    private int year;    private int month;    private int day;    public MyDate(int year, int month, int day) &#123;        this.year = year;        this.month = month;        this.day = day;    &#125;    public int getYear() &#123;        return year;    &#125;    public void setYear(int year) &#123;        this.year = year;    &#125;    public int getMonth() &#123;        return month;    &#125;    public void setMonth(int month) &#123;        this.month = month;    &#125;    public int getDay() &#123;        return day;    &#125;    public void setDay(int day) &#123;        this.day = day;    &#125;    @Override    public String toString() &#123;        return &quot;MyDate&#123;&quot; +                &quot;year=&quot; + year +                &quot;, month=&quot; + month +                &quot;, day=&quot; + day +                &#39;&#125;&#39;;    &#125;    @Override    public int compareTo(MyDate o) &#123; //把对year-month-day比较放在这里        int yearMinus = year - o.getYear();        if(yearMinus != 0) &#123;            return  yearMinus;        &#125;        //如果year相同，就比较month        int monthMinus = month - o.getMonth();        if(monthMinus != 0) &#123;            return monthMinus;        &#125;        //如果year 和 month        return day - o.getDay();    &#125;&#125;</code></pre><pre><code class="java">    public List&lt;T&gt; list()&#123;        List&lt;T&gt; list = new ArrayList&lt;&gt;();//        方法1：//        Set&lt;Map.Entry&lt;String,T&gt;&gt; set = this.map.entrySet();//        Iterator&lt;Map.Entry&lt;String,T&gt;&gt; iterator = set.iterator();//        while (iterator.hasNext()) &#123;//            Map.Entry&lt;String, T&gt; next = iterator.next();//              list.add(next.getValue());//        &#125;//         方法2：        Set&lt;String&gt; keyset = map.keySet();        for (String key:             keyset) &#123;            list.add(get(key));        &#125;        //方法3：//        Collection collections = map.values();//        list.addAll(collections);        return list;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16 多线程</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/16%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="16-多线程">16 多线程</span></h1><h2><span id="161-线程的概念">16.1 线程的概念</span></h2><blockquote><p>对于一般程序而言，其结构大都可以分为一个入口、一个出口、一个顺次执行的语句序列。这样的语句结构称为进程，它是程序的一次动态执行，对应了代码加载、执行至完毕的全过程。</p><p>进程即是程序在处理机中的一次运行。在这样一个结构中不仅包含程序代码，也包括了系统资源的概念。</p><p>在单 CPU 计算机内部，微观上讲，同一时间只能有一个线程运行。实现多线程即从宏观上使多个作业同时执行。</p></blockquote><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310112105312.png" alt="image-20231011210512208"></p><p><strong>程序</strong>：为完成特定任务，用某种语言编写的一组指令的集合。</p><p><strong>进程</strong>：运行中的程序。当你运行一个程序，系统就会为该进程分配空间。进程是程序的一次执行过程。是一个动态过程：有其自身产生、存在、消亡的过程。</p><p><strong>线程</strong>：由进程创建的，进程的一个实体。一个进程可以有多个线程。比如在百度网盘里里有多个下载任务，每一个任务就是一个线程。</p><p><strong>单线程</strong>：同一时刻，只允许执行一个线程。</p><p><strong>多线程</strong>：同一时刻，可以执行多个线程。比如QQ聊天窗口、迅雷下载。</p><p><strong>并发</strong>：同一时刻，多个任务<strong>交替执行</strong>，造成一种貌似并行的状态。单核 CPU 实现的多任务就是并发。</p><p><strong>并行</strong>：同一时刻，多个任务<strong>同时进行</strong>。多核 CPU 可以实现并行。</p><p>&#x3D;&#x3D;tips:并发和并行可以同时进行。&#x3D;&#x3D;</p><h3><span id="1611-线程的结构">16.1.1 线程的结构</span></h3><p>在 Java 中，线程由以下 3 部分组成：</p><ul><li>虚拟 CPU：封装在 java.lang.Thread 类中，控制着整个线程的运行</li><li>执行的代码：传递给 Thread 类，由其控制按序执行</li><li>处理的数据：传递给 Thread 类，是在代码执行过程中需要处理的数据</li></ul><h3><span id="1612-线程的状态">16.1.2 线程的状态</span></h3><blockquote><p>Java 的线程是通过包 java.lang 中定义的类 Thread 来实现的。当生成了一个 Thread 类后就产生了一个线程。通过该对象实例，可以启动线程、终止线程，或暂时挂起线程</p><p>mian线程和Thread-0、…子线程，&#x3D;&#x3D;主线程结束不一定意味整个进程结束&#x3D;&#x3D;，此时子线程可能还在运行中，而应用程序还在运行中，在主线程结束的基础上当所有的子线程也结束才意味着整个进程结束。</p></blockquote><p>线程共有 4 种状态：新建（New）、可运行（Runnable）、死亡（Dead）、阻塞（Blocked）</p><ul><li><p><strong>新建（New）：</strong></p><p>  线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</p></li><li><p><strong>可运行（Runnable）：</strong>（细化为两个状态）</p><p>  此时线程已经启动，处于线程的 <code>run()</code> 方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU 空闲就会立刻运行。</p><p>  可以运行但没在运行的线程都排在一个队列中，这个队列称为<strong>就绪队列</strong>。</p><p>  可运行状态下，运行中的线程处于<strong>运行状态（Running）</strong>，未运行线程处于<strong>就绪状态（Ready）</strong>。</p><p>  调用 <code>start()</code> 方法可以让线程进入可运行状态。</p></li><li><p><strong>死亡（Dead）：</strong></p><p>  <strong>线程死亡（Terminated）</strong>的原因有两个：一是 <code>run()</code> 方法最后一个语句执行完毕，二是线程遇到异常退出</p></li><li><p><strong>阻塞（Blocked）：</strong></p><p>  一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。</p><p>  阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。</p><p>  引起阻塞的方法很多，<code>sleep()</code> 和 <code>wait()</code> 是两个常用的阻塞方法</p></li><li><p><strong>中断线程：</strong></p><ul><li><p><code>void interrupt()</code>：向一个线程发送一个中断请求，并把该线程的 interruptd 状态变为 true。</p><p>  中断阻塞线程的场合，会抛出 InterruptException 异常</p></li><li><p><code>static boolean interrupted()</code>：检测当前线程是否被中断，并重置状态 interrupted 的值。</p><p>  连续调用该方法的场合，第二次调用会返回 false</p></li><li><p><code>boolean isInterrupted()</code>：检测当前线程是否中断。不改变 interrupted 的值</p></li></ul></li></ul><h2><span id="162-线程的使用">16.2 线程的使用</span></h2><p>在 Java 中线程使用有两种方法：</p><ol><li><p>继承 <code>Thread</code> 类，重写 <code>run</code> 方法</p><blockquote><pre><code class="java">public class Thread implements Runnable//可见 Thread 也是实现了 Runable 接口</code></pre></blockquote></li><li><p>实现 <code>Runable</code> 接口，重写 <code>run</code> 方法</p></li></ol><h3><span id="1621-继承-thread-类">16.2.1 继承 Thread 类</span></h3><blockquote><p>Thread 类是 Java 用于表示线程的类。那么，一个类被定义为其子类，则该类也能用来表示线程</p></blockquote><pre><code class="java">public static void main(String[] args) &#123; Type type = new Type(); type.start();//开始线程                                             //如果用 run 方法，则还是停留在主线程                                             //  那样，相当于 串行。执行完毕才继续&#125;class Type extends Thread &#123;//先继承 Thread 类 int i = 0; @Override public void run() &#123;     while (true) &#123;         System.out.println(i);         try &#123;             Thread.sleep(100);//休眠 100 毫秒         &#125; catch (InterruptedException e) &#123;             e.printStackTrace();         &#125;         if (i++ == 10) &#123;//i = 10 时停止循环             break;         &#125;     &#125; &#125;&#125;</code></pre><p><strong>关于 <code>start()</code> 方法</strong></p><pre><code class="java">public synchronized void start() &#123;    ...    start0();&#125;private native void start0();//start0 是 native。即，底层方法</code></pre><ol><li><code>start()</code> 方法调用了一个 <code>start0()</code> 底层方法</li><li><code>start0()</code> 是本地方法，<u>由 JVM 调用</u>，底层是 c&#x2F;c++ 实现</li><li>真正的多线程效果，是 <code>start0()</code>，而不是 <code>run()</code></li><li><code>start()</code> 方法调用 <code>start0()</code> 方法后，该线程不一定会立刻执行，只是将线程变成了可运行状态。具体何时运行，由 CPU 统一调度</li></ol><h3><span id="1622-实现-runable-接口">16.2.2 实现 Runable 接口</span></h3><blockquote><p>Runnable 是 Java 用以实现线程的接口。从根本上将，任何实现线程的类都必须实现该接口。</p></blockquote><pre><code class="java">public static void main(String[] args) &#123; Runnable type = new Type();//Runable 没有 start()方法 Thread thread = new Thread(type);//所以，这里使用了 静态代理 thread.start();//传入Thread&#125;JAVAclass Type implements Runnable &#123;//这部分和 Thread 相似 @Override public void run() &#123;     int i = 0;     while (true)&#123;         System.out.println(i &lt;&lt; i);         try &#123;             Thread.sleep(100);         &#125; catch (InterruptedException e) &#123;             e.printStackTrace();         &#125;         if (++i &gt; 15)&#123;             break;         &#125;     &#125; &#125;&#125;</code></pre><p><strong>关于 &#x3D;&#x3D;静态代理&#x3D;&#x3D;</strong></p><blockquote><pre><code class="java">//Thread源代码class Thread implements Runable &#123;&#125;    ...    private Runnable target;      ... public Thread(Runnable target) &#123;//构造器     init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);                                     //这句话可以先理解为 this.target = target; &#125;    ... public void run() &#123;     if (target != null) &#123;         target.run();//在这里调用run方法，进行动态绑定，实际的运行类型是传入代理的类型，调用的是它实现的run方法。     &#125; &#125;    public void start()&#123;        start0();//这个方法是底层JVM完成的,真正实现多线程的方法。    &#125;    public void start0()&#123;        run();//调用run        &#125;    ...&#125;</code></pre><p>相当于，先创建了一个新线程，然后在新线程中调用 run 方法</p></blockquote><h3><span id="1623-继承-thread-和-实现-runable-的区别">16.2.3 继承 Thread 和 实现 Runable 的区别</span></h3><ol><li><p>从 Java 设计来看，两者本质上没有区别。&#x3D;&#x3D;<code>Thread</code> 类本身就实现了 <code>Runable</code> 接口&#x3D;&#x3D;,所以在继承的时候Thread的时候也要实现</p></li><li><p>&#x3D;&#x3D;实现 <code>Runable</code> 接口的方式更加适合多个线程共享一个资源的情况，&#x3D;&#x3D;且&#x3D;&#x3D;避免了单继承的限制&#x3D;&#x3D;。&#x3D;&#x3D;建议使用。&#x3D;&#x3D;</p></li></ol><pre><code class="java">T t1 = new T(&quot;hello&quot;);Thread thread01 = new Thread(t1);Thread thread02 = new Thread(t2);//两个线程共享t1thread01.start();thread02.start();</code></pre><pre><code class="java">//下面这种情况会导致A无法继承Tread作为进程使用，因为java的单继承机制，但可以实现Runable接口来作为进程使用class A extend B implements Runable&#123;&#125;</code></pre><h3><span id="1624-线程中止">16.2.4 线程中止</span></h3><ol><li><p>当线程结束后，会自动退出</p></li><li><p>&#x3D;&#x3D;还可以通过使用变量来控制 <code>run</code> 方法退出的方式来停止线程，即 <strong>通知方式。</strong>&#x3D;&#x3D;</p><blockquote><pre><code class="java">//A类线程public void run() &#123;while (loop) &#123;//这个场合，只要外部控制loop 即可  try &#123;      Thread.sleep(1);  &#125; catch (InterruptedException e) &#123;      e.printStackTrace();  &#125;  move();&#125;    //提供一个setLoop    public void setLoop(boolean loop)&#123;this.loop = loop;&#125;&#125;</code></pre><pre><code class="java">//外部：public static void main(Stirng[] args)&#123;    Thread.sleep(10000);//休眠10秒然后通过控制线程内部变量终止进程      a.setLoop(false);//让另外一个线程中止  &#125;</code></pre><p>另外这种方法还可以在其他的线程中使用而不仅仅局限于主线程(main方法内)，比如线程b要让线程a中止就可以用这种方法，</p></blockquote></li></ol><h3><span id="1625-线程常用方法">16.2.5 线程常用方法</span></h3><ul><li><p>&#x3D;&#x3D;<code>setName(name)</code>：设置线程名称，使之与参数 name 相&#x3D;&#x3D;同</p></li><li><p><code>getName()</code>：返回线程名称</p></li><li><p>&#x3D;&#x3D;<code>start()</code>：线程开始执行。JVM 调用 <code>start0</code> 方法&#x3D;&#x3D;</p><p>  该方法会创建新的线程，新线程调用 <code>run</code>。</p></li><li><p><code>run()</code>：到下面玩跑步</p><p>  就是简单的方法调用，不会产生新线程。</p></li><li><p><code>setPriority(int priority)</code>：更改线程优先级</p><p>  <code>getPriority()</code>：获取<strong>线程优先级</strong></p><p>  priority 范围：</p><ul><li>MAX_PRIORITY：最高优先级（10）</li><li>MIN_PRIORITY：最低优先级（1）</li><li>NORM_PRIORITY：不高不低，真是好极了的优先级（5）</li></ul><p>  每个线程都有一个<strong>优先级</strong>。Java 线程调度采用如下优先级策略：</p><ul><li>优先级高的先执行，优先级低的后执行</li><li>每个线程创建时会被自动分配一个优先级。默认的场合，继承父类优先级</li><li>任务紧急的线程，优先级较高</li><li>同优先级线程按 “<strong>先进先出</strong>” 原则调度</li></ul></li><li><p><code>sleep(int millsecond)</code>：让线程休眠指定的时间</p><p>  该方法是 Thread 类的静态方法，可以直接调用</p></li><li><p>&#x3D;&#x3D;<code>interrupt()</code>：中断线程（不是 中止）&#x3D;&#x3D;</p></li></ul><h4><span id="x3dx3djava中断线程interruptx3dx3d">&#x3D;&#x3D;Java中断线程（interrupt）&#x3D;&#x3D;</span></h4><h4><span id="概念">概念</span></h4><blockquote><p>当 <code>A</code> 线程想让 <code>B</code> 线程终止运行，应该怎么办呢？在Java之前的版本中，可以利用 <code>stop</code> 方法来使一个线程终止，但是该方法已经被废弃了，不要这么用。</p><p>现在可以在 <code>A</code> 线程中调用 <code>B</code> 线程的 <code>interrupt()</code> 方法，来使 <code>B</code> 线程知道有线程想要使自己终止，&#x3D;&#x3D;但是是否终止取决于 <code>B</code> 线程自己，<code>B</code> 完全可以不理会这个终止请求。&#x3D;&#x3D;（&#x3D;&#x3D;当然最好不要这么做&#x3D;&#x3D;）下面我们来看看细节。</p></blockquote><h4><span id="相关函数介绍">相关函数介绍</span></h4><blockquote><ul><li><code>void interrupt()</code></li></ul><p>中断这个线程。</p><ul><li><code>boolean isInterrupted()</code></li></ul><p>检查这个线程是否被中断。</p><ul><li><p><code>static boolean interrupted()</code></p><p>检查<strong>当前线程</strong>是否被中断，该方法在调用后还会清除该线程的中断状态。</p></li></ul></blockquote><h4><span id="示例解释">示例解释</span></h4><blockquote><ul><li><p><code>boolean isInterrupted()</code> 方法和 <code>static boolean interrupted()</code> 方法区别</p><p>如下代码首先测试 <code>boolean isInterrupted()</code> 方法。</p><pre><code class="java">public static void main(String[] args) &#123;    Thread.currentThread().interrupt();    System.out.println(Thread.currentThread().isInterrupted()); // true    System.out.println(Thread.currentThread().isInterrupted()); // true&#125;</code></pre></li></ul><pre><code class="java">会发现两次输出都是 `true` 。接着测试 `static boolean interrupted()` 方法。    public static void main(String[] args) &#123;        Thread.currentThread().interrupt();        System.out.println(Thread.interrupted());  // true        System.out.println(Thread.interrupted());  // false    &#125;</code></pre><p>测试发现第一次输出是 true ，而第二次输出是 false ，说明&#x3D;&#x3D;这个方法在调用后会清除线程的中断状态&#x3D;&#x3D;。</p><ul><li><p>中断且不理会</p><p>这里我们让主线程中断线程 <code>aThread</code> ，<u>但是 <code>aThread</code> 线程<strong>不理会</strong></u>(最好不要怎么做)，看会发生什么。代码如下：</p><pre><code class="java">public static void main(String[] args)&#123;    // create and start aThread    Runnable r = () -&gt; &#123;//一个lamda表达式，表示的是实现Runable接口的一个对象，Runable是函数式接口，只有一个抽象方法run。        while (true) &#123;            System.out.println(&quot;I&#39;m alive&quot;);        &#125;    &#125;;    Thread aThread = new Thread(r);    aThread.start();                    // interrupt aThread    aThread.interrupt();&#125;</code></pre></li></ul><p>测试发现 <code>aThread</code> 线程的运行没有任何影响，还是一直输出 <code>I&#39;m alive</code> 。</p><ul><li><p>一般用法</p><p>既然如果中断不被处理的话不会有任何效果，按应该怎么响应中断呢？应该在线程中一直判断线程是否被中断，如果线程被中断，应该根据当前任务的要求选择接下来的工作，在结束线程前关闭必要的资源。看下面的代码。</p><pre><code class="java">public static void main(String[] args)&#123;    // create and start aThread    Runnable r = () -&gt; &#123;        try &#123;            while (!Thread.currentThread().isInterrupted()) &#123;                //do work                System.out.println(&quot;I&#39;m alive&quot;);    //当前线程未中断            &#125;            System.out.println(&quot;I ll die&quot;);//线程被中断了        &#125; finally &#123;            // close some resources        &#125;                    &#125;;    Thread aThread = new Thread(r);//静态代理    aThread.start();                    try &#123;        Thread.currentThread().sleep(1);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    // interrupt aThread//中断进程    aThread.interrupt();&#125;</code></pre></li></ul><p>线程在没有被中断时，一直执行自己的任务，当被中断时，就会跳出循环，&#x3D;&#x3D;并在 <code>finally</code> 中关闭相应的资源和并做一些清理操作&#x3D;&#x3D;。</p><ul><li><p>线程被阻塞时</p><p>上面的情况在线程没有被阻塞时可以运行，但是&#x3D;&#x3D;当线程被阻塞时，线程是无法检查线程的中断状态的，&#x3D;&#x3D;所以引入了 <code>InterruptedException</code> 异常帮助中断阻塞。不同的阻塞还有一些区别，具体如下。</p><ul><li><p>线程被 <code>sleep()</code> 方法或 <code>join()</code> 方法阻塞时</p><p>如下代码：</p><pre><code class="java">public static void main(String[] args) &#123;    // create and start aThread    Runnable r = () -&gt; &#123;        try &#123;            Thread.currentThread().sleep(5000);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;die&quot;);            e.printStackTrace();        &#125; finally &#123;            // close some resources        &#125;    &#125;;    Thread aThread = new Thread(r);    aThread.start();                                    try &#123;        Thread.currentThread().sleep(500);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    // interrupt aThread    aThread.interrupt();&#125;</code></pre></li></ul></li></ul><p>在这些线程上调用 <code>interrupt()</code> 方法时，<code>sleep()/join()</code> 方法会被中断不再执行，它会清除中断状态并直接跳入 <code>catch</code> 块中执行，所以如果在循环中调用了 <code>sleep()</code> 方法，就不要去检测中断状态了，因为会直接跳入 <code>catch</code> 块中执行，应该直接捕获 <code>InterruptedException</code> 异常。</p><ul><li><p>线程被 <code>wait()</code> 方法阻塞时</p><p>线程被 <code>wait()</code> 方法阻塞时，调用 <code>interrupt()</code> 方法的效果和线程被 <code>sleep()</code> 方法或 <code>join()</code> 方法阻塞的效果基本一样，它也会清除中断状态并跳入 <code>catch</code> 块中去执行。但是有一点点不同，就是被 <code>interrupt()</code> 调用的线程会先去获取调用 <code>wait()</code> 方法的对象的锁，获取完对象的锁之后才会抛出异常并进入 <code>catch</code> 块中去执行，如果获得不到锁，那么就无法抛出异常，也无法进入 <code>catch</code> 块中。如下代码，首先 <code>aThread</code> 获得锁并 <code>wait</code>（注意 <code>wait()</code> 方法会释放锁），然后 <code>bThead</code> 获得锁，但是 <code>b</code> 永远不释放锁，在 <code>aThread</code> <code>wait</code> 的时候，主线程调用 <code>interrupt()</code> 去中断 <code>aThread</code>，但是由于 <code>aThread</code> 永远无法获得锁，所以它不会抛出异常，也不会进入到 <code>catch</code> 块中运行。代码如下。</p></li></ul><pre><code class="java">        public static void main(String[] args) &#123;            Runnable r = () -&gt; &#123;                try &#123;                    synchronized (o) &#123;                        System.out.println(&quot;aThread get lock&quot;);                        o.wait(10000);                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace(); // can&#39;t come here                &#125;             &#125;;            Thread aThread = new Thread(r);            aThread.start();            Runnable r2 = () -&gt; &#123;                try &#123;                    Thread.currentThread().sleep(250);                    synchronized (o) &#123;                        System.out.println(&quot;bThread get lock&quot;);                        while (true) &#123;                        &#125;                    &#125;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;;            Thread bThread = new Thread(r2);            bThread.start();            try &#123;                Thread.currentThread().sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            // interrupt aThread            aThread.interrupt();        &#125;</code></pre><ul><li><p>其他阻塞</p><p>在 API 中还有其他的阻塞情况。如果线程被 <code>InterruptibleChannel</code> 的IO操作阻塞，则这个管道会被关闭，线程的中断状态会被置位，同时会抛出 <code>ClosedByInterruptException</code> 异常。</p><p>如果线程被 <code>Selector</code> 阻塞，则这个线程的中断状态会被置位，并且立即从选择操作中返回，可能返回一个非零值，就像 <code>selector</code> 的 <code>wakeup</code> 方法被调用一样。</p><p>这两种阻塞我都没有用过（太菜了），所以没有写代码去测试，之后遇到我会去测试。</p><p>除了以上这几种情况，其他情况都会置位线程的中断状态。</p></li></ul></blockquote><ul><li><p>&#x3D;&#x3D;<code>yield()</code>：<strong>线程的礼让</strong>。让出 CPU 让其他线程执行。因为礼让的时间不确定，所以不一定礼让成功。&#x3D;&#x3D;</p><p>本质是 RUNNING 切换为 READY，即让当前线程放弃执行权</p></li><li><p><code>wait()</code>：导致当前线程等待</p><p>直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法才能唤醒此线程</p><p><code>notify()</code>、<code>notifyAll()</code>：唤醒因 <code>wait()</code> 阻塞的线程。</p><p>这些方法（<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>）只能在 synchrnized 方法或代码块中调用</p></li><li><p>&#x3D;&#x3D;<code>join()</code>：<strong>线程的插队</strong>。插队的线程一旦插入成功，则必定先执行完插队线程的所有任务然后再执行其他进程&#x3D;&#x3D;，在另一个进程调用。</p><p>将导致其他线程的等待，直到 <code>join()</code> 方法的线程结束</p><p><code>join(long timeout)</code>：join，但是时间到后也能结束其他线程的等待</p></li><li><p><code>isAlive()</code>：测试当前线程是否在活动</p></li><li><p><code>Thread.currentThread()</code>：引用当前运行中的线程</p></li></ul><h3><span id="1626-用户线程和x3dx3d守护线程x3dx3d">16.2.6 用户线程和&#x3D;&#x3D;守护线程&#x3D;&#x3D;</span></h3><blockquote><p>&#x3D;&#x3D;如果希望当main线程结束后，其他子进程自动结束，只需要将其设置为守护进程。&#x3D;&#x3D;</p><p>注意如果有另外一个子进程不是守护进程却在main进程结束时仍然运行，那么这个设置的守护进程也不会随着main进程终止而终止，将其设置为守护进程属于无效操作。</p></blockquote><ul><li><p>用户线程：也叫工作线程。当线程任务执行完毕或通知方式结束</p></li><li><p>守护线程：一般是为工作线程服务的。&#x3D;&#x3D;当所有线程结束，守护线程自动结束&#x3D;&#x3D;</p><p>  常见的守护线程：<strong>垃圾回收机制</strong></p><blockquote><pre><code class="java">Thread thraed = new Thread(bullet);thread.setDeamon(true);//将子线程设置为主线程的守护线程thread.start();</code></pre></blockquote></li></ul><h3><span id="x3dx3d1627-线程的生命周期x3dx3d">&#x3D;&#x3D;16.2.7 线程的生命周期&#x3D;&#x3D;</span></h3><p>线程的状态有</p><ul><li><p>NEW：尚未启动</p></li><li><p>RUNNABLE：在 JVM 中执行的线程</p><p>  可细分为 READY 和 RUNNING，这个状态由内核决定。</p></li><li><p>BLOCKED：被阻塞等待监视器锁定的线程</p></li><li><p>WAITING：正等待另一个线程执行特定动作的线程</p></li><li><p>TIMED_WAITING：正等待另一个线程执行特定动作达到等待时间的线程</p></li><li><p>TERMINATED：已退出的线程</p></li></ul><p>&#x3D;&#x3D;重要的图：&#x3D;&#x3D;</p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310122023919.png" alt="image-20231012202310763"></p><h2><span id="x3dx3d163-线程的互斥x3dx3d">&#x3D;&#x3D;16.3 线程的互斥&#x3D;&#x3D;</span></h2><blockquote><p>在多线程编程，&#x3D;&#x3D;一些敏感数据不允许被多个线程<strong>同时访问</strong>&#x3D;&#x3D;。此时就用同步访问技术，保证数据在任意时刻，&#x3D;&#x3D;最多有一个线程同时访问&#x3D;&#x3D;，以保证数据的完整性。</p><p>也可以这样理解：<strong>线程同步</strong>，即当有一个线程对内存进行操作时，其他线程都不能对这个内存地址进行操作（被阻塞），直到该线程完成操作，再让下一线程进行操作。</p></blockquote><h3><span id="1631-互斥锁">16.3.1 互斥锁</span></h3><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310122132570.png" alt="image-20231012213214200"></p><p>在对象上加了一把锁，这把锁在同一时刻只能由一个线程(比如t1)可以得到，如果一个t1得到这把锁，可以对对象数据进行操作，操作结束把锁返还给对象，然后对象又上了锁，接着其他进程(t2、t3)和获得过这把锁的进程t1继续争夺锁，在这一时刻进程t1还可以继续争夺，所以这把锁也加不公平锁（&#x3D;&#x3D;有可能会出现锁一直被同一个对象访问的情况，可以在争夺锁的开始休眠一段时间)&#x3D;&#x3D;</p><pre><code class="java">while (true) &#123;    try &#123;        Thread.sleep(100);//先让进程等待一段时间再开始抢锁，如果休眠放在锁里，当休眠结束后，线程1又去争夺到这把锁，所以一直是线程1在得这把锁    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    synchronized (User.class) &#123;        if (money &lt;= 0) &#123;            break;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;在取钱，剩余&quot; + (money -= 1000));    &#125;&#125;</code></pre><blockquote><p>在 Java 语言中，引入了 “对象互斥锁” 的概念，也称为监视器，来保证&#x3D;&#x3D;共享数据操作的完整性&#x3D;&#x3D;</p><p>&#x3D;&#x3D;每个对象都对应一个可称为 “互斥锁” 的标记，&#x3D;&#x3D;这个标记用来保证在任一时刻都只能有一个线程访问对象。使用实现接口Runable的方式，通过静态代理实现对同一个共享数据的操作。</p><pre><code class="java">假如有三个售票口售票，一共有100张票，当票数小于0时则售票结束，如果没有实现同步访问技术，就会出现这种情况：售票口1、售票口2和售票口3同时检查票的张数，若此时票还剩余1张，售票口1判断符合条件将剩余的一张票售卖出去（此时的票数为0了），而其他2个售票口则会误以为此时的票数还为1张。接着继续售卖，就会导致超卖的情况(即票数为负数)Tik tik = new Tik();new Thread(tik).start();new Thread(tik).start();new Thread(tik).start();//这里不能用通过继承Thread的方式开启进程，用继承后的锁不是一个锁，因为每个对象对应一把锁,所以在操作的过程其实并没有起到锁的作用，如果要使用继承的方式实现同步方法，可以在在静态方法或代码块中实现当前类的锁，所有的对象就共用同一把锁了。new Tik().start();new Tik().start();new Tik().start();</code></pre><p>Java 语言中，有 2 种方式实现<strong>互斥锁</strong>：</p><ul><li><p>用关键字 volatile 声明一个共享数据（变量）。一般很少使用该关键字</p></li><li><p>用关键字 synchronized 声明共享数据的一个方法或一个代码</p><p>  <u>在前面的<strong>售票案例</strong>中&#x3D;&#x3D;只有一个线程卖票&#x3D;&#x3D;有两种可能，&#x3D;&#x3D;1.线程锁加在run方法，2.sleep不在run方法&#x3D;&#x3D;</u></p></li></ul><p>同步的局限性：导致程序的执行<u>效率要降低。</u></p><p><strong>非静态</strong>的对象，&#x3D;&#x3D;同步方法的锁可以是 <strong>this</strong>&#x3D;&#x3D;，也可以是其他对象，比如说这个对象是类的一个属性，也可以表示当前对象的锁（&#x3D;&#x3D;要求是同一对象的&#x3D;&#x3D;（被多个线程操作）），适用于实现Runnable接口的类对象，使用的是<strong>”对象锁“</strong></p><ol><li><p>添加在方法上，同步方法</p><pre><code class="java">public sychronized  void m1()&#123;&#125;</code></pre></li><li><p>添加在方法内，同步代码块</p><pre><code class="java">public void m1()&#123;    sychronized(this)&#123;//this可以传递为        ...    &#125;&#125;</code></pre></li></ol><p><strong>静态</strong>对象，&#x3D;&#x3D;同步方法的锁为<strong>当前类</strong>本身&#x3D;&#x3D;，适用于使用继承Thread的方式，多个当前类对象都使用<strong>‘’类的锁‘’。</strong></p><ol><li><p>添加在方法上，方法叫同步方法</p><pre><code class="java">public synchronized static void m1()&#123;&#125;</code></pre></li><li><p>添加在方法内，叫同步代码块</p><pre><code class="java">public static void m2()&#123;   synchronized (当前类.class)&#123;//这里括号不能再填this了，因为是静态方法(只能访问静态域)，所以是静态锁   &#125;&#125;</code></pre></li></ol></blockquote><ol><li><p><strong>同步代码块</strong>(尽量使用)</p><pre><code class="java">synchronized (对象) &#123;//得到对象的锁，才能操作同步代码    需要被同步代码;&#125;</code></pre><p> 在第一个线程持有锁定标记时，如果另一个线程企图执行该代码块语句，将从对象中索取锁定标记。</p><p> 因为此时该标记不可得，故该线程不能继续执行，而是加入等待队列。</p><p> 程序运行完 synchronized 代码块后，锁定标记会被自动返还。即使该同步代码块执行过程中抛出异常也是如此。一个线程多次调用该同步代码块的场合，也会在最外层执行完毕后正确返还。</p></li><li><p><strong>放在方法声明中</strong>，表示整个方法为<strong>同步方法</strong></p><p> 因为 &#x3D;&#x3D;synchronized 语句的参数必须是 this&#x3D;&#x3D;，因此允许下面这种简洁的写法：</p><pre><code class="java">public synchronized void method()&#123;    代码;&#125;</code></pre></li></ol><h4><span id="售票代码">售票代码</span></h4><pre><code class="java">public class Tikets &#123;    public static void main(String[] args) &#123;//        Tik2 tik1 = new Tik2();//        new Thread(tik1).start();//        new Thread(tik1).start();//        new Thread(tik1).start();        new Tik().start();        new Tik().start();        new Tik().start();    &#125;&#125;class Tik2 implements Runnable &#123;//用实现接口的方式，每个对象对应一把锁    private  int tikits = 10;    boolean loop = true;                                                        //在synchronnized只要传一个属于当前对象的属性也可以当作锁(属性必须是个对象)                                                    //这样做还需要将run方法设置为同步方法才可以防止出现票超卖的情况(即在run方法签名处添加synchronized设置为同步方法)    public synchronized void m() &#123;/*synchronized (Integer.valueOf(tikits))&#123;                                                            if (tikits &lt;= 0) &#123;...&#125;                                                                ...                                                                System.out.println(...);&#125;                        */         try &#123;            Thread.sleep(50);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        if (tikits &lt;= 0) &#123;            System.out.println(&quot;售票结束&quot;);            loop = false;            return;        &#125;            System.out.println(Thread.currentThread().getName() + &quot;剩余票数&quot; + (--tikits));    &#125;    @Override    public void run() &#123;//若采用第二种方式就将其改为public synchronized void run()        while (loop) &#123;            m();        &#125;    &#125;&#125;class Tik extends Thread&#123;//用继承的方式，同步方法的锁为类本身，也可以通过传递一个本类静态属性(必须是个对象)给synchronized(类的静态属性)的方式来添加锁，实质也是实现的”类的锁“;    private static int tikits = 10;    static boolean loop = true;    public synchronized static void m() &#123;//方式2：改为synchronized(类的静态属性)&#123;方法内部的代码...&#125;        if (tikits &lt;= 0) &#123;            System.out.println(&quot;售票结束&quot;);            loop = false;            return;        &#125;        try &#123;            Thread.sleep(50);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + &quot;剩余票数&quot; + (--tikits));    &#125;    @Override    public void run() &#123;// 方式2：synchronized (Integer.valueOf(tikits)) &#123;...&#125;        while (loop) &#123;            m();        &#125;    &#125;&#125;</code></pre><p>总之，需要确保检查使用的是同一把锁，否则都会造成超卖的情况。如果要使用类的锁(&#x3D;&#x3D;继承Thread的做法合适&#x3D;&#x3D;)，则将其置为静态同步方法或者&#x3D;&#x3D;静态同步代码块&#x3D;&#x3D;。如果要使用对象锁(&#x3D;&#x3D;实现Runnable接口的做法合适&#x3D;&#x3D;)就将方法置为非静态同步方法或非静态同步代码块。&#x3D;&#x3D;建议在实际中选择同步代码块(除了必须使用在方法上除外)，范围越小效率就越高。&#x3D;&#x3D;</p><h3><span id="1632-线程死锁">16.3.2 线程死锁</span></h3><blockquote><p>多个线程都占用了对方的资源，不肯相让，就导致了死锁。编程时要避免死锁的产生。</p></blockquote><ul><li><p>以下操作会释放锁</p><ol><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步方法、同步代码块中遇到 <code>break</code>、<code>return</code></li><li>当前线程在同步方法、同步代码块中出现了未处理的 <code>Error</code></li><li>当前线程在同步方法、同步代码块中执行了 <code>wait()</code> 方法，当前线程暂停，并释放锁</li></ol></li><li><p>以下操作不会释放锁</p><ol><li><p>执行同步方法、同步代码块时，程序调用 <code>Thread.sleep()</code> 或 <code>Thread.yield()</code> 方法暂停当前线程的执行，不会释放锁</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的 <code>suspend()</code> 方法将该线程挂起，该线程不会释放锁</p></li></ol><p>  所以，应尽量避免使用 <code>suspend()</code> 和 <code>resume()</code> 来控制线程，它们是是<strong>过时的方法</strong>。</p><p>  &#x3D;&#x3D;尽量避免synchronized嵌套使用。&#x3D;&#x3D;</p><pre><code class="java">public class DeadLock_ &#123;    public static void main(String[] args) &#123;        //模拟死锁现象        DeadLockDemo A = new DeadLockDemo(true);        A.setName(&quot;A线程&quot;);        DeadLockDemo B = new DeadLockDemo(false);        B.setName(&quot;B线程&quot;);        A.start();        B.start();    &#125;&#125;//线程class DeadLockDemo extends Thread &#123;    static Object o1 = new Object();// 保证多线程，共享一个对象,这里使用static    static Object o2 = new Object();    boolean flag;    public DeadLockDemo(boolean flag) &#123;//构造器        this.flag = flag;    &#125;    @Override    public void run() &#123;        //下面业务逻辑的分析        //1. 如果flag 为 T, 线程A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁        //2. 如果线程A 得不到 o2 对象锁，就会Blocked        //3. 如果flag 为 F, 线程B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁        //4. 如果线程B 得不到 o1 对象锁，就会Blocked        if (flag) &#123;            synchronized (o1) &#123;//对象互斥锁, 下面就是同步代码                System.out.println(Thread.currentThread().getName() + &quot; 进入1&quot;);                synchronized (o2) &#123; // 这里获得li对象的监视权                    System.out.println(Thread.currentThread().getName() + &quot; 进入2&quot;);                &#125;                            &#125;        &#125; else &#123;            synchronized (o2) &#123;                System.out.println(Thread.currentThread().getName() + &quot; 进入3&quot;);                synchronized (o1) &#123; // 这里获得li对象的监视权                    System.out.println(Thread.currentThread().getName() + &quot; 进入4&quot;);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></li></ul><h2><span id="164-线程的同步">16.4 线程的同步</span></h2><blockquote><p>Java 中，可以使用 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 来协调线程间的运行速度关系。这些方法都被定义在 java.lang.Object 中</p><p>Java 中的每个对象实例都有两个线程队列和它相连。一个用以实现等待锁定标志的线程，另一个用来实现 <code>wait()</code> 和 <code>notify()</code> 的交互机制</p></blockquote><ul><li><p><code>wait()</code>：让当前线程释放所有其持有的 “对象互斥锁”，进入等待队列</p></li><li><p><code>notify()</code>、<code>notifyAll()</code>：唤醒一个或所有在等待队列中等待的线程，并将他们移入同一个等待 “对象互斥锁” 的队列。</p><p>  执行这些方法时如果没有等待中的线程，则其不会生效，也不会被保留到以后再生效</p></li></ul><pre><code class="java">synchronized (key) &#123;    if (key.value == 0) key.wait();    key.value--;&#125;synchronized (key) &#123;    key.value++;    key.nitifyAll();&#125;</code></pre><p>因为调用这些方法时必须持有对象的 “对象互斥锁”，所以上述方法只能在 synhronized 方法或代码块中执行。</p><h1><span id="项目-坦克大战">项目-坦克大战</span></h1>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23 JDBC 和数据库连接池</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/23%20JDBC/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/23%20JDBC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="23-jdbc-和数据库连接池">23 JDBC 和数据库连接池</span></h1><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311042134382.png" alt="bieming"></p><blockquote><p>JDBC：Java 提供的一套用于操作数据库的接口 API。它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作，相关类和接口在<code>java.sql</code>与<code>javax.sql</code>包中，Java 程序员只需要面向该接口即可连接任何提供了 JDBC 驱动程序的数据库，完成对数据库的各种操作。不同的数据库厂商，需要针对这套接口提供不同的实现。</p></blockquote><p><strong>JDBC 程序编写步骤（示范）：</strong></p><blockquote><pre><code class="java">/* [0] 前置操作 */    /* [1] 注册驱动 */Driver driver = new com.mysql.cj.jdbc.Driver();    /* [2] 获取连接 */String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;//melody是创建的一个数据库Properties properties = new Properties();//user和password的写法是固定的properties.setProperty(&quot;user&quot;, &quot;root&quot;);properties.setProperty(&quot;password&quot;, &quot;******&quot;);Connection connect = driver.connect(url, properties);    /* [3] 执行语句 */String sql = &quot;insert into customer (customer_id,name,card_id) values(0004,&#39;赫尔&#39;,&#39;00000000000000000O&#39;)&quot;;Statement statement = connect.createStatement();int rows = statement.executeUpdate(sql);System.out.println(rows);    /* [4] 释放资源 */statement.close();connect.close();</code></pre><ol><li><p>&#x3D;&#x3D;前置操作：将 <code>mysql-connector-java-8.0.27.jar</code> 该文件拷贝到项目目录下，选中后右键选择 <code>Add as library</code>&#x3D;&#x3D;</p></li><li><p>注册驱动：加载 <code>Driver</code> 类</p><p> 这里我导入了 <code>com.mysql.cj.jdbc.Driver</code>。根据前面的 <code>jar</code> 包的版本不同，应该导入的路径也会不同。</p><p> 旧版本的 <code>jar</code> 包可能应该导入 <code>com.mysql.jdbc.Driver</code> 这个包。</p></li><li><p>获取连接：得到 <code>Connection</code></p><blockquote><pre><code class="java">String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;</code></pre><p>这里表示进入 <code>melody</code> 这个数据库。</p></blockquote></li><li><p>执行语句：发送 SQL 命令给 MySQL 执行</p><blockquote><pre><code class="java">int rows = statement.executeUpdate(sql);</code></pre><p>如果是 dml 语句，这里返回的 rows 是影响的行数。返回 0 表示失败。</p></blockquote></li><li><p>释放资源：关闭相关连接<strong>（切记！）</strong></p></li></ol></blockquote><h2><span id="231-连接数据库的-5-种方式">23.1 连接数据库的 5 种方式</span></h2><ul><li><p>方式 1：直接创建 <code>Driver</code>，调用 <code>driver.connet(url, properties);</code></p><p>  这个方法就是 [23.0] 示范的方法</p><blockquote><pre><code class="java">Driver driver = new com.mysql.cj.jdbc.Driver();String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;Properties properties = new Properties();properties.setProperty(&quot;user&quot;, &quot;root&quot;);properties.setProperty(&quot;password&quot;, &quot;******&quot;);Connection connect = driver.connect(url, properties);</code></pre></blockquote></li><li><p>方式 2：使用反射加载 <code>Driver</code> 类</p><p>  这个方式是动态加载，更加灵活，减少依赖性。</p><blockquote><pre><code class="java">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);Driver driver = (Driver) aClass.newInstance();Properties properties = new Properties();properties.setProperty(&quot;user&quot;, &quot;root&quot;);properties.setProperty(&quot;password&quot;, &quot;******&quot;);Connection connect = driver.connect(url, properties);</code></pre></blockquote></li><li><p>方式 3：使用 <code>DriverManager</code> 替代 <code>Driver</code> 进行统一管理</p><p>  这个方式扩展性更好，更加清晰</p><blockquote><pre><code class="java">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);Driver driver = (Driver) aClass.newInstance();String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;String name = &quot;root&quot;;String password = &quot;******&quot;;DriverManager.registerDriver(driver);Connection connection = DriverManager.getConnection(url, name, password);</code></pre><p>这里，<code>DriverManager.getConnetion()</code> 有三种方法。分别是：</p><ul><li><code>getConnetion(url);</code></li><li><code>getConnetion(url, properties);</code></li><li><code>getConnetion(url, name, password);</code></li></ul></blockquote></li><li><p>&#x3D;&#x3D;方式 4：使用 <code>Class.forName()</code> 自动完成注册驱动，实际开发中这种方式用的最多，推荐使用&#x3D;&#x3D;</p><blockquote><pre><code class="java">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);//可以不加引用String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;String name = &quot;root&quot;;String password = &quot;******&quot;;Connection connection = DriverManager.getConnection(url, name, password);</code></pre><p><code>Class.forName()</code> 在加载 <code>Driver</code> 类时，会自动完成注册。</p></blockquote><p>  原理：</p><blockquote><p><code>Driver</code> 类的源码中有这样一段</p><pre><code class="java">static &#123;     try &#123;         DriverManager.registerDriver(new Driver());     &#125; catch (SQLException var1) &#123;         throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);     &#125;&#125;</code></pre><p>这个静态代码块在类加载时会被执行。</p></blockquote><blockquote><p>另外，其实&#x3D;&#x3D;不执行 <code>Class.forName(...);</code> 语句的场合，也能正确获取 <code>Connection</code>。&#x3D;&#x3D;</p><p>这是因为 JDK 1.5 以后使用了 jdbc4。这个场合，系统会自动调用 jar 包下 <code>META-INF\services\java.sql.Driver</code> 这个文件中的类名称去注册。</p><p>……打开上述文件看看，里面赫然写着：<code>com.mysql.cj.jdbc.Driver</code></p><p>即使如此，还是建议写上 <code>Class.forName(...)</code> 语句！</p></blockquote></li><li><p>&#x3D;&#x3D;方式 5（推荐）：在方式 4 的基础上，使用配置文件，连接数据库更灵活&#x3D;&#x3D;。</p></li></ul><pre><code class="java">这种方式是实际开发最常用的方式。&gt; 配置文件（创建 src\mysql.properties）：&gt;&gt; ```properties&gt; url=jdbc:mysql://localhost:3306/melody&gt; user=root&gt; password=******&gt; driver=com.mysql.cj.jdbc.DriverPROPERTIES&gt; ```&gt;&gt; 代码：&gt;&gt; ```java    /*得到配置文件信息*/&gt; Properties pro = new Properties();&gt; pro.load(new FileInputStream(&quot;src\\mysql.properties&quot;))&gt; String url = pro.getProperties(&quot;url&quot;);&gt; String user = pro.getProperties(&quot;user&quot;);&gt; String password = pro.getProperties(&quot;password&quot;);&gt; String driver = pro.getProperties(&quot;driver&quot;);/*注册驱动*/&gt; Class&lt;?&gt; aClass = Class.forName(driver);&gt; Connection connection = DriverManager.getConnection(url, user, password);&gt; ```</code></pre><h2><span id="232-reaultset-结果集">23.2 <code>ReaultSet</code> 结果集</span></h2><blockquote><p>ResultSet：表示数据库结果集的数据表。通常通过执行查询数据库的语句生成。</p><p>ResultSet 对象保持一个光标指向其当前的数据行。该光标的初始位置在第一行之前。调用 next 方法将光标下移，移动到末端的场合会返回 false。</p></blockquote><p><strong>如何取出数据（示例）：</strong></p><pre><code class="java">String sql = &quot;select * from customer&quot;;ResultSet resset = statement.executeQuery(sql);while (resset.next()) &#123;    int id = resset.getInt(1);    String name = resset.getString(2);    String sex = resset.getString(5);    String card_id = resset.getString(6);    System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + sex + &quot;\t&quot; + card_id);&#125;</code></pre><p>其中 <code>String sex = resset.getString(5);</code> 表示取出该行数据的第 5 列的字符串数据。</p><p>ResultSet 的数据是以类似二维数组的形式保存在对象中。这不难理解，毕竟表格是二维的嘛。</p><h2><span id="x3dx3d233-statementx3dx3d">&#x3D;&#x3D;23.3 <code>Statement</code>&#x3D;&#x3D;</span></h2><blockquote><p><code>Statment</code> 对象用于执行静态 SQL 语句，并返回其生成的结果的对象</p><p>在连接建立后，需要访问数据库、执行命名或 SQL 语句，有如下方式：</p><ul><li><code>Statment</code>（存在 SQL 注入问题，在实际开发中基本不使用）</li><li><code>PerparedStatement</code>（预处理）</li><li><code>CallableStatement</code>（存储过程）</li></ul><p>案例：</p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311051151379.png" alt="image-20231105115143277"></p><p>SQL 注入：利用某些系统没有对用户输入的数据进行充分的检查，故意注入非法的 SQL 语句段或命令，恶意攻击数据库。</p><p>使用 <code>PreparedStatement</code> 可以防范 SQL 注入</p></blockquote><h3><span id="2331-preparedstatement-预处理">23.3.1 <code>PreparedStatement</code> 预处理</span></h3><pre><code class="java">    /* [1] */String sql = &quot;select * from customer where customer_id = ? and name = ?&quot;;PreparedStatement ps = connection.prepareStatement(sql);    /* [2] */ps.setInt(1, 0);ps.setString(2, &quot;萝茵&quot;);    /* [3] */ResultSet rs = ps.executeQuery();</code></pre><ol><li><p><code>PreparedStatement</code> 执行的 SQL 语句的参数用 <code>?</code> 表示。</p></li><li><p>调用方法设置 SQL 语句中的参数。</p><p> 这些方法的两个参数中，第一个是设置的参数的索引，第二个是设置值</p></li><li><p>调用 <code>executeQuery()</code> 返回 <code>ResultSet</code> 对象。或者调用 <code>executeUpdate()</code> 执行增删改</p><p> 这里，调用的方法不需要再传入参数sql进去，而且如果添加了“？”作为条件，传入参数会导致语法错误。</p></li></ol><p><strong>预处理的好处</strong></p><ol><li>不再使用拼接语句，增加代码可读性，减少语法错误</li><li>解决了 SQL 注入问题</li><li>大大减少了编译次数，效率提高</li></ol><table><thead><tr><th>类 &#x2F; 接口</th><th>方法</th></tr></thead><tbody><tr><td>DriverManager 驱动管理类</td><td>getConnection(url, user, pwd) 获取连接</td></tr><tr><td>Connection 接口</td><td>createStatement() 创建 Statement 对象</td></tr><tr><td></td><td>preparedStatement(sql) 生成预处理 PreparedStatement 对象</td></tr><tr><td>Statement 接口</td><td>executeUpdate(sql) 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery(sql) 执行查询语句，返回 ResultSet,注意不能对PreparedStatement或CallableStatement调用此方法。</td></tr><tr><td></td><td>execute(sql) 执行任意 SQL 语句，返回布尔值</td></tr><tr><td>PreparedStatement 接口</td><td>executeUpdate() 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery() 执行查询语句，返回 ResultSet</td></tr><tr><td></td><td>execute() 执行任意 SQL 语句，返回布尔值</td></tr><tr><td></td><td>setXXX(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td></td><td>setObject(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td>ResultSet 结果集</td><td>next() 向下移动一行。没有下一行的场合返回 false</td></tr><tr><td></td><td>previous() 向上移动一行。没有上一行的场合返回 false</td></tr><tr><td></td><td>getXXX(int)、getXXX(name) 返回 int 列 &#x2F; name 列的值</td></tr><tr><td></td><td>getObject(int)、getObject(name) 返回 int 列 &#x2F; name 列的值</td></tr></tbody></table><h2><span id="x3dx3d234-jdbcutilsx3dx3d">&#x3D;&#x3D;23.4 JDBCUtils&#x3D;&#x3D;</span></h2><blockquote><p>实际操作中，<strong>由于获取连接 和 释放资源 操作经常使用，所以会增加代码的冗余度</strong>，可以把这些操作统一封装成工具类 JDBCUtils，这样当需要数据库连接进行数据库操作的时候只需要通过这个JDBCUtils就可以获取。</p></blockquote><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311051551103.png" alt="image-20231105155127050" style="zoom:50%;"><p><strong>JDBCUtils.java</strong></p><pre><code class="java">package com.hspedu.jdbc.utils;import java.io.FileInputStream;import java.io.IOException;import java.sql.*;import java.util.Properties;/** * @author 韩顺平 * @version 1.0 * 这是一个工具类，完成 mysql的连接和关闭资源 */public class JDBCUtils &#123;    //定义相关的属性(4个), 因为只需要一份，因此，我们做出static    private static String user; //用户名    private static String password; //密码    private static String url; //url    private static String driver; //驱动名    //在static代码块去初始化    static &#123;        try &#123;            Properties properties = new Properties();            properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));            //读取相关的属性值            user = properties.getProperty(&quot;user&quot;);            password = properties.getProperty(&quot;password&quot;);            url = properties.getProperty(&quot;url&quot;);            driver = properties.getProperty(&quot;driver&quot;);        &#125; catch (IOException e) &#123;            //在实际开发中，我们可以这样处理            //1. 将编译异常转成 运行异常            //2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便.            throw new RuntimeException(e);//[1]        &#125;    &#125;    //连接数据库, 返回Connection    public static Connection getConnection() &#123;        try &#123;            return DriverManager.getConnection(url, user, password);        &#125; catch (SQLException e) &#123;            //1. 将编译异常转成 运行异常            //2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便.            throw new RuntimeException(e);//[1]        &#125;    &#125;    //关闭相关资源    /*        1. ResultSet 结果集        2. Statement 或者 PreparedStatement        3. Connection        4. 如果需要关闭资源，就传入对象，否则传入 null     */    public static void close(ResultSet set, Statement statement, Connection connection) &#123;        //判断是否为null        try &#123;            if (set != null) &#123;                set.close();            &#125;            if (statement != null) &#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            //将编译异常转成运行异常抛出            throw new RuntimeException(e);//[1]        &#125;    &#125;&#125;</code></pre><ol><li>实际开发中，可以把编译异常转换为运行异常。这样，调用者可以自行选择捕获异常还是默认处理。</li></ol><h2><span id="x3dx3d235-事务x3dx3d">&#x3D;&#x3D;23.5 事务&#x3D;&#x3D;</span></h2><blockquote><p>事务：JDBC 程序中，当一个 <code>Connection</code> 对象创建时，默认情况下会自动提交事务。为了让多个 SQL 语句一体执行，需要使用事务。</p></blockquote><pre><code class="java">Connection connection = null;try &#123;    connection = JDBCUtils.getConnection();    connection.setAutoCommit(false);//[1] 取消自动提交事务    String sql = &quot;insert into actor values(9, &#39;赫尔萝茵&#39;)&quot;;    PreparedStatement preparedStatement = connection.prepareStatement(sql);    preparedStatement.executeUpdate();    sql = &quot;delete from actor where name = &#39;萝茵&#39; and id &gt; (select * from (select min(id) from actor where name = &#39;萝茵&#39;) a)&quot;;//如果在第一件语句执行成功，而在第二句前因为异常导致没有成功，就会导致数据发生错乱    int i = 1/0;//产生一个异常，导致后面一句执行不成功                                                        //[2]    preparedStatement = connection.prepareStatement(sql);    preparedStatement.executeUpdate();    connection.commit();//[3] 提交事务    System.out.println(&quot;complete&quot;);&#125; catch (SQLException e) &#123;    System.out.println(&quot;fail&quot;);    System.out.println(e);    connection.rollback();//[4] 回滚事务&#125; finally &#123;    connection.close();//[5] 关闭连接&#125;</code></pre><ol><li>取消自动提交事务：</li></ol><pre><code class="java">```connection.setAutoCommit(false);```</code></pre><ol start="2"><li><p>这是一个 SQL 语句。表示在 name &#x3D; 萝茵 的数据中只保留 id 最小的一条。</p><pre><code>delete from actor where name = &#39;萝茵&#39; and id &gt; (select * from (select min(id) from actor where name = &#39;萝茵&#39;) a)MYSQL</code></pre><p> 正常写法会提示不能同表查询（在 MySQL 中，不能在同一语句中先 select 出同一表中的某些值，再 update 这个表）。使用一个额外的 select 过渡就解决了这个问题。特此记录。</p></li><li><p>提交事务：</p></li></ol><pre><code class="java">```connection.commit();```</code></pre><ol start="4"><li>回滚事务：</li></ol><pre><code class="java">```connection.rollback();```写在 catch 里。这样，语句错误抛出异常的场合会执行到这句话。</code></pre><ol start="5"><li>关闭连接：</li></ol><pre><code class="java">```connection.close();//可以传参，参数为回滚点，不传参数默认回滚到开始的状态```写在 finally 里。这样，执行完语句总会关闭连接。这很好。</code></pre><h2><span id="236-批处理">23.6 批处理</span></h2><blockquote><p>批处理：把多条语句一次性提交给数据库进行批量处理。这样做比单独提交更有效率。</p></blockquote><p>&#x3D;&#x3D;要使用批处理功能，需要在 url 中加入 <code>?rewriteBatchedStatements=true</code>，即在配置文件中写成：&#x3D;&#x3D;</p><blockquote><pre><code class="properties">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</code></pre></blockquote><p>批处理往往和 PerparedStatement 搭配使用，既减少编译次数，又减少运行次数，岂不美哉？</p><p><strong>示例：</strong></p><blockquote><pre><code class="java">    //[0] 事前准备Connection connection = JDBCUtils.getConnection();String sql = &quot;insert into test1 values(?)&quot;;PreparedStatement ps = connection.prepareStatement(sql);for (int i = 0; i &lt; 1000; i++) &#123;    ps.setInt(1,i);    ps.addBatch();//[1]&#125;ps.executeBatch();//[2]JDBCUtils.close(connection, ps, null);</code></pre><ol><li>修改配置文件</li></ol><pre><code class="properties">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true...</code></pre><ol start="2"><li>添加需要批量处理的 SQL 语句</li></ol><pre><code class="java">preparedStatement.addBatch();</code></pre><ol start="3"><li>执行批量处理语句</li></ol><pre><code class="java">preparedStatement.executeBatch();</code></pre><ol start="4"><li>（前面的例子里没有这句）清空批处理包的语句</li></ol><pre><code class="java">preparedStatement.clearBatch();</code></pre></blockquote><h3><span id="2361-说明">23.6.1 说明</span></h3><ol><li>第一次添加批处理语句时，创建一个 ArrayList。</li></ol><pre><code class="java">&gt; ```&gt; ...&gt; if (this.batchedArgs == null) &#123;&gt;     this.batchedArgs = new ArrayList();&gt; &#125;&gt; ...&gt; ```……会在其中放置批处理语句（指令的数据）</code></pre><ol start="2"><li><p>该数组满后，按照 1.5 倍扩容</p></li><li><p>达到指定的值后，执行 executeBatch 吧</p></li><li><p>批处理能减少编译次数，也能减少发送 SQL 语句的网络开销。</p></li></ol><h2><span id="237-数据库连接池">23.7 数据库连接池</span></h2><blockquote><p><strong>传统获取 Connection 方法的问题：</strong></p><ol><li>传统的 JDBC 数据库连接使用 DriverManager 获取，每次建立连接都会把 Connection 载入内存，再进行身份验证。每次连接都会重复验证请求，这样会占用过多系统资源，容易造成服务器崩溃。</li><li>每次连接，使用完毕后必须断开。如果不断开操作，会致使数据库内存泄漏，最终不得不重启数据库。</li><li>传统连接方式不能控制创建的连接数量。连接数量过多的场合，也可能导致内存泄漏，MySQL 崩溃</li></ol></blockquote><p><strong>因此，需要使用连接池技术：</strong></p><ol><li>预先在缓冲池放入一定数量的连接。需要建立数据库连接时，从缓冲池中取出一个连接。使用完后，把该连接放回缓冲池。</li><li>数据库连接池负责分配、管理和释放数据库连接。其允许应用程序重复使用一个现有的数据库连接，而非建立新的连接。</li><li>当请求连接的数量超过最大数量，这些连接请求会被加入等待队列。</li></ol><p><strong>数据库连接池种类：</strong></p><p>JDBC 数据库连接池使用 javax.sql.DataSource 表示，称为&#x3D;&#x3D;数据源&#x3D;&#x3D;，DataSource 是一个接口，通常由第三方提供实现（提供 jar 包）</p><ul><li>C3P0：速度稍慢，稳定性好……但是速度再慢也不是传统 JDBC 能比得上的，不自量力！</li><li>DBCP：速度稍快，稳定性差</li><li>Proxool：可以监控连接池状态，稳定性稍差</li><li>BoneCP：速度快</li><li>Druid：阿里提供的数据库连接池，集 DBCP、C3P0、Proxool 优点于一身</li></ul><h3><span id="2371-c3p0">23.7.1 C3P0</span></h3><p>写在前面：C3P0 连接时跳一堆红字，不一定是报错……他就这样。</p><p><strong>使用 C3P0 的前置工作：</strong></p><ol><li><p><a href="https://sourceforge.net/projects/c3p0/?source=navbar">C3P0 jar 包下载</a></p><blockquote><p>&#x3D;&#x3D;注意0.9.2版本及之后要同时在libs文件夹导入c3p0和c3p0-oracle这两个jar包&#x3D;&#x3D;</p></blockquote></li><li><p>……和前面一样，把 jar 包装载好。</p></li></ol><p>  为了正常运行程序，这里（上面连接下载的） jar 包（似乎）至少是：</p><p>  <code>mchange-commons-java-0.2.19.jar</code></p><p>  <code>c3p0-0.9.5.5.jar</code></p><blockquote><p>csdn上说mchange-commons-java-0.2.19.jar这是<strong>c3p0数据库连接池</strong>的辅助包，如果没有这个包系统启动时会报classnotfoundexception，这是更新c3p0-0.9.2版本后分离出来的包，0.9.1的时候还是只是一个包。</p></blockquote><ul><li><p>方式一：在程序中指定相关参数</p><blockquote><pre><code class="java">    /* [1] */ComboPooledDataSource cpds = new ComboPooledDataSource();    /* [2] */cpds.setDriverClass(dirver);cpds.setUser(user);cpds.setPassword(password);cpds.serJdbcUrl(url);    /* [3] */cpds.setInitialPoolSize(10);    /* [4] */cpds.setMaxPoolSize(50);    /* [5] */Connection connection = cpds.getConnection();...connection.close();</code></pre><ol><li><p>创建数据源对象（dataSource）</p><pre><code class="java">ComboPooledDataSource cpds = new ComboPooledDataSource();</code></pre></li><li><p>设置参数</p></li></ol><pre><code class="java">    cpds.setDriverClass(String dirver);    cpds.setUser(String user);    cpds.setPassword(String password);    cpds.serJdbcUrl(String url);    ```……上面输入的形参 `user` 是字符串 `&quot;root&quot;`。其他同理。3. 设置初始化连接数```java    cpds.setInitialPoolSize(10);    ```        初始化连接数，就是指连接池创建时，初始持有的连接数4. 设置最大连接数    ```javacpds.setMaxPoolSize(50);    ```    5. 获取一个连接```java    Connection connection = cpds.getConnection();</code></pre></blockquote></li><li><p>方式二：使用配置文件模板完成</p><blockquote><pre><code class="java">    /* [0] 前置操作 */     /* [1] 获取数据源对象 */ ComboPooledDataSource cpds = new ComboPooledDataSource(&quot;Heruin&quot;);    /* [2] 获取连接 */ Connection connection = cpds.getConnection();...connection.close();</code></pre><ol><li>加入配置文件</li></ol><p>  <strong>c3p0-config.xml：</strong>配置文件，文件名固定，放在 <code>src/c3p0-config.xml</code> 这个位置</p><pre><code class="xml">&lt;c3p0-config&gt;        &lt;!-- 数据源（连接池）名称 --&gt;    &lt;named-config name=&quot;Heruin&quot;&gt;            &lt;!-- 驱动类 --&gt;        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;//com.mysql.jdbc.Driver 是 mysql-connector-java 5中的， com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6以及以上中的            &lt;!-- url --&gt;        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt;            &lt;!-- 用户名 --&gt;        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;            &lt;!-- 密码 --&gt;        &lt;property name=&quot;password&quot;&gt;******&lt;/property&gt;            &lt;!-- 初始化连接数 --&gt;        &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;            &lt;!-- 最大空闲时间 --&gt;        &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt;            &lt;!-- 最大连接数 --&gt;        &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt;            &lt;!-- 最小连接数 --&gt;        &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;            &lt;!-- 每次增长的连接数 --&gt;        &lt;property name=&quot;acquireIncrement&quot;&gt;10&lt;/property&gt;            &lt;!-- 可连接的最多的命令对象数 --&gt;        &lt;property name=&quot;maxStatements&quot;&gt;10&lt;/property&gt;            &lt;!-- 每个连接可连接的最多的命令对象数 --&gt;        &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt;    &lt;/named-config&gt;&lt;/c3p0-config&gt;</code></pre><ol start="2"><li><p>获取数据源对象</p><pre><code class="java">ComboPooledDataSource cpds = new ComboPooledDataSource(String name);</code></pre><p> 这里的 <code>name</code> 就是配置文件中的 <code>数据源名称</code></p></li><li><p>获取连接</p></li></ol></blockquote></li></ul><h3><span id="2372-druid德鲁伊连接池">23.7.2 Druid（德鲁伊）连接池</span></h3><p><del>有的人因为看见而相信，有的人因为相信而看见！</del></p><p><strong>使用 Druid 的前置工作：</strong></p><ol><li><p><a href="https://github.com/alibaba/druid">Druid jar 包下载</a></p><p> ……这个链接打不开的话，试试 <a href="https://repo1.maven.org/maven2/com/alibaba/druid/">这个</a></p></li><li><p>配置 jar 包</p></li><li><p>加入配置文件</p><blockquote><p><strong>durid.properties：</strong>配置文件，文件名任意，放在 <code>src/druid.properties</code></p><pre><code class="java">driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=720mel\iminitialSize=10minIdle=5maxActive=20maxWait=5000PROPERTIES</code></pre></blockquote></li></ol><ul><li><p>使用 Druid：</p><pre><code class="java">    /* [1] 加载配置文件 */Properties properties = new Properties();properties.load(new FileInputStream(&quot;src\\Druid.properties&quot;));    /* [2] 初始化数据池 */DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);    /* [3] 获取连接 */Connection connection = dataSource.getConnection();...connection.close();</code></pre><ol><li><p>初始化数据池</p><pre><code class="java">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</code></pre></li><li><p>……没什么好说的，但要说一下这个：</p><pre><code class="java">connection.close();</code></pre></li></ol><p>  <code>Connection</code> 是一个接口，对于方法 <code>close()</code>，不同供应商有不同实现方法。</p><p>  &#x3D;&#x3D;原生的 <code>MySQL</code> 的实现方法是关闭连接，而这些连接池的实现方法是取消引用（放回连接池）。&#x3D;&#x3D;</p></li></ul><h2><span id="238-apache-dbutils">23.8 Apache - DbUtils</span></h2><blockquote><p><code>commons-DbUtils</code>：是 Apache (阿帕奇)组织提供的一个开源的 JDBC 工具库。它是对 JDBC 的封装。使用 dbutils 能极大简化 JDBC 编码的工作量</p><p><strong>DbUtils 的常用类：</strong></p><ul><li><code>QueryRunner</code> 类：封装了 SQL 的执行。是线程安全的，可以实现增、删、改、查、批处理操作</li><li><code>ResultSetHandler</code> 接口：用于处理 <code>ResultSet</code>，按照需求将数据转化为其他形式</li></ul></blockquote><p>JDBC 传统方法的不足：</p><ol><li>结果集和连接是关联的。在连接关闭后，就不能使用结果集。</li><li>结果集只能使用一次，这样不便于数据管理</li><li>使用返回信息不方便</li></ol><p>解决方案：</p><ul><li><ol><li><p>土方法（只是演示，实际还是用Dbutils）：创建一个类（这个类统称为JavaBean&#x2F;POJO&#x2F;Domain&#x2F;entity），其属性与表格的列一一对应。将数据遍历并读取到一个个类对象中，再将这些类对象放置到集合中。这样，就得到了一个与表格数据关联的数据集合。</p><blockquote><p>&#x3D;&#x3D;参考&#x3D;&#x3D;：<a href="https://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly">javabean到底是什么？</a></p></blockquote></li></ol><blockquote><p>数据类，根据需要创建：</p><pre><code class="java">+------+------------+------+| id   | date       | name |+------+------------+------+|    1 | 2003-11-20 | jack |+------+------------+------+//对应上表public class SQL_Data &#123; private Integer id;//最好使用包装类 private Date date; private String name;         /* 一定要有无参构造器。这是因为后面会用到反射 */ public SQL_Data()&#123;&#125; public SQL_Data(Integer id, Date date, String name) &#123;     this.id = id;     this.date = date;     this.name = name; &#125;    /* Geter &amp; Seter 笔记里就省略不记了。光占地方又没技术含量 */ ...&#125;</code></pre><p>……然后遍历 ResultSet，存放。就不写了。</p></blockquote></li><li><ol start="2"><li>&#x3D;&#x3D;使用 <code>DbUtils</code>&#x3D;&#x3D;：</li></ol><blockquote><pre><code class="java">    /* [0] 前置操作 */String sql = &quot;select * from account where ? = ?&quot;;    /* [1] 创建 QueryRunner */QueryRunner qr = new QueryRunner();    /* [2] 执行相关方法 */List&lt;SQL_Data&gt; list = qr.query(connection, sql, new BeanListHandler&lt;&gt;(SQL_Data.class), &quot;id&quot;, 1);...    /* [3] 释放资源*/connection.close();</code></pre><ol><li><p>前置操作：</p><p> <a href="https://commons.apache.org/proper/commons-dbutils/download_dbutils.cgi">获取 jar 包</a>，并完成配置</p><p> 得到连接 <code>Connection connection</code>，创建数据类（这里是 <code>SQL_Data</code>）</p></li><li><p>执行相关方法，返回结果集</p></li></ol><pre><code class="java">List&lt;SQL_Data&gt; list =     queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(SQL_Data.class), ...);</code></pre><ul><li><p><code>queryRunner.query</code> 方法：执行 SQL 语句，把得到的 <code>ResultSet</code> 封装到 List 集合。这个方法会**自动关闭获得的 <code>ResultSet</code>**，所以不会造成资源泄漏</p></li><li><p><code>connection</code>：前置操作中得到的连接</p></li><li><p><code>sql</code>：SQL 语句</p></li><li><p><code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：利用反射机制，将数据封装到 <code>SQL_Data</code> 对象中</p></li><li><p><code>&quot;id&quot;, 1</code>：给 SQL 语句中的 <code>?</code> 赋值。因为是<strong>可变参数</strong>，可以写多个，如：<code>queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(SQL_Data.class), &quot;id&quot;, 1, &quot;name&quot;, &quot;识之律者&quot;);</code></p></li><li><p><code>SQL_Data</code>：是数据库当中的表映射的javabean。</p><p><font color="red">……这里，可变参数也包含列名的场合，筛选似乎会失效。还不知道原理。特此记录。</font></p><blockquote><p>这种语法或者本身就要避免，是不合法的。</p></blockquote></li></ul><ol start="3"><li><p>&#x3D;&#x3D;此时只需要关闭 <code>Connection</code>&#x3D;&#x3D;</p><p> &#x3D;&#x3D;<code>query()</code> 方法已经关闭了 <code>ResultSet</code> 和 <code>PreparedStatement</code>&#x3D;&#x3D;</p></li></ol></blockquote></li></ul><h3><span id="2381-apache-dbutils-常用方法">23.8.1 Apache-DbUtils 常用方法</span></h3><ul><li><p><code>queryRunner.update(connection, sql, ...)</code>：DML 语句。增删改。</p><p>  后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>  返回值 int 代表被影响的行数。</p></li><li><p><code>queryRunner.query(connection, sql, ResultSetHandler, ...)</code>：查询。</p><p>  后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>  关于 <code>ResultSetHandler</code>：</p><ul><li>传入 <code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：返回多行多列。这个场合，用 <code>List</code> 接收返回值。</li><li>传入 <code>new BeanHandler&lt;&gt;(SQL_Data.class)</code>：返回单行。这个场合，用 <code>SQL_Data data</code> 接收返回值。<ul><li><code>SQL_Data data</code> 表中的某一行数据映射的对象。</li></ul></li><li>传入 <code>new ScalarHander&lt;&gt;()</code>：返回单行单列。这个场合，用 <code>Object</code> 接收返回值。<strong>注意没有参数</strong></li></ul></li></ul><h3><span id="2382-表和-javabeanx2fpojo-的对应关系">23.8.2 表和 JavaBean&#x2F;POJO 的对应关系</span></h3><table><thead><tr><th>表类型</th><th>JavaBean类型</th></tr></thead><tbody><tr><td>int、samllint……</td><td>Integer</td></tr><tr><td>char、varchar……</td><td>String</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>date</td><td>java.util.Date&#x2F;String</td></tr></tbody></table><h2><span id="x3dx3d24-basicdaox3dx3d">&#x3D;&#x3D;24. BasicDAO&#x3D;&#x3D;</span></h2><p>项目设计的模式：</p><p>具体各个层的作用参考：<a href="https://blog.csdn.net/Restarting2019/article/details/122296373">什么是Dao层、Entity层、Service层、Servlet层、Utils层？-CSDN博客</a></p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311071112561.png" alt="image-20231107111159462"></p><blockquote><p>实际写代码是先完成下层的，再完成上层的。</p><p>一般开发中关于dao里的方法是否应该是static的，stackoverflow上有讨论，搜关键词 dao method static就行，主要完成的是service层，<strong>从下往上分析。</strong>，&#x3D;&#x3D;映射的javabean应该有无参构造器，，因为底层反射是使用无参构造器构造javabean对象的。而且属性名要以数据库为准，底层是用setName()来初始化属性的(会根据列名对应方法，比如列名为name，如果javabean中写的是name2，他就找不到应该为setName()的方法(此时javabean中的是setName2()方法，它匹配不到)，这种场合就需要在sql语句起别名，将列名置为name2，这样就可以找到setName2()了)，<font color="red">映射的属性必须要和列名一致或者为列名的别名</font>，前提是每个sql语句都取别名&#x3D;&#x3D;</p><p>数据库会根据自己的字段找到对应实体类的属性，通过set方法对属性进行注入。 如果实体类的属性名name2和数据库的字段名name不相同,则没有通过set方法进行注入，就会将name2置为null。</p></blockquote><blockquote><p>Apache - DbUtils + Druid 简化了 JDBC 开发，但还有不足。</p><ol><li>SQL 语句固定，不能通过传入参数控制，通用性不好。</li><li>select 操作的返回类型未知，需要使用泛型。</li><li>将来的表很多，业务需求复杂，不可能只靠一个 Java 类完成</li></ol></blockquote><p>DAO：数据访问对象（data access object）</p><ol><li><p>我们把通用的和数据库交互的操作封装到一个通用类中，称为 BasicDAO。</p></li><li><p>在 BasicDAO 基础上，每张表对应一个特化的 DAO（继承 BasicDAO），从而更好地完成功能。</p><p> 比如：Data 表 -&gt; Data.java 类（JavaBean）-&gt; DataDAO.java</p></li></ol><p><strong>BasicDAO.java（示例）</strong></p><pre><code class="java">public class BasicDAO&lt;T&gt; &#123;    private QueryRunner qr = new QueryRunner();        /*这个方法完成插入和修改的操作，在底层是使用executeUpdate执行sql语句*/    //可以利用这个方法检查是否插入成功，返回值&lt;0则表明插入失败，返回值&gt;0表明插入成功    public int update(String sql, Object... parameters)&#123;        Connection connection = null;        try &#123;            connection = JDBCUtils.getConnection();            return qr.update(connection, sql, parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtils.close(connection, null, null);        &#125;    &#125;    /*因为返回的是list集合 要用到反射,所以用到class对象作为参数*/    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; tClass, Object... parameters)&#123;        Connection connection = null;        try &#123;            connection = JDBCUtils.getConnection();            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(tClass), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtils.close(connection, null, null);        &#125;    &#125;    public T querySingle(String sql, Class&lt;T&gt; tClass, Object... parameters)&#123;        Connection connection = null;        try &#123;            connection = JDBCUtils.getConnection();            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(tClass), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtils.close(connection, null, null);        &#125;    &#125;        /*注意这里查询单个数据不需要用到class*/    public Object queryScalar(String sql, Object... parameters)&#123;        Connection connection = null;        try &#123;            connection = JDBCUtils.getConnection();            return qr.query(connection, sql, new ScalarHandler&lt;&gt;(), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtils.close(connection, null, null);        &#125;    &#125;&#125;</code></pre><h1><span id="dbutils数据库连接池多表连接查询">DBUtils数据库连接池多表连接查询</span></h1><p>方案一：</p><p>老韩的思路：单独写一个javabean映射多表查询的结果，它包含其他javabean的属性(将这些属性重复组合放在这个单独的javabean中，但不是将其他javabean作为它的属性)。它也有自己的Dao，也可以有service，具体实现根据业务完成。<br>缺点：每次增加业务时，就要在这个javabean添加相应的字段。</p><p><em>随着业务增加，字段越来越多怎么办？</em></p><p>解决方案：</p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311100001554.png" alt="image-20231110000127498"></p><p>方案二：</p><p>MapListHandler的使用（具体使用方式查看官方文档<a href="http://commons.apache.org/proper/commons-dbutils/apidocs/index.html%EF%BC%89">http://commons.apache.org/proper/commons-dbutils/apidocs/index.html）</a><br>key——sql语句查询的字段<br>value——数据库中查询得到的结果<br>出现的问题描述<br>&#x3D;&#x3D;对于多表连接查询，如果使用<code>BeanListHandler</code>，则会出现空指针异常。&#x3D;&#x3D;<br>例如employee和department分类封装为Javabean。employee中声明一个department的对象。如下图所示：</p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202311092320599.png"></p><p>解决方案<br>使用MapListHandler最终返回List&lt;map&lt;String,Object&gt;&gt;,使用迭代的方式通过查询字段取出value，首先根据Department类中的key从map中取出对应的value，并将其封装为Department对象。最终再封装为Employee对象，这样就解决了使用BeanListHandler出现空指针异常的现象。<br>具体实现代码如下图</p><p><img src="https://img-blog.csdnimg.cn/20200116215105911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yY2hhaTUyMQ==,size_16,color_FFFFFF,t_70"></p><p>ResultSetHandler实现类介绍（由DbUtils框架提供）</p><pre><code> 备注：DbUtils给我们提供了10个ResultSetHandler实现类，分别是： ①ArrayHandler：     将查询结果的第一行数据，保存到Object数组中 ②ArrayListHandler     将查询的结果，每一行先封装到Object数组中，然后将数据存入List集合 ③BeanHandler     将查询结果的第一行数据，封装到user对象 ④BeanListHandler     将查询结果的每一行封装到user对象，然后再存入List集合 ⑤ColumnListHandler     将查询结果的指定列的数据封装到List集合中 ⑥MapHandler     将查询结果的第一行数据封装到map结合（key==列名，value==列值） ⑦MapListHandler     将查询结果的每一行封装到map集合（key==列名，value==列值），再将map集合存入List集合 ⑧BeanMapHandler     将查询结果的每一行数据，封装到User对象，再存入mao集合中（key==列名，value==列值） ⑨KeyedHandler     将查询的结果的每一行数据，封装到map1（key==列名，value==列值 ），然后将map1集合（有多个）存入map2集合（只有一个） ⑩ScalarHandler     封装类似count、avg、max、min、sum......函数的执行结果</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdbc </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.面向对象编程（基础）</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="6-面向对象编程基础">6 面向对象编程（基础）</span></h1><blockquote><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写</p></blockquote><h2><span id="61-类与对象">6.1 类与对象</span></h2><blockquote><p>从 类 到 对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者 把对象实例化</p><ol><li>类 是抽象的、概念的，代表一类事物</li><li>对象 是具体的、实际的，代表一个个具体事物</li><li>类 是 对象 的模板，对象 是 类 的一个个体，对应一个实例</li></ol></blockquote><h3><span id="611-属性x2f成员变量">6.1.1 属性&#x2F;成员变量</span></h3><blockquote><p>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; field（字段）</p></blockquote><pre><code class="java">class Cat&#123;    String name;    int age;&#125;</code></pre><h3><span id="612-创建对象">6.1.2 创建对象</span></h3><p>注意事项：</p><ol><li><p>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。</p><p> 对象的引用，也被称为对象的句柄。</p></li><li><p>使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用</p></li></ol><h3><span id="x3dx3d613-类与对象的内存访问机制x3dx3d">&#x3D;&#x3D;6.1.3 类与对象的内存访问机制&#x3D;&#x3D;</span></h3><blockquote><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如<code>Cat cat1 = new Cat()</code>，是在这里开辟的空间），所有的java对象都存储在堆中。</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><ol><li>创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈 中的对象名被赋予指向那个空间的地址。</li><li>之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在 堆 中；是 字符串 的记录一个地址，该地址指向 方法区，那里的常量池有该字符串。</li></ol><h2><span id="62-成员方法">6.2 成员方法</span></h2><blockquote><p>使用 成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</p></blockquote><h3><span id="x3dx3d621-方法的调用机制x3dx3d">&#x3D;&#x3D;6.2.1 方法的调用机制&#x3D;&#x3D;</span></h3><p>以前文代码为例：</p><pre><code class="java">...        int r = cat1.speak2(15, 135);...public int speak2(int n1, int n2)&#123;   int res = n1 + n2;   return res;&#125;...</code></pre><ol><li>当程序执行到方法时，在 栈 中开辟一个新的 栈空间。该空间里储存 <code>n1 = 15</code> <code>n2 = 135</code>，之后计算并储存结果 <code>res = 150</code></li><li>当方法执行完毕，或执行到 <code>return</code> 语句时，就会返回</li><li>把 新栈空间 中的 <code>res = 150</code> 返回 main栈 中调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li></ol><h3><span id="622-使用细节">6.2.2 使用细节</span></h3><ol><li>调用细节：<ul><li>同一个类中的方法调用，可以直接调用。</li><li>跨类的方法调用，需要创建新对象，然后再调用方法。</li></ul></li></ol><h3><span id="x3dx3d623-成员方法传参机制x3dx3d">&#x3D;&#x3D;6.2.3 成员方法传参机制&#x3D;&#x3D;</span></h3><p>&#x3D;&#x3D;Java 语言对对象采用的是 <strong>值传递</strong>，方法得到的总是那个传入对象的副本。&#x3D;&#x3D;</p><p>方法参数共有两种类型：</p><ol><li>基本数据类型（数字、布尔值)</li><li>对象引用。</li></ol><ul><li><p>&#x3D;&#x3D;方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参&#x3D;&#x3D;。</p></li><li><p>&#x3D;&#x3D;方法可以改变对象参数的状态。&#x3D;&#x3D;</p><p>  引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>  但改变那个形参地址指向的场合，实参的指向不会改变</p></li></ul><blockquote><p>java核心技术卷一：</p><p>4.5 方法参数</p><p>&#x3D;&#x3D;按值调用&#x3D;&#x3D;表示方法接收的是调用者提供的值。而按引用调用表示方法接受的是调用者提供的变量地址，一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>java程序设计语言总是采用按值调用，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p><pre><code class="java">double percent = 10;harry.raiseSalary(percent):不必理睬这个方法的具体实现， 在方法调用之后， percent 的值还是10。</code></pre><p>但作将对象应用作为参数就不一样了。<br>拷贝的是对象的引用变量而不是整个对象，拷贝的和原来的引用指向同一个对象，可以理解为拷贝的对象引用是它的别名，实质指的是一个东西。可以通过这个别名引用来改变原对象。</p><p>总结一下Java 中方法参数的使用情况：</p><p>&#x3D;&#x3D;一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。&#x3D;&#x3D;<br>&#x3D;&#x3D;一个方法可以改变一个对象参数的状态。&#x3D;&#x3D;<br>&#x3D;&#x3D;一个方法不能让对象参数引用一个新的对象。&#x3D;&#x3D;</p></blockquote><h2><span id="63-x3dx3d方法递归调用x3dx3d">6.3 &#x3D;&#x3D;方法递归调用&#x3D;&#x3D;</span></h2><blockquote><p>递归：即方法自己调用自己，每次调用时传入不同变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p></blockquote><blockquote><p>下面，示范一个斐波那契数列方法</p><pre><code class="java">&gt;class T&#123;   public int fib(int n)&#123;       if(n == 1 || n == 2)&#123;           return 1;       &#125;else&#123;           return (fib(n - 1)) + (feb(n - 2));       &#125;   &#125;&gt;&#125;</code></pre></blockquote><h3><span id="631-使用细节">6.3.1 使用细节</span></h3><ol><li>执行一个方法时，就创建一个新的受保护的独立 栈空间。</li><li>方法的局部变量是独立的，不会相互影响。</li><li>如果方法中使用的是引用变量，就会共享数据。（因为 [[6.2.3 成员方法传参机制]](<a href="https://i-melody.github.io/2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6">https://i-melody.github.io/2021/11/29/Java/入门阶段/6</a> 面向对象编程（基础）&#x2F;#6-2-3-成员方法传参机制)）</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示 <code>StackOverflowError</code> “死龟”</li><li>当一个方法执行完毕，或遇到 <code>return</code> 就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕</li></ol><h2><span id="64-方法重载">6.4 方法重载</span></h2><p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求 形参列表 不一致。</p><h2><span id="x3dx3d65-可变参数x3dx3d">&#x3D;&#x3D;6.5 可变参数&#x3D;&#x3D;</span></h2><blockquote><p>Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p><pre><code class="java">public void m(int... n)&#123;    //此时，n 相当于一个 数组。    int length = n.length;    int num1 = n[0];&#125;</code></pre><h3><span id="651-使用细节">6.5.1 使用细节</span></h3><ol><li><p>可变参数 的实参可以是 0 个，也可以是 任意多 个。</p></li><li><p>可变参数 的实参可以是数组</p></li><li><p>可变参数 本质就是数组</p><p> 因此，出现：</p><pre><code class="java">public void met(int... n)&#123;//这个方法与下面的方法不能构成重载&#125;</code></pre><p> 的场合，不能有方法：</p><pre><code class="java">public void met(int[] n)&#123;//这个方法与上面的方法不能构成重载&#125;</code></pre></li><li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数 在最后</p><pre><code class="java">public void m(double dou, int... n) &#123;&#125;</code></pre></li><li><p>一个形参列表<u>最多出现 一个 可变参数。</u></p></li></ol><h2><span id="66-作用域">6.6 作用域</span></h2><ol><li>在 Java 编程中，主要的变量就是 <strong>属性（成员变量</strong>）和 <strong>局部变量。</strong></li><li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是 属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。&#x3D;&#x3D;局部变量必须赋值使用&#x3D;&#x3D;</li></ol><h3><span id="661-使用细节">6.6.1 使用细节</span></h3><ol><li><p>属性 和 局部变量 &#x3D;&#x3D;可以重名&#x3D;&#x3D;，访问时遵循&#x3D;&#x3D;就近原则&#x3D;&#x3D;</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>&#x3D;&#x3D;属性 的生命周期较长。其伴随对象的创建而创建，伴随<strong>对象</strong>的销毁而销毁。&#x3D;&#x3D;</p><p> &#x3D;&#x3D;局部变量 生命周期较短。其伴随代码块的执行而创建，伴随<strong>代码块</strong>的结束而销毁。&#x3D;&#x3D;</p></li><li><p>全局变量&#x2F;属性 可以被本类使用，&#x3D;&#x3D;也可以被其他类（通过对象）使用。&#x3D;&#x3D;</p><p> 局部变量 只能被本类的对应方法中调用</p></li><li><p>全局变量&#x2F;属性 <strong>可以加</strong> 修饰符</p><p> &#x3D;&#x3D;局部变量 <strong>不能加</strong> 修饰符&#x3D;&#x3D;</p></li></ol><h2><span id="67-构造方法-构造器">6.7 构造方法、构造器</span></h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化</p></blockquote><ol><li>构造器的修饰符可以是默认。也可以是别的</li><li>参数列表 规则同 成员方法</li></ol><h3><span id="671-使用细节">6.7.1 使用细节</span></h3><ol><li>构造器本质也是方法(并不会继承)。所以，可以 构造器重载。</li><li>构造器名 和 类名 相同</li><li>构造器无返回值</li><li>&#x3D;&#x3D;构造器是完成对象的初始化，而不是创建&#x3D;&#x3D;</li><li>&#x3D;&#x3D;创建对象时，系统<u>自动调用构造器</u>&#x3D;&#x3D;</li><li>如果提供了构造器，则不会提供默认构造器了。</li><li>&#x3D;&#x3D;一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器&#x3D;&#x3D;</li></ol><h3><span id="x3dx3d672-流程分析x3dx3d">&#x3D;&#x3D;6.7.2 流程分析&#x3D;&#x3D;</span></h3><pre><code class="java">Person p1 = new Person(&quot;Amy&quot;, 10);...    class Person&#123;    String name;    int age = 20;    public Person(String pName, int pAge)&#123;        name = pName;        age = pAge;    &#125;&#125;</code></pre><ol><li><p>加载 类信息（<strong>方法区</strong>）</p></li><li><p>在 <strong>堆</strong> 中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化。<code>age = 0; name = null</code></p></li><li><p>之后显式初始化。<code>age = 20; name = null</code>&#x2F;&#x2F;定义时的赋值</p><p>  其中，&#x3D;&#x3D;显式初始化和代码块初始化按编写的先后顺序依次进行&#x3D;&#x3D;。</p></li><li><p>之后构造器的初始化。<code>age = 10; name = &quot;Amy&quot;</code></p></li></ul></li><li><p>把对象在 堆 中的 地址，返回给 <code>p1</code></p></li></ol><h2><span id="x3dx3d68-this关键字x3dx3d">&#x3D;&#x3D;6.8 this关键字&#x3D;&#x3D;</span></h2><blockquote><p>JVM 会给每个对象分配 this 代表当前对象。</p><p>相当于在 堆 中，this 指向自己（对象）</p><p>在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。</p><p>遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p></blockquote><pre><code class="java">class Example&#123;    int n = 0;    public void act(int n) &#123;&#125;&#125;</code></pre><p>上面这个类的 <code>act()</code> 方法实际有 2 个参数。对其调用：</p><pre><code class="java">Example e = new Exmaple();e.act(100);</code></pre><p>可见，出现在方法名前的参数 <code>e</code>，以及出现在方法名后的括号中的参数 <code>100</code></p><p>&#x3D;&#x3D;出现在方法名前的参数被称为 <strong>隐式参数</strong>（也称为 方法调用的 目标 或 接收者）&#x3D;&#x3D;</p><p>&#x3D;&#x3D;出现在方法名后的参数被称为 <strong>显式参数</strong>，就是所谓的实参&#x3D;&#x3D;</p><p>在每一个方法中，用 <strong>this 指代隐式参数</strong>。</p><pre><code class="java">public void act(int n) &#123;    this.n = n;&#125;</code></pre><p>此时，再以相同方式调用方法：</p><pre><code class="java">e.act(100);// &lt;———— 相当于 e.n = 100;</code></pre><h3><span id="super-与-this-关键字"><code>super 与 this 关键字</code></span></h3><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p><p>this关键字：指向自己的引用。</p><blockquote><p>《java核心技术卷1》：5.1.3 子类构造器</p><ol><li><p>this 有两个用途： 一是引用隐式参数(&#x3D;&#x3D;所构造的对象&#x3D;&#x3D;)， 二是<u>调用该类其他的构造器</u></p></li><li><p>super 也有两个用途：一是调用超类的方法，二是调用超类的构造器。</p></li></ol><p>在调用构造器的时候， 这两个关键字的使用方式很相似。&#x3D;&#x3D;调用构造器的语句只能作为另一个构造器的第一条语句出现。&#x3D;&#x3D;&#x3D;&#x3D;构造参数既可以传递给本类(this ) 的其他构造器， 也可以传递给超类(super ) 的构造器。&#x3D;&#x3D;</p></blockquote><h3><span id="681-使用方法">6.8.1 使用方法</span></h3><ol><li><p><code>this</code> 关键字可以用来访问本类的属性、方法、构造器</p></li><li><p><code>this</code> 用于区分当前类的 属性 和 局部变量</p></li><li><p>访问本类中成员方法的语法：<code>this.方法名</code></p></li><li><p>访问构造器的语法：<code>this(参数列表);</code></p><p> 注意：&#x3D;&#x3D;只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中 使用&#x3D;&#x3D;</p></li></ol><h2><span id="附录">附录</span></h2><h3><span id="迷宫游戏代码">迷宫游戏代码</span></h3><pre><code class="java">/***@author Melody*@version v1.2.6**///迷宫import java.util.Scanner;public class MazeOut&#123;    public static void main(String[] args)&#123;        //tools 方便后面调用方法。 inP 可以接收用户输入        T tools = new T();        Scanner inP = new Scanner(System.in);                //提示并接收用户输入信息        System.out.println(&quot;\n输入迷宫宽度（至少为6）：&quot;);        int x = inP.nextInt();        System.out.println(&quot;\n输入迷宫长度（至少为6）：&quot;);        int y = inP.nextInt();          //若用户输入的长或宽超出范围，则将其重置为正常值        if(x &lt; 6)&#123;            x = 6;        &#125; else if(x &gt; 110)&#123;            x = 110;        &#125;        if(y &lt; 6)&#123;            y = 6;        &#125; else if(y &gt; 60)&#123;            y = 60;        &#125;        System.out.println(&quot;\n输入迷宫的困难度（请输入1 - 6的数字，数字越高越不容易获胜）：&quot;);        int hard = inP.nextInt();        if(hard == 7)&#123;            System.out.println(&quot;\n\n您选择了找点麻烦&quot;);        &#125; else if (hard == 8 || hard == 9)&#123;            System.out.println(&quot;\n\n您选择了给自己添堵&quot;);        &#125;        System.out.println(&quot;\n\t迷宫生产完毕\n&quot;);                //设置一个 count 值，记录步数。设为数组，以便数据通用。第一位记录当前值，第二位为最大值。        int[] count = &#123;0, 0&#125;;        //调用方法，生成迷宫        char[][] maze =new char[y][x];        tools.newMaze(maze.length, maze[0].length, maze, hard);        //调用方法，展示迷宫        tools.showMaze(maze);                //提示用户开始游戏        System.out.println(&quot;\n召唤一个探索者，来探索迷宫吧（随便输点什么吧）&quot;);        //输入 r 或 c 则采用递归方法，其余采用爬墙方法        char inC = inP.next().charAt(0);        if(inC == &#39;c&#39;)&#123;            System.out.println(&quot;\n您触发了迷宫之神的眷顾。&quot;);            if(hard &gt; 5)&#123;                System.out.println(&quot;\n迷宫之神眉头一皱，发现事情并不简单。&quot;);            &#125;            if(x &gt; 12 || y &gt; 12)&#123;                System.out.println(&quot;看到地图这么大，迷宫之神悻悻而归。他只喜欢12格以下的地图。&quot;);                return;             &#125;        &#125; else if(inC == &#39;r&#39;)&#123;            System.out.println(&quot;\n您引来了一群无畏小黄鸡。他们视死如归，一心想着寻找出口&quot;);        &#125; else &#123;            System.out.println(&quot;\n我们找来了一只小蜘蛛。试试看吧。&quot;);        &#125;        System.out.println(&quot;\n&quot;);        //调用方法，解密        if(inC == &#39;r&#39; || inC == &#39;c&#39;)&#123;            tools.outMazeRec(maze, inC, count);        &#125; else &#123;            tools.outMaze(maze, count);        &#125;    &#125;&#125;class T&#123;       //=======================================================================================            //方法 newMaze：让 n3 生成随机的 长 * 宽 = n1 * n2 的迷宫，其困难度为 n4    public void newMaze(int n1, int n2, char[][] n3, int n4)&#123;        //构建迷宫墙壁，以&#39;#&#39;表示。并随机向其中填充石块，以&#39;O&#39;表示        ////墙壁是迷宫的 开头和结尾行 以及 每行的开头和结尾        for(int i = 0; i &lt; n1; i++)&#123;            for(int j = 0; j &lt; n2; j++)&#123;                if(i == 0 || i == n1 - 1 ||j == 0 || j == n2 - 1)&#123;                    n3[i][j] = &#39;#&#39;;                &#125;else&#123;                    //ran 是一个随机值，此处是概率生成挡路的石块&#39;O&#39;。其概率与 n4 值的大小正相关                    //此外，若 n4（即用户输入的难度值 hard）超过范围，则按照 难度6 计算                    int ran;                    if(n4 &lt;= 9 &amp;&amp; n4 &gt;= 0)&#123;                        ran = (int)(Math.random() * (9 - n4) + 1);                    &#125;else&#123;                        ran = (int)(Math.random() * 3 + 1);                    &#125;                    n3[i][j] = (ran == 1) ? &#39;O&#39; : &#39; &#39;;                &#125;            &#125;        &#125;        //生成起点、终点，优化地形        n3[1][1] = &#39;B&#39;;        n3[2][1] = &#39; &#39;;        n3[1][2] = &#39; &#39;;        n3[n1 - 2][n2 - 2] = &#39;F&#39;;        n3[n1 - 3][n2 - 2] = &#39; &#39;;        n3[n1 - 2][n2 - 3] = &#39; &#39;;    &#125;                    //方法 showMaze：展示一个迷宫    public void showMaze(char[][] n1)&#123;        for(int i = 0; i &lt; n1.length; i++)&#123;            for(int j = 0; j &lt; n1[i].length; j++)&#123;                System.out.print(&quot; &quot; + n1[i][j]);            &#125;            System.out.println();        &#125;    &#125;    //=======================================================================================       //=======================================================================================    //方法 outMazeRec：递归方法迷宫游戏入口。可以接入普通递归方法，或最短路径方法。    public void outMazeRec(char[][] n1, char n2, int[] count)&#123;        //out：是否走出迷宫        boolean out = false;        //将迷宫的起止位置记为通路        n1[1][1] = &#39; &#39;;        n1[n1.length - 2][n1[0].length -2] = &#39; &#39;;        //如果输入的是&#39;c&#39;，则采用最短路径法。反之采用普通递归方法        if(n2 == &#39;c&#39;)&#123;            out = outCountMaze(1, 1, n1, count);        &#125;else&#123;            out = outMazeRecursion(1, 1, n1, count);                   &#125;        //把迷宫起始位置重新标注出来        n1[1][1] = &#39;B&#39;;        //判断是否解谜成功。如果成功，迷宫终点显示&#39;V&#39;，并展示步数，否则显示&#39;F&#39;        if(out)&#123;            n1[n1.length - 2][n1[0].length -2] = &#39;V&#39;;            showMaze(n1);            System.out.println(&quot;\t YOU WIN！！！&quot;);            System.out.println(&quot;通过路径为 &quot; + count[1] + &quot; 格&quot;);            &#125; else &#123;            n1[n1.length - 2][n1[0].length -2] = &#39;F&#39;;            showMaze(n1);            System.out.println(&quot;\t YOU LOSE&quot;);        &#125;            &#125;    //=======================================================================================    //=======================================================================================    //方法 outMazeRecursion：迷宫游戏，普通递归方法    public boolean outMazeRecursion(int y, int x, char[][] n3, int[] count)&#123;        count[1]++;        if(n3[n3.length - 2][n3[0].length - 2] == &#39;.&#39;)&#123;            return true;        &#125; else if(n3[y][x] == &#39; &#39;)&#123;            n3[y][x] = &#39;.&#39;;            if(outMazeRecursion(y, x + 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecursion(y + 1, x, n3, count))&#123;                return true;            &#125; else if(outMazeRecursion(y, x - 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecursion(y - 1, x, n3, count))&#123;                return true;            &#125; else&#123;                count[1]--;                n3[y][x] = &#39;+&#39;;             &#125;        &#125; else &#123;            count[1]--;            return false;        &#125;        count[1]--;        return false;    &#125;    //=======================================================================================        //=======================================================================================    //方法 outCountMaze：迷宫游戏，最短路径法的入口。这个入口由普通递归法接入。    public boolean outCountMaze(int y, int x, char[][] n, int[] count)&#123;        //首先，创建一个里数组。该数组用于 part1，原数组用于 part2。        //似乎没必要作此设计。但我还是予以保留。        char[][] inMaze = new char[n.length][n[0].length];        for(int i = 0; i &lt; n.length; i++)&#123;            for(int j = 0; j &lt; n[0].length; j++)&#123;                inMaze[i][j] = n[i][j];            &#125;        &#125;        //首先进行 part1，然后必定进行 part2。因为 part1 总会返回一个 false        if(countMazeRec(y, x, inMaze, count) || true)&#123;            count[0] = 0;            return outMazeRecC(y, x, n, count);        &#125;        return false;    &#125;    //方法 countMazeRec：迷宫游戏，最短路径法，part1    //该方法是先统计最短路径。最终总会返回 false    public boolean countMazeRec(int y, int x, char[][] n3, int[] count)&#123;        count[0]++;        if(y == n3.length - 2 &amp;&amp; x == n3[0].length - 2)&#123;            if(count[0] &lt; count[1] || count[1] == 0)&#123;                count[1] = count[0];            &#125;        &#125; else if(n3[y][x] == &#39; &#39;)&#123;            n3[y][x] = &#39;.&#39;;                       if(countMazeRec(y, x + 1, n3, count))&#123;                return true;            &#125; else if(countMazeRec(y + 1, x, n3, count))&#123;                return true;            &#125; else if(countMazeRec(y, x - 1, n3, count))&#123;                return true;            &#125; else if(countMazeRec(y - 1, x, n3, count))&#123;                return true;            &#125; else&#123;                n3[y][x] = &#39; &#39;;                count[0]--;                return false;            &#125;        &#125; else &#123;            count[0]--;            return false;        &#125;        count[0]--;        return false;    &#125;    //方法 outMazeRecC：迷宫游戏，最短路径法，part2    //该方法是在 part1 统计完最短路径后，按最短路径走出迷宫，并绘制路径    public boolean outMazeRecC(int y, int x, char[][] n3, int[] count)&#123;        count[0]++;        if(y == n3.length - 2 &amp;&amp; x == n3[0].length - 2)&#123;            if(count[0] &lt;= count[1])&#123;                return true;            &#125; else &#123;                n3[n3.length - 2][n3[0].length - 2] = &#39; &#39;;                count[0]--;                return false;            &#125;        &#125; else if(n3[y][x] == &#39; &#39;)&#123;            n3[y][x] = &#39;.&#39;;            if(outMazeRecC(y, x + 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecC(y + 1, x, n3, count))&#123;                return true;            &#125; else if(outMazeRecC(y, x - 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecC(y - 1, x, n3, count))&#123;                return true;            &#125; else&#123;                n3[y][x] = &#39; &#39;;                count[0]--;                return false;            &#125;        &#125; else &#123;            count[0]--;            return false;        &#125;    &#125;    //=======================================================================================        //=======================================================================================    //方法 outMaze：爬墙方法迷宫游戏入口    public void outMaze(char[][] n1, int[] count)&#123;        //boolean out：记录是否走出迷宫        boolean out = false;        //角色光标 m        n1[1][1] = &#39;m&#39;;                //创建一系列变量，后面解释用法        //创建 角色坐标        int x = 1;        int y = 1;        //创建 辅助坐标 及 方向字符。初始方向为右。        int xi = 1;        int yi = 0;        char dir = &#39;r&#39;;          //创建 里迷宫，标记起止点。        char[][] inMaze = new char[n1.length][n1[0].length];        inMaze[1][1] = &#39;B&#39;;        inMaze[n1.length - 2][n1[0].length - 2] = &#39;F&#39;;                //开始走迷宫。        //如果一个迷宫有出路，则沿着一侧的墙壁走就一定能走到出路。以下方法就是基于这个原理。        //角色坐标 y,x 是角色所在的位置坐标。辅助坐标 yi，xi 是角色靠近的墙壁坐标。        //dir 代表角色此时的朝向。只要角色按照墙壁延申的方向向前，就一定不会迷路。        //里迷宫的大小和真迷宫相同，坐标也一一对应。目的是为了记录数据，这些数据不会被用户看到。        //里迷宫记载了 起始点 和 终点 的位置。如角色回到起点，则必定失败。到达终点则成功。        for(;;)&#123;            //判断 是否走出迷宫。如若是，则展示迷宫，记录脱出为真，并退出寻路            if(inMaze[y][x] == &#39;F&#39;)&#123;                n1[y][x] = &#39;V&#39;;                n1[1][1] = &#39;B&#39;;                showMaze(n1);                out = true;                break;            &#125;            //通过爬墙方式试图走出迷宫            //这是方向朝右时的情况            if(dir == &#39;r&#39;)&#123;                //如果角色面对墙壁，意味着走到了墙角，则角色坐标不变，调整墙壁坐标，并转向                if(n1[y][x + 1] == &#39;#&#39; || n1[y][x + 1] == &#39;O&#39;)&#123;                    dir = yi &gt; y ? &#39;u&#39; : &#39;d&#39;;                    yi = y;                    xi = x + 1;                //如果面前有路，且墙壁延伸，则前进                &#125; else if (n1[yi][xi + 1] == &#39;#&#39; || n1[yi][xi + 1] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    x++;                    xi++;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                //如果面前有路，但墙壁不延伸，则是遇到了转角。角色移动，转向，但墙壁坐标不变                &#125; else &#123;                    dir = yi &gt; y ? &#39;d&#39; : &#39;u&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y][x + 1] = &#39;.&#39;;                    y = yi;                    x = xi + 1;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            //这是方向朝左的情况            &#125; else if(dir == &#39;l&#39;)&#123;                if(n1[y][x - 1] == &#39;#&#39; || n1[y][x - 1] == &#39;O&#39;)&#123;                    dir = yi &gt; y ? &#39;u&#39; : &#39;d&#39;;                    yi = y;                    xi = x - 1;                &#125; else if(n1[yi][xi - 1] == &#39;#&#39; || n1[yi][xi - 1] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    x--;                    xi--;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                &#125; else &#123;                    dir = yi &gt; y ? &#39;d&#39; : &#39;u&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y][x - 1] = &#39;.&#39;;                    y = yi;                    x = xi - 1;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            //这是方向朝下的情况            &#125; else if(dir == &#39;d&#39;)&#123;                if(n1[y + 1][x] == &#39;#&#39; || n1[y + 1][x] == &#39;O&#39;)&#123;                    dir = xi &lt; x ? &#39;r&#39; : &#39;l&#39;;                    yi = y + 1;                    xi = x;                &#125; else if(n1[yi + 1][xi] == &#39;#&#39; || n1[yi + 1][xi] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    y++;                    yi++;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                &#125; else &#123;                    dir = xi &lt; x ? &#39;l&#39; : &#39;r&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y + 1][x] = &#39;.&#39;;                    y = yi + 1;                    x = xi;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            //这是方向朝上的情况            &#125; else if(dir == &#39;u&#39;)&#123;                if(n1[y - 1][x] == &#39;#&#39; || n1[y - 1][x] == &#39;O&#39;)&#123;                    dir = xi &lt; x ? &#39;r&#39; : &#39;l&#39;;                    yi = y - 1;                    xi = x;                &#125; else if(n1[yi - 1][xi] == &#39;#&#39; || n1[yi - 1][xi] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    y--;                    yi--;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                &#125; else &#123;                    dir = xi &lt; x ? &#39;l&#39; : &#39;r&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y - 1][x] = &#39;.&#39;;                    y = yi - 1;                    x = xi;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            &#125;            //判断 是否回到起点。如若是，则一定是迷宫无解。展示迷宫并退出寻路            if(inMaze[y][x] == &#39;B&#39;)&#123;                showMaze(n1);                break;            &#125;        &#125;        //输出结果        if(out)&#123;            System.out.println(&quot;\t YOU WIN！！！\n\t您的步数为：&quot; + count[1]);        &#125; else &#123;            System.out.println(&quot;\t YOU LOSE&quot;);        &#125;    &#125;&#125;</code></pre><h3><span id="八皇后代码">八皇后代码</span></h3><pre><code class="java">import java.util.Scanner;public class EightQueen&#123;    public static void main(String[] args)&#123;        T tools = new T();        char[][] chess = new char[8][8];        //调用方法，建立棋盘        tools.buildChess(chess);        //调用方法，开始游戏        tools.eightQueen(chess);    &#125;&#125;class T&#123;    //buildChess：建立一个新棋盘。该棋盘白色格子用&#39; &#39;表示，黑色格子用&#39;#&#39;表示    public void buildChess(char[][] chess)&#123;        for(int i = 0; i &lt; chess.length; i++)&#123;            for(int j = 0; j &lt; chess[0].length; j++)&#123;                chess[i][j] = ((i + j) % 2 == 0) ? &#39; &#39; : &#39;#&#39;;            &#125;        &#125;    &#125;    //eightQueen：八皇后游戏的接入口    public void eightQueen(char[][] chess)&#123;        //建立 里棋盘 inward 及 计数数组 count。里棋盘用于计算问题，原棋盘输出给用户看。        //计数 count 使用数组，这样其数据在所有方法都能通用        char[][] inward = new char[chess.length][chess[0].length];        int[] count = &#123;0&#125; ;        //进行游戏。因为穷举所有方法，最后返回的一定是 false。反正我们不在意。        boolean isFinished = gameEQS(0, 0, chess, inward, count);    &#125;    //gameEQS：八皇后游戏的基本方法    //八皇后游戏方法。y 代表当前位置的纵坐标，x 是横坐标。chess 是棋盘，inward 是里棋盘，count 是计数数组    public boolean gameEQS(int y, int x, char[][] chess, char[][] inward, int[] count)&#123;        //当 y 超出棋盘 时，显然已经完成八皇后。        //由于要进行穷举，此时我们计数并输出棋盘，然后返回 false 使其继续计算        if(y == inward.length)&#123;            count[0]++;            System.out.println();            gameEQS2(chess, inward, count);            return false;        //当 x 超出棋盘 时，显然棋盘该列已经无合法放置位置。我们返回 false        &#125; else if(x == inward[0].length)&#123;            return false;        //gameEQS1，这个方法是查看该格子是否是合法放置位置。如若是，返回 true，而且在该位置放置棋子&#39;Q&#39;        //当这个位置合法，我们进入下一行，从头开始判断。        //如果后面的判断为 false，我们就拿掉这枚棋子。如果后面判断为 true 说明我们找到了一个方法。        //特别地，由于代码目前是穷举模式，我想我们永远不会在此输出 true        &#125; else if(gameEQS1(y, x, inward))&#123;            if(gameEQS(y + 1, 0, chess, inward, count))&#123;                return true;            &#125; else &#123;                inward[y][x] = &#39; &#39;;            &#125;        &#125;        //如果代码进行到这个位置，证明我们所在的格子不适合放置棋子。我们只好去看看下一格如何。        return gameEQS(y, x + 1, chess, inward, count);    &#125;    //gameEQS1：该方法是输入一个坐标，并输入里棋盘地址，在里棋盘上查看该位置是否合法    //什么是合法的位置：就是该坐标的 同列、同行、同斜线 没有别的棋子    //如果是合法位置，我们放置一个棋子，并返回 true    public boolean gameEQS1(int y, int x, char[][] inward)&#123;        for(int i = 0; i &lt; inward.length; i++)&#123;            for(int j = 0; j &lt; inward[0].length; j++)&#123;                if(j == x || i == y || i - j == y - x || i + j == y + x)&#123;                    if(inward[i][j] == &#39;Q&#39;)&#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        inward[y][x] = &#39;Q&#39;;        return true;    &#125;    //gameEQS2：这个方法是把当前 里棋盘 的棋子放置到棋盘上，输出棋盘 并 输出计数。    //在输出完成后，会清空棋盘。    public void gameEQS2(char[][] chess, char[][] inward,int[] count)&#123;        for(int i = 0; i &lt; chess.length; i++)&#123;            for(int j = 0; j &lt; chess[0].length; j++)&#123;                if(inward[i][j] == &#39;Q&#39;)&#123;                    chess[i][j] = &#39;Q&#39;;                &#125;                System.out.print(&quot; &quot; + chess[i][j]);            &#125;            System.out.println();        &#125;        System.out.print(&quot;\n&quot; + count[0] + &quot;\n&quot;);        buildChess(chess);    &#125;    //gameEQSDebug    //输出里棋盘。测试用。    public void gameEQSDebug(char[][] inward)&#123;        for(int i = 0; i &lt; inward.length; i++)&#123;            for(int j = 0; j &lt; inward[0].length; j++)&#123;                System.out.print(&quot; &quot; + inward[i][j]);            &#125;            System.out.println();        &#125;        System.out.println();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15 图形界面设计</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/15%20%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="15-图形界面设计">15 图形界面设计</span></h1><blockquote><p>图形用户界面（Graphical User Interface，简称 GUI）是大多数程序不可缺少的部分。</p><p>Java 的图形界面由各种组件组成。在 java.awt 和 java.swing 包中定义了多种用于创建图形用户界面的组件类。</p><p>Swing 组件和 AWT 组件最大的不同是 Swing 组件实现时不包含任何本地代码，因此不受硬件平台的限制，而具有更多的功能，并且在任何平台上运行效果都是相同的。不包含本地代码的 Swing 组件被称为 “轻量级” 组件，而 AWT 被称为 “重量级” 组件。两种组件一同使用的场合，AWT 总是显示在上面。</p></blockquote><p>设计用户界面是一般有 3 个步骤：</p><ol><li>选取组件</li><li>设计布局</li><li>响应事件</li></ol><h2><span id="151-容器">15.1 容器</span></h2><blockquote><p>组件分为容器组件和非容器组件。容器组件即可以包含其他组件的组件。非容器组件必须包含在容器组件中。</p><p>容器组件分为：顶层容器、一般用途容器</p></blockquote><h3><span id="1511-顶层容器">15.1.1 顶层容器</span></h3><p>Swing 中提供了 4 种顶层容器：</p><ul><li>JFrame：带有标题行和控制按钮（最小化、恢复&#x2F;最大化、关闭）的独立窗口。有时称为框架。创建程序时要使用 JFream</li><li>JApplet：创建小应用程序时要使用 JApplet。其被包含在浏览器窗口中</li><li>JDialog：创建对话框时使用 JDialog</li><li>JWindow：一个不带有标题行和控制按钮的窗口。一般很少使用</li></ul><p>构造方法：</p><ul><li><code>new JFrame()</code>：构造一个初始不可见，无标题的新框架窗体</li><li><code>new JFrame(&quot;Title&quot;)</code>：构造一个初始不可见，具有指定标题的新框架窗体</li></ul><p>常用方法：</p><ul><li><p><code>void setBounds(int x, int y, int width, int height)</code>：移动并调整框架大小。框架左上角位置为（x, y），框架大小为 width × height</p></li><li><p><code>void setSize(int width, int height)</code>：设置窗口大小</p></li><li><p><code>void setBackground(Color bg)</code>：设置框架背景色</p><p>  <code>void setForeground(Color fg)</code>：设置框架前景色</p></li><li><p><code>void setVisible(boolean aFlag)</code>：设置可见性</p></li><li><p><code>void pack()</code>：自适应框架大小，以符合子组件的首选大小和布局</p></li><li><p><code>void setTitle(String title)</code>：设置标题</p></li><li><p><code>Container getContentPane()</code>：返回此框架窗体的内容窗格对象</p><p>  <em>Container 类是所有容器类的父类，包含容器的共有操作</em></p><p>  <code>void setContentPane(Container contentPane)</code>：把指定内容窗格设置为此框架的内容窗格对象</p></li><li><p><code>void setLayout(LayoutManager manager)</code>：设置布局管理器</p></li></ul><p> <em><strong>—— 哦我的上帝啊，如果有什么名词是你不懂的，为什么不试着继续看下去呢？</strong></em></p><h3><span id="1512-内容窗格">15.1.2 内容窗格</span></h3><blockquote><p>4 个顶层容器每个都有 1 个内容窗格。除菜单外，顶层容器的所有组件都放在这个内容窗格内。</p></blockquote><ul><li><p>直接添加组件至内容窗格</p><pre><code>Container contentPane = jframe.getContentPane();//[1] 获取内容窗格对象contentPane.add(button, BorderLayout.CENTER);//[2] 将组件添加到内容窗格JAVA</code></pre><blockquote><ol><li><p>使用顶层容器的 <code>getContentPane()</code> 方法获得其内容窗格对象。</p></li><li><p>将组件添加到内容窗格。</p><p> 其中 button 是一个按钮控件，BorderLayout.CENTER 代表位置在中间</p><p> 向顶层容器内容窗格添加组件时，也可以直接调用顶层容器的 add() 方法</p></li></ol></blockquote></li><li><p>以新的内容窗格代替原有内容窗格</p><pre><code>JPanel contentPane = new JPanel();//[1] 创建 JPanel 实例contentPane.setLayout(new BorderLayout());//[2] 创建布局管理器contentPane.add(button, BorderLayout.CENTER);//[3] 添加组件jfream.setContentPane(contentPane);//[4] 添加内容窗格JAVA</code></pre><blockquote><ol><li>创建 JPanel（面板）实例。JPanel 是 Container 的子类。</li><li>顶层容器默认的布局管理器是 BorderLayout，而 JPanel 的默认布局管理器是 FlowLayout</li><li>通过 <code>setContentPane(contentPane)</code> 方法为 jfream 设置新的内容窗格</li></ol></blockquote></li></ul><h3><span id="1513-面板">15.1.3 面板</span></h3><blockquote><p>普通面板（JPanel）和滚动面板（JScrollPanel）都是用途广泛的容器。面板与顶层容器不同，不能独立存在，而必须添加到其他容器内部。面板可以嵌套，由此可以设计出复杂的图形用户界面。</p></blockquote><h4><span id="15131-jpanel">#15.1.3.1 JPanel</span></h4><p><strong>构造方法：</strong></p><ul><li><code>new JPanel()</code>：创建具有 FlowLayout 布局的新面板</li><li><code>new JPanel(LayoutManager layout)</code>：创建指定布局的新面板</li></ul><p><strong>常用方法：</strong></p><ul><li><code>Component add(Compinent comp)</code>：将指定组件添加至面板</li></ul><h4><span id="15132-jscrollpanel">#15.1.3.2 JScrollPanel</span></h4><p>JScrollPanel 是一个带有滚动条的面板，但只能添加一个组件。添加多个组件的场合，先将那些组件添加入 JPanel 对象，再将该 JPanel 对象添加进 JScrollPanel 对象中</p><p><strong>构造方法：</strong></p><ul><li><code>new JScrollPanel()</code>：创建一个空的 JScrollPanel。水平、垂直滚动条都能显示</li><li><code>new JScrollPanel(Component view)</code>：创建指定组件内容的 JScrollPanel</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void setHorizontalScrollBarPolicy(int policy)</code>：确定水平滚动条何时显示</p><p>  其中 policy 的可选值是以下三种：</p><ul><li>ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED：需要时可见</li><li>ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER：永远不可见</li><li>ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS：永远可见</li></ul></li><li><p><code>void setVerticalScrollBarPolicy(int policy)</code>：确定垂直滚动条何时显示</p><p>  其中 policy 的可选值是以下三种：</p><ul><li>ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED：需要时可见</li><li>ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER：永远不可见</li><li>ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS：永远可见</li></ul></li></ul><h4><span id="15133-scrollbar">#15.1.3.3 Scrollbar</span></h4><p>AWT 中还有一个滚动条组件，提供了允许用户在一定范围的值中进行选择的便捷方式</p><p><strong>构造器：</strong></p><ul><li><p><code>new Scrollbar()</code>：构造一个新的滚动条</p></li><li><p><code>new Scrollbar(int orientation)</code>：构造一个有指定方向的滚动条</p><p>  其中 orientation 的可选值是：</p><ul><li>Scrollbar.HORIZONTAL：水平滚动条</li><li>Scrollbar.VERTICAL：垂直滚动条</li></ul></li><li><p><code>new Scrollbar(int orientation, int value, int visible, int minimum, int maximun)</code>：构造一个有初始方向、初始值、可视量、最小&#x2F;最大值的滚动条</p></li></ul><h2><span id="152-标签和按钮">15.2 标签和按钮</span></h2><h3><span id="1521-标签">15.2.1 标签</span></h3><blockquote><p>标签（JLable）是最简单的 Swing 组件，通常用于显示提示性的文本信息或图标。其不可被编辑</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new JLable()</code>：构造一个不显示文本或图标的空标签</p></li><li><p><code>new JLable(Icon image)</code>：构造一个显示图标的标签</p></li><li><p><code>new JLable(String text)</code>：构造一个显示文本的标签</p></li><li><p><code>new JLable(Icon image, int horizontalAlignment)</code>：构造一个显示图标的标签，并指定水平对齐方式</p><p>  其中 horizontalAlignment 的取值可以是：</p><ul><li>JLable.LEFT：左对齐</li><li>JLable.RIGHT：右对齐</li><li>JLable.CENTER：居中对齐</li></ul></li><li><p><code>new JLable(String text, int horizontalAlignment)</code>：构造一个显示文本的标签，并指定水平对齐方式</p></li><li><p><code>new JLable(String text, Icon image, int horizontalAlignment)</code>：构造一个同时显示文本和图标的标签，并指定水平对齐方式</p></li></ul><h3><span id="1522-按钮">15.2.2 按钮</span></h3><blockquote><p>按钮（JButton）是 Java 图形用户界面的基本组件之一。</p><p>经常用到的按钮有 4 种形式：按钮（JButton）、切换按钮（JToggleButton）、复选按钮（JCheckButton）、单选按钮（JRadioButton）</p><p>这些按钮类均是 AbstractButton 的子类或间接子类</p></blockquote><h4><span id="15221-jbutton">#15.2.2.1 JButton</span></h4><p><strong>构造器：</strong></p><ul><li><code>new JButton()</code>：构造一个既没有文本也没有图标的按钮</li><li><code>new JButton(Icon icon)</code>：构造一个有图标的按钮</li><li><code>new JButton(String text)</code>：构造一个有文本的按钮</li><li><code>new JButton(String text, Icon icon)</code>：构造一个有文本也有图标的按钮</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void setMnemonic(int mnemonic)</code>：设置当前按钮的键盘助记符</p></li><li><p><code>void setText(String text)</code>：设置按钮的文本</p><p>  <code>void setIcon(Icon icon)</code>：设置按钮图标</p></li><li><p><code>void setEnabled(boolean mod)</code>：是否启用按钮</p></li><li><p><code>String getText()</code>：返回按钮的文本</p></li><li><p><code>void setToolTipText()</code>：设置提示文本</p></li><li><p><code>void addActionListener(ActionListener l)</code>：为按钮添加事件监听程序</p><p>  <code>void removeActionListener(ActionListener l)</code>：移除事件监听程序</p></li></ul><h4><span id="15222-jtogglebutton-jcheckbutton-jradiobutton">#15.2.2.2 JToggleButton、JCheckButton、JRadioButton</span></h4><blockquote><p>JToggleButton 是有两种状态（选中状态、未选中状态）的按钮。通过点击切换这两种状态</p><p>JCheckButton、JRadioButton 是 JToggleButton 的子类，构造方法与 JToggleButton 相同。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new JToggleButton()</code>：构造一个没有文本也没有图标的切换按钮</p></li><li><p><code>new JToggleButton(Icon icon)</code>：构造一个有图标的切换按钮</p><p>  <code>new JToggleButton(Icon icon, boolean selected)</code>：构造一个有图标的切换按钮，设置其初始状态</p></li><li><p><code>new JToggleButton(String text)</code>：构造一个有文本的切换按钮</p><p>  <code>new JToggleButton(String text, boolean selected)</code></p></li><li><p><code>new JToggleButton(String text, Icon icon)</code>：构造一个有文本也有图标的切换按钮</p><p>  <code>new JToggleButton(String text, Icon icon, boolean selected)</code></p></li></ul><p><strong>常用方法（除 JButton 方法外）：</strong></p><ul><li><p><code>boolean isSeleced()</code>：获取按钮的当前状态</p></li><li><p><code>void addItemListener(ItemListener l)</code>：为按钮添加事件侦听程序</p><p>  <code>void removeItemListener(ItemListener l)</code>：移除事件侦听程序</p></li></ul><h2><span id="153-布局管理器">15.3 布局管理器</span></h2><blockquote><p>容器中包含了组件。组件的布局，包括其位置和大小，通常由布局管理器负责安排。每个容器都有一个默认的布局管理器。</p></blockquote><h3><span id="1531-flowlayout-流布局管理器">15.3.1 FlowLayout 流布局管理器</span></h3><blockquote><p>FlowLayout 定义在 java.awt 包中。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new FlowLayout()</code>：创建默认的 FlowLayout 布局管理器。</p><p>  居中对齐。默认水平、垂直间距是 5 像素</p></li><li><p><code>new FlowLayout(int align)</code>：创建一个 FlowLayout 布局管理器。</p><p>  指定对齐方式。默认水平、垂直间距是 5 像素</p><p>  align 的可选值有这些：</p><ul><li>FlowLayout.LEFT：左对齐</li><li>FlowLayout.RIGHT：右对齐</li><li>FlowLayout.CENTER：居中对齐</li></ul></li><li><p><code>new FlowLayout(int align, int hgap, int vgap)</code>：创建一个 FlowLayout 布局管理器。</p><p>  指定对齐方式。指定水平、垂直间距</p></li></ul><p><strong>使用说明：</strong></p><ol><li>FlowLayout 对容器中组件进行布局的方式是将组件逐个放置在容器中的一行上。一行满后，另起一行。</li><li>与其他布局管理器不同。FlowLayout 不会强行设定组件的大小，而是通过每个组件的 getPreferredSize() 方法获取其各自的期望大小</li></ol><h3><span id="1532-borderlayout-边界布局管理器">15.3.2 BorderLayout 边界布局管理器</span></h3><blockquote><p>BorderLayout 定义在 java.awt 包中，是顶层容器的默认布局管理器。它提供了一种较为复杂的组件布局管理方案。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new BorderLayout()</code>：一个组件间没有间距的布局管理器</li><li><code>new BorderLayout(int hgap, int vgap)</code>：定义水平、垂直间距的布局管理器</li></ul><p><strong>使用说明：</strong></p><ol><li>每个由 BorderLayout 管理的容器被划分成 5 个区域，分别是容器的 上部（BorderLayout.NORTH）、下部（BorderLayout.SOUTH）、左部（BorderLayout.WEST）、右部（BorderLayout.EAST）、中部（BorderLayout.CENTER）</li><li>在 BorderLayout 布局管理器的管理下，组件必须通过 add() 方法加入容器的指定区域。不指定的场合，默认加入中部区域</li><li>容器的每个区域仅能加入一个组件。加入了多个组件的场合，只有最后一个生效</li><li>对于中部以外的 4 个边界区域，没有使用的区域的大小将变为零。此时，中部区域会扩展并占据该未用区域的位置。如果 4 个边界区域都没有使用，中部区域会占据整个窗口。</li><li>窗口大小改变时，按钮的相对位置不会变化。但按钮的大小会改变</li></ol><h3><span id="1533-gridlayout-网格布局管理器">15.3.3 GridLayout 网格布局管理器</span></h3><blockquote><p>GridLayout 定义在 java.awt 包中，是一种网格式的布局管理器。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new GridLayout()</code>：创建一个一行的网格。列数根据实际需要决定</p></li><li><p><code>new GridLayout(int rows, int cols)</code>：指定行数、列数的网格布局</p><p>  rows 和 cols 中，最多有一个可以是 0，但不能都为 0。那个为 0 的场合，根据实际需要决定数量</p></li><li><p><code>new GridLayout(int rows, int cols, int hgap, int vgap)</code>：指定行数、列数，也指定水平、垂直间距的网格</p></li></ul><p><strong>使用说明：</strong></p><ol><li><p>GridLayout 将容器空间划分成若干行乘若干列的网格。组件依次放入其中，每个组件占据一格</p></li><li><p>网格每列宽度相同，每行高度相同。组件放入的次序决定了其位置</p></li><li><p>想要组件间留有空白的场合，可以添加一个空白标签</p></li><li><p>网格数多于组件数的场合，那些多余的格子为空白。</p><p> 网格数少于组件数的场合，系统根据需要适当添加。</p></li><li><p>窗口大小改变时，按钮的相对位置不会变化。但按钮的大小会改变</p></li></ol><h3><span id="1534-cardlayout-卡片式布局管理器">15.3.4 CardLayout 卡片式布局管理器</span></h3><blockquote><p>CardLayout 定义在 java.awt 包中，是一种卡片式的布局管理器。</p></blockquote><p><strong>构造器：</strong></p><ul><li><code>new CardLayout()</code>：一个默认无间距的 CardLayout 布局管理器</li><li><code>new CardLayout(int hgap, int vgap)</code>：指定水平、垂直间距的 CardLayout 布局管理器</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void first(Container parent)</code>：翻转到容器的第一张卡片</p><p>  <code>void next(Container parent)</code>：翻转到下一张卡片。当前是最后一张的场合，翻到第一张卡片</p><p>  <code>void previous(Container parent)</code>：翻转到前一张卡片。当前是第一张的场合，翻到最后一张卡片</p><p>  <code>void last(Container parent)</code>：翻转到容器的最后一张卡片</p></li><li><p><code>void show(Container parent, String name)</code>：翻转到卡片集中具有指定 name 的卡片。没有该卡片的场合不执行任何操作</p></li></ul><p><strong>使用说明：</strong></p><ol><li>CardLayout 将容器中的组件处理为一系列卡片，每一刻只显示其中一张。</li><li>容器第一次显示时，显示第一个添加的组件。</li></ol><h3><span id="1535-boxlayout-方框布局管理器">15.3.5 BoxLayout 方框布局管理器</span></h3><blockquote><p>BoxLayout 定义在 javax.swing 包中，其组件横排一行或竖排一列，但宽度（高度）可以不同。</p></blockquote><p><strong>构造器：</strong></p><ul><li><p><code>new BoxLayout(Container target, int axis)</code>：创建一个沿给定轴放置组件的布局管理器</p><p>  其中 target 表明为哪个容器设置此布局管理器，axis 指明组件排列方向</p><p>  axis 的值是：</p><ul><li>BoxLayout.X_AXIS：水平方向排列</li><li>BoxLayout.Y_AXIS：竖直方向排列</li></ul><p>  举个例子：</p><blockquote><pre><code>JPanel jp = new JPanel();jp.setLayout(new BoxLayout(jp, BoxLayout.X_AXXIS));JAVA</code></pre></blockquote></li></ul><p><strong>使用说明：</strong></p><ol><li>BoxLayout 将容器中的组件横排一行或竖排一列。那些组件横排一行时，可以有不同宽度；竖排一列时，可以有不同的高度。</li><li>窗口大小改变时，按钮的相对位置不会变化。</li></ol><p><strong>Box 类</strong></p><blockquote><p>javax.swing 中定义了一个专门使用 BoxLayout 的容器 Box 类。</p></blockquote><ul><li><p><code>static Box createHorizontalBox()</code>：返回一个使用水平方向的 BoxLayout 的 Box</p><p>  <code>static Box createVerticalBox()</code>：返回一个使用竖直方向的 BoxLayout 的 Box</p></li><li><p><code>static Component createHorizontalGlue()</code>：创建一个水平方向的不可视的组件（填满剩余空间）</p><p>  <code>static Component createVerticalGlue()</code></p></li><li><p><code>static Component createHorizontalStrut()</code>：创建一个水平方向的不可视的组件（指定宽高）</p><p>  <code>static Component createVerticalStrut()</code></p></li><li><p><code>static Component createRigidArea()</code>：创建一个不可视的组件，不大不小，尺寸真是好极了</p></li></ul><h3><span id="1536-空布局">15.3.6 空布局</span></h3><blockquote><p>其实也能不用布局管理器的，真的</p></blockquote><ol><li>调用容器的 <code>setLayout(null)</code> 将容器的布局管理器置空</li><li>调用组件的 <code>setBounds(x, y, w, h)</code> 方法设置其位置和大小。<del>老东西，你的布局管理器最没用啦！</del></li></ol><h2><span id="154-事件处理">15.4 事件处理</span></h2><blockquote><p>Java 运行时，如果用户进行某个操作，程序应当做出相应。</p><p>程 · 序 · 无 · 响 · 应（噔 噔 咚）</p><p>……总之，用户在程序界面进行的操作称为用户事件，对事件的相应称为事件处理。</p></blockquote><h3><span id="1541-事件处理模型">15.4.1 事件处理模型</span></h3><blockquote><p>Java 事件处理是采取 “委派事件模型”。&#x3D;&#x3D;当事件发生时，产生事件类对象。&#x3D;&#x3D;这里说的事件类对象实际上就是 <code>java.awt.event</code> 事件类库里某个类创建的对象。操作不同的场合，事件类对象不同。</p><p>会把此事件类对象传递给事件侦听程序处理。它是实现了对应侦听程序接口的一个类。</p><p>事件只是一个对象，其只向注册的侦听程序报告</p></blockquote><p>示范一个简单的事件处理：</p><pre><code class="java">import javax.seing.*;import java.awt.*;//[0]public class Code_15_4_1 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Button b = new Button(&quot;Button&quot;);        b.addActionListener((e) -&gt; System.out.println(&quot;Pressed&quot;));//[1]        JFrame jFrame = new JFrame(&quot;Test&quot;);        jFrame.setBounds(30, 30, 100, 100);        jFrame.add(b);        jFrame.setVisible(true);    &#125;&#125;</code></pre><blockquote><ol><li><p>引入 java.awt.event 包</p></li><li><p>注册事件侦听程序，并实现其方法</p><p> 示例中的简写其实相当于以下代码（匿名内部类）：</p><pre><code class="java">b.addActionListener(new ActionListener() &#123;    @OverRide    public void actionPerformed (ActionEvent e) &#123;        System.out.println(&quot;Pressed&quot;);    &#125;&#125;);</code></pre><p> <em><strong>—— 示例写法见 [27 Java8 新特性]</strong></em></p><p> 事件侦听程序可以定义在单独的类中，也可以定义在组件类中：</p><pre><code class="java">class MyButton extends JButton implements ActionListener&#123;    public MyButton() &#123;        addActionListener(this);    &#125;                                             @Override    public void actionPerformed(ActionEvent e) &#123;        System.out.println(&quot;Pressed&quot;);    &#125;&#125;</code></pre></li></ol></blockquote><h3><span id="1542-事件的种类">15.4.2 事件的种类</span></h3><blockquote><p>在 java.awt.event 包和 javax.swing.event 包中定义了很多其他的事件类。每种事件类有一个对应的接口，接口中声明了一个或多个抽象的事件处理方法。</p></blockquote><table><thead><tr><th>事件类</th><th>组件</th><th>方法及说明</th></tr></thead><tbody><tr><td>ActionEvent</td><td>JButton、JCheckBox、JComboBox、JMenuItem、JRaidoButton</td><td>actionPerformed(e) 单击按钮、选择菜单项或在文本框中按回车时</td></tr><tr><td>AdjustmentEvent</td><td>JScrollBar</td><td>adjustmentValueChanged(e) 当改变滚动条滑块位置时</td></tr><tr><td>ComponentEvent</td><td>JComponent 及其子类</td><td>componentMoved(e) 组件移动时；componentHidden(e) 组件隐藏时；componenetResized(e) 组件缩时；componentShown(e) 组件显示时</td></tr><tr><td>ContainerEvent</td><td>JContainer 及其子类</td><td>containerAdded(e) 添加组件时；containerMoved(e)移除组件时</td></tr><tr><td>FocusEvent</td><td>同 ComponentEvent</td><td>focusGained(e) 组件获得焦点时；focusLost(e) 组件失去焦点时</td></tr><tr><td>ItemEvent</td><td>JCheckBox、JCheckboxMenuItem、JComboBox</td><td>itemStateChanged(e) 选择复选框、选项框、单击列表框、选中带复选框菜单时</td></tr><tr><td>KeyEvent</td><td>同 ComponentEvent</td><td>keyPressed(e) 键按下时；keyReleased(e) 键释放时；keyTaped(e) 击键时</td></tr><tr><td>MouseEvent</td><td>同 ComponentEvent</td><td>mousePressed(e) 鼠标按下时；mouseEntered(e) 鼠标进入时；mouseExited(e) 鼠标离开时；mouseClicked(e) 鼠标点击时；mouseReleased(e) 鼠标释放时</td></tr><tr><td>MouseMotionEvent</td><td>同 ComponentEvent</td><td>mouseDragged(e) 鼠标拖放时；mouseMoved(e) 鼠标移动时</td></tr><tr><td>TextEvent</td><td>JTextField、JTextArea</td><td>textValueChanged(e) 文本框、多行文本框内容修改时</td></tr><tr><td>WindowEvent</td><td>JFrame、JWindow、JDialog</td><td>windowOpened(e) 窗口打开时；windowClosing(e) 窗口关闭时；windowClosed(e) 窗口关闭后；windowActived(e) 窗口激活时；windowDeactivated(e) 窗口失去焦点时；windowIconified(e) 窗口最小化时；WindowDeiconified(e) 窗口最小化还原时</td></tr></tbody></table><p>使用说明：</p><ol><li><p>XXXEvent 事件类的接口名就是 XXXListener。占地方太大，上面就没写</p></li><li><p>事件侦听模式允许为一个组件多次调用 addListener 方法，注册多个侦听程序。</p><p> 事件发生时，单个事件的多个侦听程序的调用顺序不确定。</p></li><li><p>调用事件处理方法时会传入一个参数。该参数就是那些事件类实例，其中包含事件有关的重要信息。</p><p> 调用这些事件类实例各自特有的方法获取这些信息。</p></li></ol><h3><span id="1543-事件适配器">15.4.3 事件适配器</span></h3><blockquote><p>侦听程序必须实现接口的全部抽象方法，但有时我们只关心其中的某一种方法。为了编程方便，Java 为一些声明了多个抽象方法的 Listener 接口提供了相应的适配器类。</p></blockquote><table><thead><tr><th>接口名称</th><th>适配器名称</th></tr></thead><tbody><tr><td>ComponentListener</td><td>ComponentAdapter</td></tr><tr><td>ContainerListener</td><td>ContainerAdapter</td></tr><tr><td>FocusListener</td><td>FocusAdapter</td></tr><tr><td>KeyListener</td><td>KeyAdapter</td></tr><tr><td>MouseListener</td><td>MouseAdapter</td></tr><tr><td>MouseMotionListener</td><td>MouseMotionAdapter</td></tr><tr><td>MouseInputListener</td><td>MouseInputAdapter</td></tr><tr><td>WindowListener</td><td>WindowAdapter</td></tr></tbody></table><p>这些适配器实现了接口的全部抽象方法，只是方法内容为空</p><p>这样，创建新类时可以不必实现接口，而是继承适配器类，并重写需要的方法</p><h2><span id="155-java-绘图技术">15.5 Java 绘图技术</span></h2><blockquote><p>Java 语言约定，显示屏上一个长方形区域为程序绘图区域，坐标原点（0, 0）位于整个区域左上角。</p><p>一个坐标点（x, y）对应一个像素，其中坐标点的 x、y 必须是非负整数。x 沿水平方向从左向右递增、y 沿竖直方向从上往下递增</p></blockquote><h3><span id="1551-颜色">15.5.1 颜色</span></h3><blockquote><p>可以使用 java.awt 包中的 Color 类来定义和管理颜色。Color 类的每个对象代表一种颜色。</p></blockquote><p>Color 类有 26 个常量，代表 13 种预定义颜色：</p><table><thead><tr><th>颜色</th><th>对象</th><th>ᓚᘏᗢ</th></tr></thead><tbody><tr><td>黑色（#000000）</td><td>Color.black</td><td>Color.BLACK</td></tr><tr><td>蓝色（#0000FF）</td><td>Color.blue</td><td>Color.BLUE</td></tr><tr><td>青色（#00FFFF）</td><td>Color.cyan</td><td>Color.CYAN</td></tr><tr><td>灰色（#808080）</td><td>Color.gray</td><td>Color.GRAY</td></tr><tr><td>深灰色（#404040）</td><td>Color.darkGary</td><td>Color.DARKGARY</td></tr><tr><td>浅灰色（#C0C0C0）</td><td>Color.lightGary</td><td>Color.LIGHTGARY</td></tr><tr><td>绿色（#00FF00）</td><td>Color.green</td><td>Color.GREEN</td></tr><tr><td>洋红色（#FF00FF）</td><td>Color.magenta</td><td>Color.MAGENTA</td></tr><tr><td>橙色（#FFC800）</td><td>Color.orange</td><td>Color.ORANGE</td></tr><tr><td>粉红色（#FFAFAF）</td><td>Color.pink</td><td>Color.PINK</td></tr><tr><td>红色（#FF0000）</td><td>Color.red</td><td>Color.RED</td></tr><tr><td>白色（#FFFFFF）</td><td>Color.write</td><td>Color.WRITE</td></tr><tr><td>黄色（#FFFF00）</td><td>Color.yellow</td><td>Color.YELLOW</td></tr></tbody></table><p>也可以通过红、绿、蓝三原色值来组合。每种颜色由三个值组成（RGB），值的范围是 [0, 256)：</p><pre><code class="java">Color color = new Color(102, 204, 255);</code></pre><blockquote><p>这个颜色是：天依蓝（#66CCFF）</p><p>这部分笔记恐怕是所有 Java 笔记里唯一有五颜六色的地方了，真难得</p></blockquote><h3><span id="1552-字体"><em>15.5.2 字体</em></span></h3><blockquote><p>文字有 字体、样式、字号 三个要素</p></blockquote><p>基本的样式有：</p><ul><li><p>Font.PLAIN：正常（0）</p></li><li><p>Font.BOLD：<strong>粗体</strong>（1）</p></li><li><p>Font.ITALIC：<em>斜体</em>（2）</p><p>  样式可以组合使用，如 (Font.BOLD + Font.ITALIC) 即 <em><strong>粗斜体</strong></em></p></li></ul><p>常用的字体：Times New roman（Times New roman）、Symbol（Symbol）、宋体（宋体）、楷体（楷体）等</p><p><strong>构造器：</strong></p><ul><li><code>new Font(String name, int style, int size)</code>：新建字体，指定字体、样式、字号</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>String getName()</code>：返回其字体名称</p><p>  <code>int getSize()</code>：返回其字号大小</p><p>  <code>int getStyle()</code>：返回其样式</p></li><li><p><code>boolean isBold()</code>：是否是粗体</p><p>  <code>boolean isItalic()</code>、<code>boolean isPlain()</code></p></li></ul><h3><span id="1553-graphics-类">15.5.3 Graphics 类</span></h3><blockquote><p>java.awt 包下的 Graohics 类是所有图形处理的基础，是所有图形上下文的抽象父类。其允许应用程序在组件及屏幕图像上进行绘制。</p></blockquote><p>当先后绘制的图形不同时，确定重叠部分颜色的方法称为绘图模式。</p><p>绘图模式分为两种：</p><ul><li><p>正常模式：<code>setPaintMode()</code></p><p>  后绘制的图形覆盖先绘制的图形。</p></li><li><p>异或模式：<code>setXORMode(Color c)</code></p><p>  当前绘制的颜色、先前绘制的颜色 及 选定的颜色 c 之间进行某种处理后，用新的颜色绘制。</p><p>  这个模式下，如果使用同一颜色绘制 2 次，则相当于擦除之前绘制的图形，即恢复原本状态。</p></li></ul><p>若要在某个组件中绘图，应重写该组件的 paint(Graphics g) 方法，并在重写的方法内进行绘图。</p><ul><li><p><code>paint(Graphics g)</code>：组件被显示出来时，调用该方法</p><p>  以下情况该方法会被调用</p><ul><li>组件第一次在屏幕显示时</li><li>窗口最小化&#x2F;最大化</li><li>窗口大小发生变化</li><li><code>repaint</code> 函数被调用</li></ul></li><li><p><code>repaint()</code>：重绘组件</p><p>  该方法默认情况下会调用以下方法</p><ul><li><p><code>paintCompnent(Graphics g)</code>：绘制组件</p><p>  一般情况下，要在 JComponent 子类的组件中绘图，重写该方法即可</p></li><li><p><code>paintBorder(Graphics g)</code>：绘制组件边框</p></li><li><p><code>paintChildren(Graphics g)</code>：绘制组件的子组件</p></li></ul></li></ul><p><strong>设置画笔：</strong></p><ul><li><p><code>setColor(Color c)</code>：设置画笔前景色</p><p>  <code>setBackgroud(Color c)</code>：设置背景色</p><p>  每个图形环境都有一种画图时正在使用的前景色。画图所在的每个表面都有背景色</p></li><li><p><code>setFont(Font f)</code>：设置画笔字体</p></li></ul><p><strong>绘制几何图案：</strong></p><ul><li><p><code>drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)</code>：绘制弧线</p><p>  该弧线是 沿着起始点为 (x, y)、宽 width、高 height 的矩形所限定的椭圆 绘制一条弧线。</p><p>  该弧线起始角度为 startAngle，弧度角度为 arcAngle</p><p>  <code>fillArc(int x, int y, int width, int height, int startAngle, int arcAngle)</code>：填充扇形</p></li><li><p><code>drawLine(int x1, int y1, int x2, int y2)</code>：绘制线段</p><p>  该线段的两个端点是 (x1, y1) 和 (x2, y2)</p></li><li><p><code>drawOval(int x, int y, int width, int height)</code>：绘制椭圆</p><p>  一个起始点为 (x, y)、宽 width、高 height 的矩形所限定的椭圆</p><p>  <code>fillOval(int x, int y, int width, int height)</code>：填充椭圆</p></li><li><p><code>drawPolygon(int[] xPoints, int[] tPoints, int nPoints)</code>：绘制多边形</p><p>  <code>drawPolygon(Polygon p)</code>：也能通过传入一个 Polygon 对象来绘制多边形</p><p>  该图形的端点由传入参数确定。如果最后一个端点和第一个端点不相等，那么图形可能不闭合</p><p>  <code>fillPolygon(int[] xPoints, int[] tPoints, int nPoints)</code>：填充多边形</p><p>  <code>fillPolygon(Polygon p)</code>：通过传入一个 Polygon 对象来填充多边形</p><p>  低情商：这咋填充？高情商：留给读者们思考吧</p></li><li><p><code>drawRect(int x, int y, int width, int height)</code>：绘制矩形</p><p>  一个起始点为 (x, y)、宽 width、高 height 的矩形</p><p>  <code>fillRect(int x, int y, int width, int height)</code>：填充矩形</p></li><li><p><code>drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)</code>：圆角矩形</p><p>  一个起始点为 (x, y)、宽 width、高 height 的矩形，其圆角形状由 arcWidth、arcHeight 确定</p><p>  其实就是矩形（线段）和椭圆（圆弧）的某种拼接</p><p>  <code>fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight)</code>：填充圆角矩形</p></li><li><p><code>drawString(String str, int x, int y)</code>：输出字符串</p><p>  在 (x, y) 处输出字符串 str，向右扩展</p><p>  <code>drawChars(char[] chars, int offSet, int length, int x, int y)</code>：输出字符串</p><p>  从字符数组的 offSet 下标处起，在 (x, y) 处输出 length 个字符，向右扩展</p><p>  <code>drawBytes(byte[] data, int offSet, int length, int x, int y)</code>：还不是一样？</p></li><li><p><code>draw3DRect(int x, int y, int width, int height, boolean raised)</code>：绘制 3D 矩形</p><p>  <code>fill3DRect(int x, int y, int width, int height, boolean raised)</code>：填充 3D 矩形</p><p>  我感觉是和 PS 里的浮雕效果类似，生成了亮部和暗部。rasied 决定是凸起还是凹陷。</p></li></ul><h4><span id="15531-polygon-类">#15.5.3.1 Polygon 类</span></h4><blockquote><p>Polygon 对象封装了多边形的坐标。</p></blockquote><p>构造方法：</p><ul><li><p><code>new Polygon()</code>：构造一个空的多边形。</p><p>  无为太虚，无生一，一生二，二生三，三生万物。所以，空的多边形也是多边形。</p></li><li><p><code>new Polygon(int[] xs, int[] ys, int n)</code>：构造一个 n 点连接成的多边形</p></li></ul><p>常用方法：</p><ul><li><p><code>addPoint(int x, int y)</code>：将该点加入多边形中</p></li><li><p><code>boolean contains(int x, int y)</code>：如果多边形包含该点，则返回真</p><p>  <code>boolean contains(Point p)</code></p></li><li><p><code>get Bounds()</code>：得到多边形的外接矩形</p></li><li><p><code>translate(int dx, int dy)</code>：偏移</p><p>  将多边形各点沿 x 轴偏移 dx，再沿 y 轴偏移 dy</p></li></ul><h3><span id="1554-graphics2d-类">15.5.4 Graphics2D 类</span></h3><blockquote><p>为了解决图形对象的局限性，Java 1.1 后 引入了 Java 2D，其包含一个继承自 Graphics 的 Graphics2D 类，增加了很多状态属性，扩展了 Java 的绘图功能</p><p>Graphics2D 拥有强大的二维图形处理能力，提供对几何形状、坐标转换、颜色管理、文字布局等更复杂的控制</p></blockquote><h4><span id="15541-图形状态属性">#15.5.4.1 图形状态属性</span></h4><blockquote><p>通过设定和修改属性，可以指定画笔宽度和画笔连接方式、设定平移、旋转、缩放或裁剪变换图形，还能设置填充图形的颜色和图案等。</p></blockquote><p><strong>状态属性：</strong></p><ul><li><p><strong>stroke 属性：</strong></p><p>  该属性控制线宽、笔形样式、线段连接方式、短划线图案。</p><p>  使用 <code>setStroke(Stroke s)</code> 方法设置 stroke 属性。</p><p>  构造方法：</p><ul><li><p><code>new BasicStroke(float w)</code>：指定线宽的 stroke</p></li><li><p><code>new BasicStroke(float w, int cap, int join)</code>：指定线宽、端点样式 cap、线段交汇方式 join 的 stroke</p><p>  其中，端点样式 cap 的值可以是：</p><ul><li>BasicStroke.CAP_BUTT：无修饰（0）</li><li>BasicStroke.CAP_ROUND：半圆形末端（1）</li><li>BasicStroke.CAP_SQUARE：方形末端（2，默认值）</li></ul><p>  线段交汇方式 join 的值可以是：</p><ul><li>BasicStroke.JOIN_BEVEL：无修饰（2）</li><li>BasicStroke.JOIN_MITER：尖型末端（0，默认值）</li><li>BasicStroke.JOIN_ROUND：圆形末端（1）</li></ul></li></ul></li><li><p><strong>paint 属性：</strong></p><p>  该属性控制填充效果。</p><p>  使用 <code>setPaint(Paint p)</code> 方法设置 paint 属性</p><p>  构造方法：</p><ul><li><p><code>new GradientPaint(float x1, float y1, Color c1, float x2, float y2, Color c2)</code>：构造一个简单的非周期性的 paint 对象。</p><p>  从点 (x1, y1) 至点 (x2, y2) 处，颜色由 c1 渐变至 c2</p></li><li><p><code>new GradientPaint(float x1, float y1, Color c1, float x2, float y2, Color c2, boolean cyclic)</code>：构造一个周期或非周期性的 paint 对象。</p><p>  如果希望渐变至终点又是起点的颜色，将 cyclic 设定为 true</p></li></ul></li><li><p><strong>transform 属性：</strong></p><p>  该属性用来实现常用的图形平移、缩放、斜切等</p><p>  使用 <code>setTransform(Transform t)</code> 方法设置 transform 属性</p><p>  构造方法：</p><ul><li><p><code>new AffineTransform()</code>：构造一个表示仿射变换的新的 tansform</p><p>  <em>仿射变换：用我的话来讲，就是保持坐标点不变的情况下变换坐标系，能形成的变换</em></p></li></ul><p>  常用方法：</p><ul><li><p><code>setToRotation(double theta)</code>：旋转 theta 角度</p><p>  <code>setToRotation(double theta, double x, double y)</code>：以 (x, y) 为旋转中心旋转</p><p>  <code>rotate(double theta, double x, double y)</code></p></li><li><p><code>setToScale(double sx, double sy)</code>：拉伸变换</p><p>  x、y 方向按照 sx、yx 比例变换</p><p>  <code>scale(double sx, double sy)</code></p></li><li><p><code>setToTranslation(double tx, double ty)</code>：平移变换</p><p>  <code>translate(double tx, double ty)</code></p></li><li><p><code>setToShear(double shx, double shy)</code>：斜切变换</p><p>  shx、shy 分别指定 x、y 方向的斜拉度</p></li></ul><p>  看得出来，出版社的人写到这里应该是到了下班的点了。内容不明不白的不说，还写错了好几处。</p><p>  我笔记上是改过来的。放心。</p><p>  就这还 ”指定教材“ 呢。垃圾，还没我笔记写得好。</p></li><li><p><strong>clip 属性：</strong></p><p>  该属性用于实现剪裁效果。</p><p>  使用 <code>setClip(Shape clip)</code> 方法，确定裁剪区域的 Shape。可以连续使用该方法以得到其交集区域</p></li><li><p><strong>composit 属性：</strong></p><p>  该属性设置图形重叠区域的效果</p><p>  通过 <code>Alpha.Composite.getInstance(int rule, float alpha)</code> 得到一个实例。其中 alpha（透明度）的范围是 [0.0f, 1.0f]</p><p>  至于 rule 是什么……我也不知道。或许不重要吧</p><p>  通过 <code>setComposite(Composite comp)</code> 设置混合效果</p></li></ul><h4><span id="15542-graphics2d-的绘图方法">#15.5.4.2 Graphics2D 的绘图方法</span></h4><blockquote><p>Graphics2D 保留了 Graphics 的绘图方法，又增加了很多新方法</p><p>另外，在 java.awt.geom 中声明了一系列类，能用于创建各种几何图形对象，包括：Line2D 线段类、Rectangle2D 矩形类、RoundRectangle2D 圆角矩形类、Ellipse2D 椭圆类、Arc2D 圆弧类、QuadCurve2D 二次曲线类、CubicCurve2D 三次曲线类</p><p>这些类都是抽象类，但这些类包中有实现了其方法的 Double 类。</p></blockquote><pre><code class="java">...@OverRidepublic void paintComponents(Graphics g) &#123;    Graphics2D g2d = (Graphics2D)g;//[1]    Line2D line = new Line2D.Double(5, 5, 5, 5);//[2]    g2d.draw(line);//[3]&#125;</code></pre><blockquote><ol><li><p>将 Graphics 对象强制转型为 Graphics2D 对象</p></li><li><p>创建几何图形对象</p><p> 这里的 Line2D.Double 表示 Line2D 包下的 Double 类。此处调用了 Double 类的构造器</p></li><li><p>绘制线段</p></li></ol></blockquote><h4><span id="15543-graphics2d-中的几何图形类">#15.5.4.3 Graphics2D 中的几何图形类</span></h4><ul><li><p><code>new Line2D.Double(int x1, int y1, int x2, int y2)</code>：线段</p><p>  从 (x1, y1) 到 (x2, y2) 的线段</p></li><li><p>……（略了略了。相信椭圆、矩形之类的也不用再详细说明了吧）</p></li><li><p><code>new Arc2D.Double(double x, double y, double w, double h, double start, double extent, int type)</code>：弧</p><p>  但是特别地，type 的值是以下几种：</p><ul><li>Arc2D.OPEN：开弧</li><li>Arc2D.CHORD：弓弧</li><li>Arc2D.PIE：饼弧</li></ul></li><li><p><code>new QuadCurver2D.Double(double x1, double y1, double ctrlx, double ctrly, double x2, double y2)</code>：绘制二次曲线</p><p>  绘制二次曲线需要 3 个点，分别是起始点 (x1, y1)、终点 (x2, y2)、控制点 (ctrlx, ctrly)</p></li><li><p><code>new CubicCurve2D.Double(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2, double y2)</code>：绘制三次曲线</p><p>  绘制三次曲线需要 4 个点，分别是起始点、终点、两个控制点</p></li></ul><h2><span id="156-组合框与列表">15.6 组合框与列表</span></h2><h3><span id="1561-jcombobox-组合框">15.6.1 JComboBox 组合框</span></h3><blockquote><p>JComboBox 是一个下拉式菜单。它有两种模式：可编辑的、不可编辑的。</p><p>对于不可编辑的 JComboBox，用户只能在现有列表中进行选择</p><p>对于可编辑的 JComboBox，用户既能在现有选项中选择，也能输入新的内容</p></blockquote><p><strong>构造方法：</strong></p><ul><li><p><code>new JComboBox&lt;E&gt;()</code>：创建一个 E 类型（泛型）的没有任何可选项的默认组合框</p></li><li><p><code>new JComboBox&lt;E&gt;(E[] items)</code>：根据 items 数组创建组合框</p><p>  items 数组元素即为组合框的可选项</p></li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void setEditable(boolean aFlag)</code>：设置可编辑性</p><p>  不设置的场合，默认处于不可编辑状态</p></li><li><p><code>void addItem(E item)</code>：在末尾添加可选项</p><p>  <code>void insertItemAt(E item, int index)</code>：在指定下标处添加可选项</p></li><li><p><code>void removeAllItems()</code>：删除所有可选项</p><p>  <code>void removeItem(E iten)</code>：删除 item 指定的可选项</p><p>  <code>void removeItemAt(int index)</code>：删除指定下标处的可选项</p></li><li><p><code>E getItemAt(int index)</code>：获取指定下标的可选项</p></li><li><p><code>int getItemCount()</code>：获取列表项数</p></li><li><p><code>int getSelectedIndex()</code>：获取选中项匹配的第一个选项的索引下标</p><p>  <code>E getSelectedItem()</code>：获取选中项</p></li></ul><h3><span id="1562-jlist-列表">15.6.2 JList 列表</span></h3><blockquote><p>JList 是可供用户选择的一系列可选项</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new JList&lt;E&gt;()</code>：构造一个空列表</li><li><code>new JList&lt;E&gt;(E[] listData)</code>：构造一个列表，可选元素由 listData 指定</li><li><code>new JList&lt;E&gt;(Vector&lt;E&gt; listData)</code>：构造一个列表，使其显示指定 Vector 中的元素</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>addListSelectionListener(ListSelectionListener l)</code>：添加监视器</p><p>  当用户在列表上选择时，会触发 ListSelectionEvent 事件。</p><p>  在 ListSelectionListener 接口中，仅有一个方法：</p><pre><code class="java">void valueChanged(ListSelectionEvent e);</code></pre><p>  当列表的当前选项改变时，会调用该方法。</p></li><li><p><code>int getSelectedIndex()</code>：返回选中项第一次出现的下标索引</p><p>  没有选中项的场合，返回 -1</p><p>  <code>E getSelectedValue()</code>：返回所选的第一个值</p><p>  没有选中项的场合，返回 null</p></li><li><p><code>void setVisableRowCount(int count)</code>：设置不使用滚动条可以在列表中显示的选项行数</p></li><li><p><code>void setSelectionMode(int mode)</code>：设置列表的选择模式</p><p>  其中，mode 的值可以是以下几种：</p><ul><li>ListSelectionModel.SINGLE_SELECTION：仅支持单项选择（0）</li><li>ListSelectionModel.SINGLE_INTERVAL_SELECTION：可多选，但多个选项必须是连续的（1）</li><li>ListSelectionModel.MULTIPLE_INTERVAL_SELECTION：可多选（2，默认值）</li></ul></li></ul><h2><span id="157-文本组件">15.7 文本组件</span></h2><blockquote><p>文本组件可以提示信息和提供用户输入功能。Swing 中提供了 JTextField（文本域）、JPasswordField（口令输入域）、JTextArea（文本区）等多个文本组件。</p></blockquote><p>文本组件的共同的父类是 JTextComponent，其中定义了文本组件的共有方法：</p><ul><li><p><code>String getSelectedText()</code>：从文本组件中提取被选中的文本内容</p></li><li><p><code>String getText()</code>：从文本组件中提取全部文本内容</p><p>  <code>String getText(int offs, int len)</code>：从文本组件中提取指定范围的文本内容</p></li><li><p><code>void select(inr start, int end)</code>：在文本组件中选中指定范围内容</p><p>  <code>void selectAll()</code>：在文本组件中选中全部内容</p></li><li><p><code>void setEditable(boolean b)</code>：设置可编辑状态</p></li><li><p><code>void setText(String t)</code>：设置文本组件的文本内容</p></li><li><p><code>void setDocument(Document doc)</code>：设置文本组件的文档</p></li><li><p><code>void copy()</code>：复制选中文本至剪贴板</p><p>  <code>void cut()</code>：剪切选中文本至剪贴板</p><p>  <code>void paste()</code>：粘贴剪贴板内容至当前位置</p></li></ul><p>另外，JComponrnt 类中有如下方法：</p><ul><li><code>boolean requestFocusInWindow()</code>：请求当前组件获得输入焦点</li></ul><h3><span id="1571-jtextfield-文本域">15.7.1 JTextField 文本域</span></h3><blockquote><p>文本域是一个单行的文本输入框，可以用于输入少量文本</p></blockquote><p><strong>构造方法：</strong></p><ul><li><p><code>new JTextField()</code>：构造一个空文本域</p></li><li><p><code>new JTextField(int columns)</code>：构造一个指定列数的空文本域</p><p>  由于组件大小通常由布局管理器确定，因此指定的列数可能被忽略</p></li><li><p><code>new JTextField(String text)</code>：构造一个显示指定初始字符的文本域</p></li><li><p><code>new JTextField(String text, int columns)</code>：构造一个指定列数及初始字符的文本域</p></li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void addActionListener(ActionListener l)</code>：添加指定侦听器</p><p>  <code>void removeActionListener(ActionListener l)</code>：移除指定侦听器</p></li><li><p><code>void setFont()</code>：设置当前字体</p></li><li><p><code>void setHorizontalAlignment(int alignment)</code>：设置水平对齐方式</p><p>  有效值包括：</p><ul><li><p>JTextField.LEFT：左对齐（2）</p></li><li><p>JTextField.RIGHT：右对齐（4）</p></li><li><p>JTextField.CENTER：居中对齐（0）</p></li><li><p>JTextField.LEADING：领先对齐（10）</p><p>  （似乎是）识别文字前端的对齐方式……好吧，我也不太明白</p></li><li><p>JTextField.TRAILING：落后对齐（11）</p></li></ul></li><li><p><code>int getColumns()</code>：返回文本域列数</p></li></ul><h3><span id="1572-jtextarea-文本区">15.7.2 JTextArea 文本区</span></h3><blockquote><p>JTextArea 是一个多行多列的文本输入框</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new JTextArea()</code>：构造一个空文本区</li><li><code>new JTextArea(int rows, int columns)</code>：构造一个指定行数、列数数的空文本区</li><li><code>new JTextArea(String text)</code>：构造一个显示指定初始字符的文本区</li><li><code>new JTextArea(String text, int rows, int columns)</code>：构造一个指定行列数及初始字符的文本区</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>void append(String str)</code>：追加文本到文本区</p></li><li><p><code>void insert(String str, int pos)</code>：将指定文本插入到特定位置 pos 处</p></li><li><p><code>void replaceRange(String str, int start, int end)</code>：用指定文本 str 替换指定范围的文本</p></li><li><p><code>void addAncestorListener(AncestorListener listener)</code>：添加指定侦听器</p><p>  特别地，用户输入文本时，按下 Enter 键的场合只是向缓冲区输入一个字符，而不能表示输入的结束。因此，需要识别用户输入完成时，通常要在文本区旁放置一个确定按钮</p></li></ul><h2><span id="158-菜单组件">15.8 菜单组件</span></h2><blockquote><p>菜单是最常用的 GUI 组件之一。Swing 包中提供了多种菜单组件。</p><p>菜单有下拉式菜单和弹出式菜单两种</p></blockquote><h3><span id="1581-菜单栏及菜单">15.8.1 菜单栏及菜单</span></h3><blockquote><p>JMenuBar 菜单栏是窗口主菜单，用来包容一组菜单</p><p>通过容器的 <code>setJMenuBar(JMenuBar m)</code> 方法将菜单栏放到窗口上</p></blockquote><p><strong>菜单栏 JMenuBar 构造方法：</strong></p><ul><li><code>new JMenuBar()</code>：构建一个新的菜单栏</li></ul><p>菜单栏也能注册一些事件侦听程序，但通常情况下对于这些事件我们都不进行处理</p><p><strong>菜单构造方法：</strong></p><ul><li><code>new JMenu()</code>：构造没有文本的新菜单</li><li><code>new JMenu(String str)</code>：构造有指定标签的菜单</li><li><code>new JMenu(String str, boolean b)</code>：构造有指定标签的菜单，并指示其是否可以被分离</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>add(JMenu m)</code>：菜单可以被加入菜单栏或另一个菜单中</p></li><li><p><code>addSeparator()</code>：为菜单各项间加入间隔线</p><p>  <code>insertSeparator(int index)</code>：在指定位置插入间隔线</p><p>  也能通过这种方式插入间隔线：</p><pre><code class="java">menu.add(new JSeparator());//JSeparator 类即分割线类</code></pre></li></ul><h3><span id="1582-jmenuitem-菜单项">15.8.2 JMenuItem 菜单项</span></h3><blockquote><p>JMenuItem 菜单项是菜单系统的最下一级</p></blockquote><p><strong>构造方法：</strong></p><ul><li><p><code>new JMenuItem()</code>：创建不带有设置文本或图标的菜单项</p></li><li><p><code>new JMenuItem(Icon i)</code>：创建只有图标的菜单项</p></li><li><p><code>new JMenuItem(String str)</code>：创建只有文本的菜单项</p></li><li><p><code>new JMenuItem(String str, Icon i)</code>：创建有图标和文本的菜单项</p></li><li><p><code>new JMenuItem(String str, int mnemonic)</code>：创建有文本和快捷键的菜单项</p><p>  那个快捷键的有效值是 KeyEvent 包下的各种常量</p></li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>setMnemonic(int m)</code>：设置快捷键</p></li><li><p><code>setAccelerator(KeyStroke keyStroke)</code>：设置加速键</p></li><li><p><code>addActionListener(ActionListener l)</code>：加入侦听器</p><p>  菜单项被选中时，会触发 ActionEvent 事件</p></li></ul><h3><span id="1583-复选菜单项和单选菜单项">15.8.3 复选菜单项和单选菜单项</span></h3><blockquote><p>JCheckBoxMenuItem（复选菜单项）和 JRadioButtonMenuItem（单选菜单项）是两种特殊的菜单项。</p><p>JCheckBoxMenuItem 前有个小方框，以供提示复选</p><p>JRadioButtonMenuItem 前有个小圆圈，以供提示单选</p></blockquote><p><strong>复选菜单项构造器：</strong></p><ul><li><code>new JCheckBoxMenuItem()</code>：一个无文本图标，初始未选中的菜单项</li><li><code>new JCheckBoxMenuItem(Icon i)</code>：就是有图标咯</li><li><code>new JCheckBoxMenuItem(String str)</code>：就是有文本咯</li><li><code>new JCheckBoxMenuItem(String str, boolean b)</code>：就是有文本，又指定初始状态咯</li><li><code>new JCheckBoxMenuItem(String str, Icon i)</code>：就是有文本，又有图标咯</li><li><code>new JCheckBoxMenuItem(String str, Icon i, boolean b)</code>：你猜呗</li></ul><p><strong>单选菜单项构造器：</strong></p><p>单选菜单项是 JRadioButtonMenuItem，剩下的都和上面的一样</p><h2><span id="159-对话框">15.9 对话框</span></h2><blockquote><p>对话框是一个临时的可移动窗口，其依赖于其他窗口。当期依赖的窗口消失或最小化时，对话框消失。窗口还原时对话框恢复。</p><p>对话框分为强制型和非强制型。强制型对话框在关闭前，其他窗口不能接收任何形式的输入。也就是说，该对话过程不能中断。强制型对话框也被称为模式窗口。</p></blockquote><h3><span id="1591-jdialog-自定义对话框">15.9.1 JDialog 自定义对话框</span></h3><p><strong>构造方法：</strong></p><ul><li><p><code>new JDialog(Dialog owner)</code>：无标题无模式对话框。指定对话框为其所有者</p><p>  <code>new JDialog(Frame owner)</code>：指定框架为其所有者</p></li><li><p><code>new JDialog(Dialog owner, boolean model)</code>：无标题对话框，指定所有者并指示是否为有模式</p></li><li><p><code>new JDialog(Dialog owner, String title)</code></p><p>  <code>new JDialog(Frame owner, String title)</code></p><p>  <code>new JDialog(Dialog owner, String title, boolean model)</code></p><p>  <code>new JDialog(Frame owner, String title, boolean model)</code>：这些你都懂的吧</p></li></ul><h3><span id="1592-joptionalpane-标准对话框">15.9.2 JOptionalPane 标准对话框</span></h3><blockquote><p>JDialog 通常用于创建自定义对话框。此外，还有用于显示标准对话框的 JOptionalPane 类</p></blockquote><p>JOptionalPane 定义了多个<strong>静态方法</strong>，分为以下 4 个类型：</p><ul><li><p><strong>showConfirmDialog</strong>：确认对话框。显示问题，要求用户进行确认（yes &#x2F; no &#x2F; cancel）</p><p>  其同名方法有以下 3 种</p><ul><li>int showConfirmDialog(Component parentComponent, Object message)</li><li>int showConfirmDialog(Component parentComponent, Object message, String title, int optionType)</li><li>int showConfirmDialog(Component parentComponent, Object message, String title, int optionType, int messageType)</li></ul></li><li><p><strong>showInputDialog</strong>：输入对话框。提示用户进行输入</p><p>  同名方法有以下 6 种：</p><ul><li>showInputDialog(Object message)</li><li>showInputDialog(Object message, Object initialValue)</li><li>showInputDialog(Component parentComponent, Object message)</li><li>showInputDialog(Component parentComponent, Object message, Object initialValue)</li><li>showInputDialog(Component parentComponent, Object message, String title, int messageType)</li><li>showInputDialog(Component parentComponent, Object message, String title, int messageType, Icon icon, Object[] options, Object initialValue)</li></ul></li><li><p><strong>showMessageDialog</strong>：信息对话框。显示信息</p><p>  同名方法有以下 3 种：</p><ul><li>showMessageDialog(Component parentComponent, Object message)</li><li>showMessageDialog(Component parentComponent, Object message, String title, int messageType)</li><li>showMessageDialog(Component parentComponent, Object message, String title, int messageType, Icon icon)</li></ul></li><li><p><strong>showOptionDialog</strong>：选项对话框，显示选项，要求用户进行选择</p><p>  其只有 1 种同名方法</p><ul><li>showOptionDialog(Component parentComponent, Object message, String title, int optionType, int messageType, Icon icon, Object[] options, Object initialValue)</li></ul></li></ul><p>以上各个方法的参数分别是：</p><ul><li><p>Component parentComponent：对话框的父窗口对象。其父窗口位置决定了对话框位置</p><p>  该值可以是 null，表示用默认的 Frame 作为父窗口。这个场合，对话框位置在屏幕正中</p></li><li><p>Object message：显示在对话框的描述信息。</p><p>  该参数通常是 String 对象，但也能是一个图标、组件或对象数组</p></li><li><p>String title：对话框标题</p></li><li><p>int optionType：对话框上的按钮类型。可以是以下常量：</p><ul><li>JOptionalPane.DEFAULT_OPTION：默认（-1）</li><li>JOptionalPane.YES_NO_OPTION：一组 yes &#x2F; no（0）</li><li>JOptionalPane.YES_NO_CANCEL_OPTION：一组 yes &#x2F; no &#x2F; cancel（1）</li><li>JOptionalPane.OK_CANCEL_OPTION：一组 ok &#x2F; cancel（2）</li></ul><p>  此外，也能通过 Object[] options 参数指定其他形式</p></li><li><p>Object[] options：对话框上的选项。</p><p>  在输入对话框中，通常以组合框架形式显示。在选项对话框中，则是指按钮类型。</p><p>  该参数通常是一个 String[] 数组，但也能是图标数组或组件数组</p></li><li><p>int messageType：对话框传递的信息类型。可以是以下常量：</p><ul><li>JOptionalPane.ERROR_MESSAGE：错误信息（0）</li><li>JOptionalPane.INFORMATION_MESSAGE：普通信息（1）</li><li>JOptionalPane.WARNING_MESSAGE：警告信息（2）</li><li>JOptionalPane.QUESTION_MESSAGE：提问信息（3）</li><li>JOptionalPane.PLAIN_MESSAGE：无格式信息（-1）</li></ul><p>  除 PLAIN_MESSAGE 外，每种类型对应于一个默认的图标</p></li><li><p>Object initialValue：初始选项或输入值</p></li></ul><h3><span id="1593-jfilechooser-文件对话框">15.9.3 JFileChooser 文件对话框</span></h3><blockquote><p>JFileChooser 文件对话框是专门用于对文件或目录进行浏览和选择的对话框</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>new JFileChooser()</code>：构造一个指向客户默认目录的文件对话框</li><li><code>new JFileChooser(File currentDirectory)</code>：指向指定目录的文件对话框</li><li><code>new JFileChooser(String path)</code>：指向指定目录的文件对话框</li></ul><p><strong>常用方法：</strong></p><ul><li><p><code>showOpenDialog(Component parent)</code>：弹出一个 “打开” 文件对话框</p><p>  parent 是对话框的父窗口对象。其父窗口位置决定了对话框位置</p><p>  该值可以是 null，表示用默认的 Frame 作为父窗口。这个场合，对话框位置在屏幕正中</p><p>  <code>showSaveDialog(Component parent)</code>：弹出一个 “保存” 文件对话框</p></li><li><p><code>getSelectedFile()</code>：获得用户选择的文件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13 Java 数据结构</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/13%20java%E9%9B%86%E5%90%88/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/13%20java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="13-java-数据结构">13 Java 数据结构</span></h1><blockquote><p>数据结构分为两种：线性结构、非线性结构</p></blockquote><p><strong>线性结构：</strong></p><ul><li><p>最常用的数据结构。数据元素间存在一对一线性关系。</p></li><li><p>线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构</p><p>  顺序存储结构中元素存储在连续的内存空间中。</p><p>  链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息</p></li><li><p>常见的线性结构有：数组、队列、链表、栈等</p></li></ul><p><strong>非线性结构：</strong></p><ul><li>非线性结构包括：二维数组、多维数组、广义表、树结构、图结构</li></ul><h2><span id="131-集合的框架体系">13.1 集合的框架体系</span></h2><blockquote><p>Java 提供了一系列集合容器，以方便程序员动态保存元素。并提供了一系列方便的操作对象的方法。</p><p>Java 集合主要分为两组：单列集合（Collection）、双列集合（Map）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190227211326757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhcnRvb25f,size_16,color_FFFFFF,t_70"></p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310081718593.webp" alt="集合体系图_13.1"></p><p><em>（集合体系图_13.1）</em></p><ul><li><p><strong>Collection 接口</strong>（单列集合）：可以存放多个元素。每个元素可以是 Object</p><p>  Collection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</p></li><li><p><strong>Map 接口</strong>（双列集合）：用于保存具有映射关系的数据：key - value（双列元素）</p><p>  key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复</p><p>  key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</p></li></ul><h2><span id="132-单列集合接口-collection">13.2 单列集合接口 Collection</span></h2><pre><code class="java">public interface Collection&lt;E&gt; extends Lterable&lt;E&gt;</code></pre><blockquote><p>Collection 实现子类可以存放多个元素。每个元素可以是 Object</p><p>有些 Collection 实现子类能存放重复的元素，有些不能</p><p>有些 Collection 实现子类是有序的（List） ，有些不是（Set）</p><p>Collection 接口没有直接的实现子类，都是通过其子接口实现的</p></blockquote><h3><span id="常用方法">常用方法：</span></h3><ul><li><p><code>add</code>：添加单个元素</p><pre><code class="java">ArrayList list = new ArrayList();list.add(&quot;哈哈啊&quot;);list.add(10);// 相当于List.add(new Integer(10));list.add(true);// 同上</code></pre></li><li><p><code>remove</code>：删除单个元素</p><pre><code class="java">list.remove(0)// 删除编号 0 的元素。上例中会删除 &quot;哈哈啊&quot;list.remove((Integer)10);// 删除上例的 10 要这样写</code></pre></li><li><p><code>contains</code>：检查元素是否存在</p></li><li><p><code>size</code>：获取元素个数</p></li><li><p><code>isEmpty</code>：判断是否为空</p></li><li><p><code>clear</code>：清空</p></li><li><p><code>addAll</code>：添加多个元素</p><pre><code class="java">ArrayList list2 = new ArrayList();list2.add(111);list2.add(&quot;idea&quot;);list.addAll(list2);// 这里可以输入所有实现了 Collection 接口的集合</code></pre></li><li><p><code>containsAll</code>：检查多个元素是否存在</p><pre><code class="java">list.contaionsAll(list2);// 同上，放一个实现了 Collection 接口的集合</code></pre></li><li><p><code>removeAll</code>：删除多个元素</p><pre><code class="java">list.removeAll(list2);// 同上</code></pre></li><li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p></li></ul><h3><span id="1321-迭代器-iterator">13.2.1 迭代器 Iterator</span></h3><blockquote><p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p><p>Collection 继承的 Iterable 接口中，提供了 <code>iterator()</code> 方法，会返回一个新的迭代器。</p><p>Iterator 对象仅用于遍历集合，本身不存放元素</p><p>IDEA 中，迭代器 while 循环的模板快捷键：<code>itit</code></p></blockquote><p><strong>常用方法：</strong></p><ul><li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li><li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li></ul><p><strong>用迭代器遍历元素：</strong></p><pre><code class="java">Collection&lt;Object&gt; c = new LinkedList&lt;&gt;();Iterator&lt;Object&gt; iterator = c.iterator();// [1]while (iterator.hasNext())&#123;// [2]    Object obj = iterator.next();// [3]引用泛型后可以直接指定Object类型为其他，不用再向下转型了。    System.out.println(obj);&#125;</code></pre><ol><li><p>获取迭代器</p></li><li><p>判断有无下一元素</p></li><li><p>将迭代器后移，并返回那个后移位置上的元素</p><p> while 循环结束后，指针指向最后元素的位置。再次 <code>next()</code> 会报错。如果需要再使用，需要重置迭代器。</p><pre><code class="java">iterator = list.iterator();// 重置了迭代器</code></pre></li></ol><p><strong>for each（增强 for 循环）：</strong></p><blockquote><p>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素</p><p>IDEA 中，增强 for 循环的模板快捷键：<code>I</code></p></blockquote><pre><code class="java">for (Object o : list)&#123;    ...&#125;</code></pre><ul><li>for each 可在 Collection 集合中使用。</li><li>for each 的底层在本质上也是 <code>Iterator</code>。可以理解为简化版本的迭代器遍历。</li></ul><h2><span id="133-有序集合接口-list">13.3 有序集合接口 List</span></h2><pre><code class="java">public interface List&lt;E&gt; extends Collection&lt;E&gt;</code></pre><blockquote><p>List 是 Collection 接口的子类接口</p><p>List 是有序（添加顺序和取出顺序一致）的，可重复的</p><p>List 中的每个元素都有其对应的顺序索引（从 0 开始编号）</p><p>List遍历时除了可以采用同Collection的增强for循环和迭代器iterator外，还可以利用自己的get()方法来进行普通for循环遍历。</p></blockquote><h3><span id="常用方法">常用方法：</span></h3><ul><li><p><code>add(int, obj)</code>：在 int 位置插入 obj 元素。返回 true</p><p>  <code>add(obj)</code>：在末尾插入 obj。返回 true</p><pre><code class="java">list.add(111);list.add(0, 110);// 在第 1 个位置插入数字 110</code></pre><p>  <code>addElement(obj)</code>：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截</p></li><li><p><code>addAll(int, collection)</code>：在 int 位置插入 collection 中的所有元素</p></li><li><p><code>get(int)</code>：返回 int 位置的元素</p></li><li><p><code>indexOf(obj)</code>：返回 obj 首次出现时的位置</p></li><li><p><code>lastIndexOf(obj)</code>：返回 obj 最后一次出现时的位置</p></li><li><p><code>remove(int)</code>：移除 int 位置的元素，并返回那个被移除的元素</p></li><li><p><code>set(int, obj)</code>：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标</p><p>  <code>setElement(obj, int)</code>：设置 int 位置的元素为 obj。无返回值</p></li><li><p><code>subList(int1, int2)</code>：返回 [int1, int2) 范围的元素构成的子集合</p></li></ul><h3><span id="1331-可变数组-arraylist">13.3.1 可变数组 ArrayList</span></h3><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre><blockquote><p>ArrayList 是 List 的实现子类。其底层由数组来实现存储。</p><p>ArrayList 可以存放 null</p></blockquote><h4><span id="arraylist-的源码">ArrayList 的源码：</span></h4><ol><li>ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组</li></ol><pre><code class="java">transient Object[] elementData;</code></pre><ol start="2"><li>创建 ArrayList 对象时，如果使用无参构造器，则 elementData[] 初始容量为 0</li></ol><pre><code class="java">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList() &#123;    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</code></pre><ol start="3"><li>如果使用指定大小构造器，则初始容量为指定大小。</li></ol><pre><code class="java">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList(int initialCapacity) &#123;    if (initialCapacity &gt; 0) &#123;        this.elementData = new Object[initialCapacity];    &#125; else if (initialCapacity == 0) &#123;    /* 这个场合，与默认构造器的不同之处在于        扩容时，该 0 容量变为 1，而默认构造器会变为 10 */        this.elementData = EMPTY_ELEMENTDATA;    &#125; else &#123;        throw new IllegalArgumentException(...);    &#125;&#125;</code></pre><ol start="4"><li>扩容的场合：</li></ol><pre><code class="java">如果是 **无参构造器生成的初始 0 长度的 elementData**，则将其容量置为 10。否则容量扩容为 1.5 倍。/* 扩容方法，传入的参数 minCapacity 是容器现有元素数量 + 1 的值    如果是无参构造器生成的默认数组，此时传入固定值 10 */private void grow(int minCapacity) &#123;    int oldCapacity = elementData.length;    /* 计算新的容量（旧容量的 1.5 倍）        此处 &gt;&gt; 为位运算符，等同于 newC = oldC + oldC / 2; */    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    /* 这里如果原容量是特殊值（1 或 0），容量会变为那个 minCapacity 的值 */    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><h3><span id="1332-可变数组-vector">13.3.2 可变数组 Vector</span></h3><pre><code class="java">public class Vector&lt;E&gt;    extends AbstractList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre><blockquote><p>Vector 是 List 的实现子类。其底层由数组来实现存储</p><p>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。</p><p>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList。</p></blockquote><h4><span id="vector-的源码">Vector 的源码：</span></h4><ol><li>底层维护了一个 Object 类型的数组 elementData。用以存放元素</li></ol><pre><code class="java">protected Object[] elementData;</code></pre><ol start="2"><li>使用无参构造器创建对象时，默认大小是 10</li></ol><pre><code class="java">使用有参构造器的场合，默认是那个指定大小（initialCapaticy）也能在构造器中指定那个扩容的增长速度（capacityIncrement）public Vector() &#123;    this(10);&#125;public Vector(int initialCapacity) &#123;    this(initialCapacity, 0);&#125;public Vector(int initialCapacity, int capacityIncrement) &#123;    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(...);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;&#125;</code></pre><ol start="3"><li>扩容的场合，容量变成 2 倍</li></ol><pre><code class="java">使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值private void grow(int minCapacity) &#123;    int oldCapacity = elementData.length;    /* 计算新的容量（按照指定的增速扩容）        那个指定无效或未指定时，容量变为 2 倍 */    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><h3><span id="1333-链表-linkedlist">13.3.3 链表 LinkedList</span></h3><pre><code class="java">public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><blockquote><p>在 Java 中，LinkedList 是 List 的实现子类，底层以链表形式存储元素，&#x3D;&#x3D;[数据结构中，Stack，ArrayDeque、LinkedList都可以作为栈使用,建议不要使用ArrayDeque和Stack作为栈来使用，而是使用LinkedList](D:\TyporaMarkdown\图解算法数据结构.md#### 性能选项)&#x3D;&#x3D;</p><p>链表是一种<strong>非线性结构</strong>：其以节点方式存储，节点间在内存上的位置不连续。</p><p>链表是有序的列表。单向链表每个节点包含 data 域和 next 域。那些 next 域指向下一节点的位置。</p><p>双向链表在单向链表的基础上，每个节点加入 prev 区域以指示其前方节点。这样，就能实现双向查找。双向链表可以不依靠辅助节点而实现自我删除。</p><p><strong>LinkedList 底层实现了 双向链表 和 双端队列 特点。</strong>在 Java 中，LinkedList 也实现了 Deque 接口。</p><p>LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。</p></blockquote><h4><span id="常用方法">#常用方法：</span></h4><ul><li><p><code>void addLast(E e)</code>：尾插一个新的元素</p><p>  LinkedList 的 add 方法即调用该方法</p></li><li><p><code>void addFirst(E e)</code>：头插一个新的元素</p></li><li><p><code>E removeLast()</code>：移除并返回尾部元素。为空时报错</p><p>  <code>E poll()</code>：移除并返回尾部元素。为空时返回 null</p><p>  <code>E removeFirst()</code>：移除并返回头部元素。为空时报错</p></li><li><p><code>E getLast()</code>：<u>仅返回尾部元素</u>。为空时报错</p><p>  <code>E peek()</code>：返回尾部元素。为空时返回 null</p><p>  <code>E element()</code>：返回头部元素。为空时返回 null</p><p>  <code>E getFirst()</code></p></li></ul><h4><span id="linkedlist-的源码">#LinkedList 的源码</span></h4><ol><li><p>LinkedList 只有默认构造器和一个拷贝构造器</p><pre><code class="java">public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123;    this();    addAll(c);&#125;</code></pre></li><li><p>LinkedList 底层维护了一个 &#x3D;&#x3D;双向链表&#x3D;&#x3D;</p><p> 两个属性 first、last 分别指向 首节点 和 尾节点</p><p> 每个节点（Node 对象），里面又维护了 prev、next、item 属性。</p><p> 其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。</p><pre><code class="java">transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        this.item = element;        this.next = next;        this.prev = prev;    &#125;&#125;</code></pre></li><li><p><strong>LinkedList 不需要扩容</strong>。其增删元素时只要改变节点的指向即可。</p><p> 也因此，其添加、删除元素效率比数组更高</p></li></ol><h4><span id="arraylist-和-linkedlist-的比较">#ArrayList 和 LinkedList 的比较：</span></h4><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>改查效率</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>低（数组扩容）</td><td>高</td></tr><tr><td><code>LinkedList</code></td><td>双向链表</td><td>高（链表追加）</td><td>低</td></tr></tbody></table><p>应该根据实际情况来选择使用的集合：</p><ul><li>如果改查操作多，选择 ArrayList。一般来说，在程序中，80% - 90% 都是查询。大部分情况下，选择 ArrayList。</li><li>如果增删操作多，选择 LinkedList</li></ul><h3><span id="1334-稀疏数组">13.3.4 稀疏数组</span></h3><blockquote><p>二维数组的很多值是默认值 0，因此记录了很多没有意义的数据。因此，可以使用稀疏数组。</p></blockquote><p>稀疏数组的处理方法：</p><ol><li>记录数组共有几行几列，有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序规模</li></ol><p><strong>二维数组转换为稀疏数组：</strong></p><p>下面用 ArrayList 模拟一个稀疏数组。</p><p>二维数组：</p><pre><code class="java">int[][] map = &#123;&#123;0, 2, 0, 0, 0, 0 ,0 , 0&#125;,              &#123;0, 0, 3, 0, 0, 0, 0, -1&#125;,              &#123;15, 0, 0, 0, 0, 4, 0, 0&#125;,              &#123;0, 2, 0, 0, 0, 0, 0, 0&#125;,              &#123;0, 0, 0, 0, 0, 0, 0, 0&#125;,              &#123;0, 0, 0, 0, 0, 0, 0, 1&#125;,              &#123;0, 0, 0, 0, 0, 0, 0, 0&#125;&#125;;</code></pre><p>遍历原始的二维数组，得到有效数据的个数 sum，并将二维数组的有效数据存入稀疏数组</p><pre><code class="java">List&lt;int[]&gt; sparseArray = new ArrayList();sparseArray.add(new int[]&#123;map.length, map[0].length, 0&#125;);//for (int y = 0; y &lt; map.length; y++) &#123;    for (int x = 0; x &lt; map[0].length; x++) &#123;        if (map[y][x] != 0) &#123;            sparseArray.add(new int[]&#123;y, x, map[y][x]&#125;);            sparseArray.get(0)[2]++;        &#125;    &#125;&#125;</code></pre><p><strong>稀疏数组转化为二维数组：</strong></p><p>读取稀疏数组的每一行，按照其第一行数据，创建原始的二维数组。</p><p>读取后几行数据，将值赋给二维数组</p><h3><span id="1335-栈-stack">13.3.5 栈 Stack</span></h3><pre><code class="java">public class Stack&lt;E&gt; extends Vector&lt;E&gt;</code></pre><blockquote><p>Stack 是 Vector 的子类。以数组模拟了栈的数据结构。</p><p>栈是一个先入后出的有序列表。其元素之插入删除只能在该线性表的同一端进行。</p><p>其允许增删的一端称为栈顶，另一端即为栈底。</p><p>最先放入的元素位于栈底，最后放入的元素位于栈顶。</p><p>放入元素称为入栈（push），取出元素称为出栈（pop）</p></blockquote><p><strong>栈的应用场景：</strong></p><ul><li>子程序的调用</li><li>处理递归调用</li><li>表达式的转换与求值</li><li>二叉树的遍历</li><li>图形的深度优先搜索法</li></ul><h4><span id="常用方法">#常用方法：</span></h4><ul><li><p><code>E push(E item)</code>：将元素 item 压入栈。返回值是 item 自己</p></li><li><p><code>E pop()</code>：让栈顶元素出栈</p></li><li><p><code>E peek()</code>：仅获取栈顶元素</p></li><li><p><code>int search(Object o)</code>：查找该元素最后出现的位置。</p><p>  栈底为 1，栈顶为 size()，不存在返回 -1</p></li></ul><h4><span id="13351-栈模拟计算器">#13.3.5.1 栈模拟计算器</span></h4><blockquote><p>使用栈结构完成对计算器的实现</p></blockquote><p>要进行计算，需要获得表达式。</p><p>表达式分为三种：</p><ul><li><p><strong>中缀表达式：</strong></p><p>  中缀表达式即生活中常见的运算表达式。比如：(3 + 4) * 5 - 6</p><p>  中缀表达式是人最熟悉的。但是对于计算机来说却不好操作。因此，计算时常将其转化为其他表达式进行操作。</p></li><li><p><strong>前缀表达式：</strong></p><p>  前缀表达式（波兰表达式）是一种没有括号的表达式。其将运算符写在前面，操作数写在后面</p><blockquote><p>(3 + 4) * 5 - 6 的前缀表达式为： + 3 * 4 - 5 6</p><p>(1 + 2) * (3 + 4) 的前缀表达式为：* + 1 2 + 3 4</p></blockquote><p>  前缀表达式的计算机求值：</p><ul><li>从<strong>右</strong>向<strong>左</strong>扫描表达式</li><li>将数字压入堆栈</li><li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li><li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li></ul></li><li><p><strong>后缀表达式：</strong></p><p>  后缀表达式（逆波兰表达式）与前缀表达式相似。但其运算符位于操作数之后</p><blockquote><p>(3 + 4) * 5 - 6 的后缀表达式为： 3 4 + 5 * 6 -</p><p>(1 + 2) * (3 + 4) 的后缀表达式为：1 2 + 3 4 + *</p></blockquote><p>  后缀表达式的计算机求值：</p><ul><li>从<strong>左</strong>向<strong>右</strong>扫描表达式</li><li>将数字压入堆栈</li><li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li><li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li></ul></li></ul><p>对于人类来说，中缀表达式最为熟悉。但对于计算机来说，前缀、后缀表达式更容易识别。</p><p>我们可以将中缀表达式转化为后缀表达式，再进行运算。</p><p><strong>中缀表达式转换为后缀表达式：</strong></p><ol><li><p>初始化两个栈：运算符栈 operator_stack、表达式栈 formula_stack</p></li><li><p>从左到右扫描中缀表达式</p></li><li><p>遇到操作数时，将其压入表达式栈 formula_stack</p></li><li><p>遇到运算符时，比较其与 operator_stack 栈顶运算符的优先级。</p><ul><li>operator_stack 为空，或栈顶为 <code>(</code> 的场合，让运算符入栈</li><li>优先级高于栈顶运算符的场合，让其入栈</li><li>优先级低于或等于栈顶运算符的场合，将那个堆顶运算符弹出并压入 formula_stack。之后，重复该步骤。</li></ul></li><li><p>遇到括号时：</p><ul><li>遇到 <code>(</code> 时，压入 operator_stack</li><li>遇到 <code>)</code> 时，直到遇到 <code>(</code> 前，依次弹出 operator_stack 堆顶的运算符，并压入 formula_stack。之后将这一对括号丢弃。</li></ul></li><li><p>到达表达式最右边时，依次弹出 operator_stack 堆顶的运算符，压入 formula_stack。</p></li><li><p>此时，formula_stack 即为后缀表达式。</p><p> 使用 Java 的 toArray 方法将其转为数组。或将其依次弹出，并逆序输出。</p></li></ol><p><strong>计算器的实现：</strong></p><pre><code class="java">class Calculator &#123;    private static final Map&lt;Character, Integer&gt; priority = new HashMap&lt;&gt;();    static &#123;        priority.put(&#39;+&#39;, 1);        priority.put(&#39;-&#39;, 1);        priority.put(&#39;*&#39;, 2);        priority.put(&#39;/&#39;, 2);        priority.put(&#39;×&#39;, 2);        priority.put(&#39;÷&#39;, 2);        priority.put(&#39;(&#39;, -100);        priority.put(&#39;)&#39;, -10);    &#125;    public static double calculate(String formula) &#123;        String[] ss = formula.split(&quot; &quot;);        Stack&lt;String&gt; operator_stack = new Stack&lt;&gt;();        Stack&lt;String&gt; formula_stack = new Stack&lt;&gt;();        for (String s : ss) &#123;            if (s.matches(&quot;\\d+([.]\\d+)?&quot;)) &#123;                formula_stack.push(s);                continue;            &#125; else if (operator_stack.empty() || s.equals(&quot;(&quot;)) &#123;                operator_stack.push(s);                continue;            &#125;            String temp = operator_stack.peek();            while (priority.get(s.charAt(0)) &lt;= priority.get(temp.charAt(0))) &#123;                formula_stack.push(operator_stack.pop());                if (operator_stack.empty()) break;                temp = operator_stack.peek();            &#125;            if (s.equals(&quot;)&quot;)) &#123;                operator_stack.pop();            &#125; else operator_stack.push(s);        &#125;        while (!operator_stack.empty()) &#123;            formula_stack.push(operator_stack.pop());        &#125;        return anti_Poland(String.join(&quot; &quot;, formula_stack.toArray(new String[]&#123;&#125;)));    &#125;    private static double anti_Poland(String formula) &#123;        String[] ss = formula.split(&quot; &quot;);        Stack&lt;Double&gt; ns = new Stack&lt;&gt;();        for (String s : ss) &#123;            try &#123;                double num = Double.parseDouble(s);                ns.push(num);            &#125; catch (Exception e) &#123;                switch (s) &#123;                    case &quot;+&quot;:                        ns.push(ns.pop() + ns.pop());                        break;                    case &quot;*&quot;:                    case &quot;×&quot;:                        ns.push(ns.pop() * ns.pop());                        break;                    case &quot;/&quot;:                    case &quot;÷&quot;:                        ns.push(1 / ns.pop() * ns.pop());                        break;                    case &quot;-&quot;:                        ns.push(-ns.pop() + ns.pop());                        break;                    default:                        throw new RuntimeException(&quot;Illegal operator&quot;);                &#125;            &#125;        &#125;        return ns.pop();    &#125;&#125;</code></pre><h3><span id="1336-跳表-skiplist">13.3.6 跳表 SkipList</span></h3><p>跳表是一种特殊的链表。普通的链表虽然添加、删除节点的速度很快（O(1)），但是要查找节点却很慢（O(n)）。跳表是一个多层次的链表，其在链表的基础上增加了多级索引，实现了 O(㏒n) 的查找速度。</p><p>[![img](<a href="https://i-melody.github.io/img/Java_InputImage/13_3_6">https://i-melody.github.io/img/Java_InputImage/13_3_6</a> 跳表图.webp)](<a href="https://i-melody.github.io/img/Java_InputImage/13_3_6">https://i-melody.github.io/img/Java_InputImage/13_3_6</a> 跳表图.webp)</p><p><em>（13_3_6 跳表图）</em></p><p>跳表将原本数据层的数据按照一定间隔抽取节点形成索引层，之后再从索引层抽取节点形成第二级索引，以此类推形成多层索引。</p><p>跳表的查询速度得到了优化，但占用空间更大。本质上是一种空间换时间的做法。</p><p><strong>查询</strong></p><p>从最稀疏的索引层（最上层）开始，确定那个待查找数据所在的范围，逐层向下并确定范围，直至数据层。</p><p><strong>增删</strong></p><p>删除元素时，如果那个元素是索引元素，那些索引也会被删除。同时，如果只向数据层中增加元素，可能使索引间隔过大，从而降低查找效率。如果在增加元素时还能保持索引数量的动态平衡，就能防止跳表退化，保持跳表效率。</p><p>跳表给出的解决方案是：在增加元素时产生一个随机值，让这个随机值决定该新节点是否成为索引节点，以及成为几级索引节点。</p><p><strong>实现跳表</strong></p><pre><code class="java">class Skiplist &#123;    private final int level;// 该跳表的合计层数，包括数据层和索引层    private final Random seed;// 随机数种子    private final Node root;// 链表开头    private final Node end;// 链表结尾    private static class Node &#123;// 链表节点类        int val;// 值        int count;// 储存的值的数量        Node[] next;// 指向的下一节点        Node[] prev;// 指向的上一节点                                // 需要指出的是：next 和 prev 的长度指示了节点所在的最高层级                                // 长度为 1 时仅处在数据层，2 时也位于一级索引，以此类推                                // 也就是说，next 和 prev 里，下标 0 的位置位于数据层，1 位于一级索引层        /* 三个参数是：值 val，节点的层级 rand，节点储存值的数量 count */        Node(int val, int rand, int count) &#123;            this.val = val;            this.count = count;            next = new Node[rand];            prev = new Node[rand];        &#125;    &#125;    /* 构造器 */    public Skiplist() &#123;        this(4);    &#125;        /* 有参构造器。输入的值是索引层数量。该值至少应为 1 */    public Skiplist(int level) &#123;        if (level &lt; 1 || level &gt; 30)            throw new RuntimeException(level == 0 ?                    &quot;Why not choose a LinkedList?&quot; :                    &quot;SkipList level out of range: given &quot; + level + &quot; out of range [1, 30]&quot;);        this.level = level + 1;        this.seed = new Random(System.currentTimeMillis());        root = new Node(Integer.MIN_VALUE, this.level, 0);        end = new Node(Integer.MAX_VALUE, this.level, 0);        for (int n = 0; n &lt; this.level; n++) &#123;            root.next[n] = end;            end.prev[n] = root;        &#125;    &#125;        /* 查询一个值是否存在 */    public boolean search(int target) &#123;        Node find = position(target);        return find.val == target &amp;&amp; find.count &gt; 0;    &#125;        /* 搜索一个值的位置。不存在时会返回数据层中前一个节点的位置 */    private Node position(int target) &#123;        Node see = root;        while (true) &#123;            if (see.val == target) return see;            for (int n = see.next.length - 1; ; n--) &#123;                if (n &lt; 0) return see;                else if (see.next[n].val &lt;= target) &#123;                    see = see.next[n];                    break;                &#125;            &#125;        &#125;    &#125;        /* 添加一个值 */    public void add(int num) &#123;        Node pos = position(num);        if (pos.val == num) &#123;// 如果这个节点已经建立，就仅使该节点计数增加            pos.count++;            return;        &#125;        int rand = 1 + level - Integer.toBinaryString(seed.nextInt(1 &lt;&lt; level)).length();                    // level 的值等于总层数。seed 是一个随机数种子，nextInt(int n) 方法返回 [0, n) 的数值                    // Integer.toBinaryString(int n) 方法是将一个数字转化成二进制表示的字符串                    // seed.nextInt(1 &lt;&lt; level) 保证了返回值的二进制长度在 [1, level] 之间，并且概率合意        Node add = new Node(num, rand, 1);        for (int t = 0; t &lt; rand; ) &#123;// 将新节点添加到链表中。            for (; t &lt; pos.next.length &amp;&amp; t &lt; rand; t++) &#123;                Node next = pos.next[t];                add.next[t] = next;                next.prev[t] = add;                pos.next[t] = add;                add.prev[t] = pos;            &#125;            pos = pos.prev[pos.prev.length - 1];        &#125;    &#125;        /* 删除节点（的值） */    public boolean erase(int num) &#123;        Node pos = position(num);        if (pos.val == num &amp;&amp; pos.count &gt; 0) &#123;            pos.count--;            return true;        &#125; else return false;    &#125;&#125;</code></pre><h2><span id="134-队列接口-queue">13.4 队列接口 Queue</span></h2><pre><code class="java">public interface Queue&lt;E&gt; extends Collection&lt;E&gt;</code></pre><blockquote><p>Queue 是 Collection 的子接口</p><p>Queue 的实现子类都是队列式集合。队列是一个有序列表，可以用数组或链表来实现</p><p>队列遵循先入先出的原则。队列中元素是以添加顺序取出的。</p><p>向队列中增加元素称为<strong>入列</strong>（push），取出元素称为<strong>出列</strong>（pop）</p></blockquote><p><a href="https://i-melody.github.io/img/Java_InputImage/%E9%98%9F%E5%88%97%E5%9B%BE_13.4.webp"><img src="https://i-melody.github.io/img/Java_InputImage/%E9%98%9F%E5%88%97%E5%9B%BE_13.4.webp" alt="img"></a></p><h3><span id="常用方法">常用方法：</span></h3><ul><li><p><code>add(E e)</code>：添加元素。队列满的场合抛出异常</p><p>  <code>put(E e)</code>：添加元素。队列满的场合可能阻塞</p><p>  <code>boolean offer(E e)</code>：添加元素。队列满的场合返回 false</p></li><li><p><code>E remove()</code>：移除并返回队列头部元素。队列空的场合抛出异常</p><p>  <code>E poll()</code>：移除并返回队列头部元素</p><p>  <code>E take()</code>：移除并返回队列头部元素。队列空的场合可能阻塞</p></li><li><p><code>E peek()</code>：仅返回队列头部元素。为空时返回 null</p><p>  <code>E element()</code>：仅返回队列头部元素。为空时抛出异常</p></li></ul><h3><span id="1341-优先级队列-priorityqueue">13.4.1 优先级队列 PriorityQueue</span></h3><pre><code class="java">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;    implements java.io.Serializable</code></pre><blockquote><p>PriorityQueue 是一个无界优先级队列。底层以数组储存元素。</p><p>无界队列：即没有范围限制的队列。</p><p>PriorityQueue 不允许 null 元素，也不允许不可比较的元素。</p><p>PriorityQueue 中的元素以自然顺序，或传入的比较器决定的顺序排序。其中的最小元素位于队头，最大元素位于队尾。</p><p>以迭代器遍历时，会按照原本的放入顺序获取元素。PriorityQueue 的源码：</p></blockquote><ol><li><p>底层维护了一个 Object 类型的数组 queue。用以存放元素</p><p> 另维护了一个比较器 comparator，用以比较元素</p><pre><code class="java">transient Object[] queue;private final Comparator&lt;? super E&gt; comparator;</code></pre></li><li><p>默认构造器初始容量为 11，比较器为 null</p></li></ol><pre><code class="java">也能指定初始容量，或传入比较器public PriorityQueue() &#123;    this(DEFAULT_INITIAL_CAPACITY, null);&#125;public PriorityQueue(int initialCapacity) &#123;    this(initialCapacity, null);&#125;public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123;    this(DEFAULT_INITIAL_CAPACITY, comparator);&#125;public PriorityQueue(int initialCapacity,                     Comparator&lt;? super E&gt; comparator) &#123;    if (initialCapacity &lt; 1)        throw new IllegalArgumentException();    this.queue = new Object[initialCapacity];    this.comparator = comparator;&#125;</code></pre><ol start="3"><li><p>放入时依靠比较器 comparator 进行排序。</p><p> 那个比较器为 null 的场合，每次放入元素会按元素自身的自然顺序进行排序。</p><p> 不能排序的场合会抛出异常。</p></li><li><p>扩容时，容量小于 64 的场合容量变为 2 倍 + 2。否则那个容量变为 1.5 倍</p><pre><code class="java">private void grow(int minCapacity) &#123;        int oldCapacity = queue.length;        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?                                         (oldCapacity + 2) :                                         (oldCapacity &gt;&gt; 1));        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)            newCapacity = hugeCapacity(minCapacity);        queue = Arrays.copyOf(queue, newCapacity);    &#125;</code></pre></li></ol><h3><span id="1342-阻塞队列接口-blockingqueue">13.4.2 阻塞队列接口 BlockingQueue</span></h3><pre><code class="java">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;</code></pre><blockquote><p>BlockingQueue 是一个接口，其实现子类都是阻塞队列。</p><p>阻塞队列：</p><ul><li>元素入列时，那个队列已满的场合，会进行等待。直到有元素出列后，元素数量未超过队列总数时，解除阻塞状态，进而继续入列。</li><li>元素出列时，如果队列为空，则会进行等待。直到有元素入列时，解除阻塞状态，进而继续出列。</li><li>阻塞队列能防止容器溢出。只要是阻塞队列，就是线程安全的队列。</li><li>阻塞队列不接受 null 元素</li></ul></blockquote><p><strong>常用方法</strong></p><p>实际上，其常用方法能分为几类</p><table><thead><tr><th>队列为空&#x2F;满时…</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>等待</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除</td><td>remove()</td><td>poll()</td><td>take()</td><td>take(time, unit)</td></tr><tr><td>查找</td><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></tbody></table><p><strong>BlockingQueue 的常用实现子类</strong></p><ul><li>ArrayBlockingQueue：底层以数组存放元素的有界阻塞队列</li><li>LinkedBlockingQueue：底层以链表存放元素的可选边界的阻塞队列</li><li>PriorityBlockingQueue：优先级阻塞队列，与 PriorityQueue 排序方式相同</li></ul><h3><span id="1343-双端队列接口-deque">13.4.3 双端队列接口 Deque</span></h3><pre><code class="java">public interface Deque&lt;E&gt; extends Queue&lt;E&gt;</code></pre><blockquote><p>Deque 是 Queue 的子接口。</p><p>Deque 的实现子类都是双端队列。双端队列的两端都可以添加、删除。可见，Deque 双端队列既有队列的特性，又有栈的特性。</p></blockquote><p><strong>常用方法</strong></p><p>Deque 接口同样提供了一系列方法</p><table><thead><tr><th>操作的是…</th><th>头元素</th><th>尾元素</th><th></th><th></th></tr></thead><tbody><tr><td>队列为空&#x2F;满时…</td><td>抛出异常</td><td>特殊值</td><td>抛出异常</td><td>特殊值</td></tr><tr><td>插入</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>odderLast(e)</td></tr><tr><td>删除</td><td>removeFirst(e)</td><td>pollFirst(e)</td><td>removeLast(e)</td><td>pollLast(e)</td></tr><tr><td>查找</td><td>getFirst(e)</td><td>peekFirst(e)</td><td>getLast(e)</td><td>peekLast(e)</td></tr></tbody></table><p><strong>Deque 的常用实现子类</strong></p><ul><li>LinkedList：双向链表。在 Java 中，LinkedList 也实现了 Deque 接口。</li><li>ArrayDeque：基于数组实现的双端队列。</li><li>LinkedBlockingDeque：以双向链表实现的，双端阻塞队列。该类事实上也继承了 BlockingQueue 接口。</li></ul><h2><span id="135-双列集合接口-map">13.5 双列集合接口 Map</span></h2><pre><code class="java">public interface Map&lt;K,V&gt;</code></pre><p><strong>以下关于 Map 接口的描述，适用于 JDK 8 的环境</strong></p><blockquote><p>Map 与 Collection 并列存在，用于保存具有映射关系的数据：key - value（双列元素）</p><p>Map 的 key 和 value 可以是任何类型的引用数据类型，也能存入 null。</p><p>Map 的 key 不允许重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value。</p><p>一组 k - v 会被封装到一个 Entry 对象中。Entry 是一个内部接口。Map 的实现子类中都包含一个实现这个接口的内部类。</p><pre><code class="java">interface Entry&lt;K,V&gt; &#123;    K getKey();    V getValue();    ...&#125;</code></pre><p>如果添加相同的 key，会覆盖原先的 key -value。等同于修改（key 不会替换，value 会被替换）</p></blockquote><h4><span id="常用方法">#常用方法：</span></h4><ul><li><p><code>put()</code>：添加。已存在的场合，实行替换。（key 不替换，value 替换）</p></li><li><p><code>remove()</code>：根据键删除映射关系</p></li><li><p><code>get()</code>：根据键获取值</p></li><li><p><code>size()</code>：元素个数</p></li><li><p><code>isEmpty()</code>：判断个数是否为 0</p></li><li><p><code>clear()</code>：清空</p></li><li><p><code>containsKey()</code>：查找键是否存在</p></li><li><p><code>Set&lt;K&gt; keySet()</code>：获取所有 键 构成的集合</p><p>  <code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取所有 Entry 构成的集合</p><p>  <code>Collection&lt;V&gt; values()</code>：获取所有 值 构成的集合</p></li></ul><h4><span id="map-接口遍历元素">#Map 接口遍历元素：</span></h4><blockquote><p>Set接收单独获取key，Collection接收单独获取value，Set&lt;Map.Entry&lt;K,V&gt;&gt;获取key和value。</p></blockquote><ul><li><p><strong>方法一</strong>：利用 <code>Set&lt;K&gt; keySet()</code> 方法</p><p>先得到所有 keys，再遍历 keys，根据每个 key 获得 value：</p><pre><code class="java">Set&lt;String&gt; keyset = map.keySet();//返回的是Set的方法，代表获取key值，具体类型可以根据泛型指定for (String o : keyset) &#123;    System.out.println(o + &quot; = &quot; + map.get(o));&#125;</code></pre></li><li><p><strong>方法二</strong>：利用 <code>Set&lt;V&gt; values()</code> 方法</p><p>直接把所有 values 取出，之后遍历 values</p><pre><code class="java">直接把所有 values 取出，之后遍历 valuesCollection values = map.values();//values是返回connection的方法，代表获取values值，在这里不能用泛型，因为确认了返回的是connection类型for (Object value : values) &#123;    System.out.println(value);&#125;</code></pre></li><li><p>&#x3D;&#x3D;<strong>方法三</strong>：利用 <code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 方法（K和V都可以取到）&#x3D;&#x3D;</p></li></ul><p>&#x2F;&#x2F;通过获取 entrySet（是Map接口的内部接口） 来获取 k - v<br>entrySet方法：</p><pre><code class="java">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()&#123;...&#125;</code></pre><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310120814602.png" alt="image-20231007210521367"></p><p>Node实现了Map.Entry接口，可以获取到Node中的k-v值，一个k-v对应一个Node。&#x3D;&#x3D;(注意此接口Entry不是LinkedHashMap的内部类Entry)&#x3D;&#x3D;</p><pre><code class="java">Set&lt;Map.Entry&gt; entrySet = map.entrySet();//Entry是Map的内部接口。而HashMap$Node实现了Entry接口。（static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; ）所以有获取k-v的方法。for (Map.Entry e : entrySet) &#123;    System.out.println(e.getKey() + &quot; - &quot; + e.getValue());&#125;</code></pre><h5><span id="x3dx3d迭代器完成遍历x3dx3d">&#x3D;&#x3D;迭代器完成遍历&#x3D;&#x3D;</span></h5><pre><code class="java">/*1.只对key遍历,也可以同时对value遍历  Set keys = map.keySet();Iterator iterator = keys.iterator();*/while (iterator.hasNext()) &#123;    Object key = iterator.next();    Object value = map.get(key);    System.out.println(key+&quot;=&quot;+value));&#125;/*2.只对values遍历  Collection values = map.values();  Iterator iterator = values.iterator();*/while (iterator.hasNext()) &#123;    Object next =  iterator.next();    System.out.println(next);&#125;/*3.对key和value遍历  Set&lt;Map.Entry&gt; kv = map.entrySet();  Iterator iterator = kv.iterator();*/while (iterator.hasNext()) &#123;            Map.Entry next = iterator.next();              list.add(next.getValue());        &#125;//果是传入的是对象，要调用对象的方法就转化为Map.Entry类型。</code></pre><p>题目：显示工资大于18000的员工信息。</p><blockquote><p>引入泛型后可以省去向下转型的操作</p></blockquote><pre><code class="java">map.put(1, tom);map.put(2 jack);map.put(3, frank);//方法1，迭代器遍历Set&lt;Map.Entry&gt; entrySet = map.entrySet();Iterator iterator = entrySet.iterator();while (iterator.hasNext()) &#123;    Object next = iterator.next();    Map.Entry e = (Map.Entry) next;    Staff stif = (Staff) e.getValue();    if(stif.getSal()&gt;18000) &#123;         while (iterator.hasNext()) &#123;           Map.Entry  next = (Map.Entry)iterator.next();//直接向下转型，返回的是map中作为Object类型的键值对。所以可以直接转型,引入泛型后可以直接合并为一句(Map.Entry&lt;Intager,Staff&gt; staff = )            Staff staff = (Staff) next.getValue();            if(staff.getSal()&gt;18000) &#123;                System.out.println(staff);            &#125;        &#125;        &#125;//方式2，增强for循环遍历        Set keys = map.keySet();        for (Object key:             keys) &#123;          Staff v =  (Staff) map.get(key);            if(v.getSal()&gt;18000)            System.out.println(v);        &#125;stem.out.println(next);    &#125;&#125;</code></pre><h3><span id="x3dx3d1351-散列表-hashmapx3dx3d">&#x3D;&#x3D;13.5.1 散列表 HashMap&#x3D;&#x3D;</span></h3><pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable</code></pre><blockquote><p>HashMap 是 Map 接口使用频率最高的实现类。是根据关键码值（key value）而进行直接访问的数据结构。通过将关键码值映射到表中一个位置来访问记录，以加快查找速度。</p><p>那个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）</p><p>HashMap 是以 k - v 对得到方式来存储数据。&#x3D;&#x3D;一组数据会被封装到一个 Node 对象中。&#x3D;&#x3D;</p><pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;... &#125;</code></pre><p>JDK 7 前，HashMap 底层是 数组 + 链表。JDK 8 后，底层是 数组 + 链表 + 红黑树。HashMap 不保证映射的顺序。</p><p>&#x3D;&#x3D;HashMap 没有实现同步（没有 synchronized），是线程不安全的&#x3D;&#x3D;</p></blockquote><h4><span id="hashmap-的源码">#HashMap 的源码：</span></h4><ol><li><p>HashMap 底层维护(指的是对数据的增删改查等操作)了 Node 类型的数组 table。默认为 null</p><pre><code class="java">transient Node&lt;K,V&gt;[] table;</code></pre><p> 另外，还有集合 values、keySet、enrtySet。<strong>这些集合能帮助程序员进行遍历</strong></p><pre><code class="java">transient Set&lt;K&gt;keySet;transient Collection&lt;V&gt;values;transient Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet;</code></pre></li><li><p>创建对象时，默认构造器将加载因子（loadfactor）初始化为 0.75。</p><p> 也能指定那些初始容量和加载因子。</p><p> 默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。</p><pre><code class="java">static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></pre></li></ol><p>​</p><pre><code class="java">    public HashMap() &#123;        this.loadFactor = DEFAULT_LOAD_FACTOR;// 这个默认构造的场合，其他参数都是默认值    &#125;    </code></pre><pre><code class="java">public HashMap(int initialCapacity) &#123;    this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity, float loadFactor) &#123;    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(...);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(...);    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);&#125;```</code></pre><ol start="3"><li><p>添加时容量不够的场合，需要扩容。</p><p> 默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。</p><p> 扩容的场合，容量变为 2 倍。临界值相应变化。</p><p> 临界值不会超过那个指定的 MAXIMUM_CAPACITY（1 &lt;&lt; 30），否则变成 Integer.MAX_VALUE。</p><p> JDK 8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认是 8），并且 <code>table</code> 的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认 64），会进行树化。</p><p> &#x3D;&#x3D;剪枝：红黑树的元素减少到一定程度，会被重新转化为 链表&#x3D;&#x3D;</p><pre><code class="java">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;// &lt;- 旧的数据数组 table    int oldCap = (oldTab == null) ? 0 : oldTab.length;// &lt;- 旧的 table 的容量    int oldThr = threshold;// &lt;- 旧的临界值    int newCap, newThr = 0;// &lt;- 新的容量、临界值        /* 旧的数组不为空时，        如果容量已达指定的 MAXIMUM_CAPACITY，则不扩容        否则扩容为 2 倍容量，临界值也变为 2 倍 */    if (oldCap &gt; 0) &#123;        newCap = oldCap &lt;&lt; 1;        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125;        else if (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1;    &#125;    /* 旧的数组为空，但临界值已被指定（原因是：指定构造器传入初始容量为 0） */    else if (oldThr &gt; 0)        newCap = oldThr;    /* 旧的数组为空，临界值为 0（原因是：使用默认构造器）        默认构造器初始化容量为 16，默认临界因子为 0.75f */    else &#123;        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;        /* 到这里，newThr（新临界值）为 0 的原因可能是：        1. 旧容量小于那个最小容量（16）        2. 扩容后容量大于那个最大容量        3. 旧的临界值为 0 或 Integer.MIN_VALUE        4. 构造器传入初始容量为 0 */    if (newThr == 0) &#123;        /* 按照 新容量 * 临界因子 的方法计算临界值。临界值不会超过一个指定的最大值 */        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    threshold = newThr;        /* 确定了容量和临界值，下面把旧数组元素移至新数组。        那个移动的场合，会以新容量重新计算所有元素的下标位置 */    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) &#123;        for (int j = 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) &#123;                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else &#123;                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do &#123;                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) &#123;                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        &#125;                        else &#123;                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; while ((e = next) != null);                    if (loTail != null) &#123;                        loTail.next = null;                        newTab[j] = loHead;                    &#125;                    if (hiTail != null) &#123;                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;</code></pre></li><li><p>添加 k - v 时，通过 key 的哈希值得到其在 table 的索引，判断索引位置是否被占用。</p><p> 未占用的场合，直接添加。</p><p> 占用的场合，判断其 key 是否相等。相等的场合，替换 value。否则，按照 树 或 链表 的方式处理。</p><pre><code class="java">public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;</code></pre></li></ol><p>​<br>​&#x2F;* 会先对放入元素的哈希值进行一次计算，得到一个数字：hash *&#x2F;<br>​static final int hash(Object key) {<br>​    int h &#x3D; key.hashCode();<br>​    return (key &#x3D;&#x3D; null) ? 0 : (h ^ (h &gt;&gt;&gt; 16));&#x2F;&#x2F; 位运算符：&gt;&gt;&gt; 无符号右移<br>​}</p><p>​<br>​&#x2F;* put 方法会调用该 putVal 方法。<br>​那些传入值是：hash、key、value、false、true *&#x2F;<br>​final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {<br>​    Node&lt;K,V&gt;[] tab &#x3D; table; &#x2F;&#x2F; &lt;- 是那个存放数据的 table 数组<br>​    int n;&#x2F;&#x2F; &lt;- 是 table.length<br>​    </p><pre><code class="java">    /* 如果原先的 table 为空，则对其重新分配空间 */    if (tab == null || (n = tab.length) == 0) &#123;        tab = resize();        n = tab.length;    &#125;        /* 用方才计算的 hash 数，得到要放入元素的下标值 i        n - 1 是数据数组的最大下标，(n - 1) &amp; hash 必定不大于 n - 1 */    int i = (n - 1) &amp; hash;// 位运算符：&amp; 按位与    Node&lt;K,V&gt; p = tab[i];// 得到 table 中，位于那个插入位置的元素</code></pre><pre><code class="java">                /* 倘若该位置为空，则直接放入 */        if (p == null) &#123;            tab[i] = newNode(hash, key, value, null);        &#125;        /* 该位置不为空，意味着可能添加了重复元素 */        else &#123;            Node&lt;K,V&gt; e; // &lt;- 被发现重复的那个 Node。无重复时结果为 null。这个 Node 的 value 会被替换。            K k = p.key;// &lt;- 当前取出进行比较的 key 值</code></pre><p>​        </p><pre><code class="java">        /* 为了验证其是否重复，这里要进行如下比较：            1. 比较两者的 hash 数。不同的场合是不同元素            2. 使用 == 和 equals 两种方法比较 key。不同的场合是不同元素             如果是相同元素，则该节点的值会被替换 */        if (p.hash == hash &amp;&amp; (k  == key || (key != null &amp;&amp; key.equals(k)))) &#123;            e = p;        &#125;                /* 此处节点结构是 树 的场合，还需遍历比较树的每个节点 */        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);                /* 此处节点结构是 链表 的场合，还需遍历比较每个链表节点 */        else &#123;            for (int binCount = 0; ; ++binCount) &#123;                e = p.next;                /* e == null 意味着遍历结束，全部不同。这样，在此处添加那个新的 Node */                if (e == null) &#123;                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                &#125;                /* 故技重施，如果发现相同，则替换那个新元素 */                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;                    break;                &#125;                p = e;            &#125;        &#125;                /* 经历上述比较后，e != null 意味着有元素要被替换了 */        if (e != null) &#123;            V oldValue = e.value;            /* 传入的参数 onluIfAbsent == false，所以此处一定是 true */            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);// &lt;- HashMap 中，该方法为空实现。            return oldValue;        &#125;    &#125;    ++modCount;        /* 如果到达这里，说明添加了元素（而非替换），要查看大小是否超过临界值 */    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);// &lt;- HashMap 中，该方法为空实现。    return null;&#125;</code></pre><pre><code class="java">    /* 上面提到的一些空实现的方法 */    void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;    void afterNodeInsertion(boolean evict) &#123; &#125;    void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</code></pre><h3><span id="x3dx3d1352-散列表-hashtablex3dx3d">&#x3D;&#x3D;13.5.2 散列表 Hashtable&#x3D;&#x3D;</span></h3><pre><code class="java">public class Hashtable&lt;K,V&gt;    extends Dictionary&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</code></pre><blockquote><p>Hashtable 和 HashMap 基本一致，但Hashtable <strong>是线程安全的</strong> 。但也因为如此，Hashtable 的效率低下。</p></blockquote><h4><span id="hashtable-与-hashmap-的比较">#Hashtable 与 HashMap 的比较：</span></h4><table><thead><tr><th></th><th>版本</th><th>线程安全（同步）</th><th>效率</th><th>是否允许 null值</th></tr></thead><tbody><tr><td>Hashtable</td><td>1.0</td><td>安全</td><td>较低</td><td>不允许</td></tr><tr><td>HashMap</td><td>1.2</td><td>不安全</td><td>高</td><td>允许</td></tr></tbody></table><ul><li><p>Hashtable 底层也是有数组(&#x3D;&#x3D;Entry，但不是继承自Node的，和LinkedHashMap中的Entry无关)&#x3D;&#x3D;，默认构造器的初始容量为 11。临界值是 11 * 0.75 &#x3D; 8。</p></li><li><p>扩容大致如下：</p><pre><code class="java">int newCapacity = (oldCapacity &lt;&lt; 1) + 1;//即，原容量 * 2 + 1</code></pre></li><li><p>Hashtable 不会树化</p></li></ul><h4><span id="x3dx3dentry-node和mapentryx3dx3d">&#x3D;&#x3D;Entry、Node和Map.Entry&#x3D;&#x3D;</span></h4><p> 在HashMap中，Node是内部类，表示HashMap的一个节点，用于存储键值对。Node没有继承关系，它实现了Map.Entry接口。</p><p>在<strong>LinkedHashMap</strong>中，<strong>Entry</strong>是一个内部类，用于存储键值对，同时它继承自<strong>HashMap</strong>中的<strong>Node</strong>类。这是为了在LinkedHashMap中实现<strong>有序性</strong>而继承了Node。</p><p><strong>Entry</strong>表示键值对的条目。然而，Map.Entry是一个接口，它是Java标准库中用于表示键值对的接口，<u>而Entry只是HashMap和LinkedHashMap内部用来实现这个接口的类。</u></p><h4><span id="重写hashcode和equal方法">重写hashCode和equal方法</span></h4><p>我们看HashMap源码的主干可以看出，首先查询哈希表的表头位置，if为空直接创建节点赋值，不为空就是else里的三种情况。无非就是我们要插入的key值是否和表头相等，相等直接替换，<u>不相等看表头是链表还是已经树化</u>，按照不同方式处理。按照这个逻辑，我们就可以研究比较hash的作用是什么，首先我们了解一个逻辑式即：&#x3D;&#x3D;key相等-&gt;hash值相同&#x3D;&#x3D;（&#x3D;&#x3D;需要我们自己重写hashcode实现，注意只有hash值是相同的才有可能在同一数组位置形成链表&#x3D;&#x3D;）而如果他满足hash相等的条件后，我们此时无法确定key值是否相等，因为hash相等只是一个必要条件，接着判断key值相等就行，这样就极大的提高性能,类比生活的话，就是班长肯定要在班干部里面选，所以我们可以先判断他是不是班干部，而不是一上来直接按照班长的所有符合条件去判断班里每个人</p><pre><code class="java">public class HashSetExercise &#123;    public static void main(String[] args) &#123;        Set set = new HashSet();        set.add(new Employee(&quot;jack&quot;,16));        set.add(new Employee(&quot;tom&quot;,23));        set.add(new Employee(&quot;frank&quot;,22));        set.add(new Employee(&quot;frank&quot;,22));        Iterator iterator = set.iterator();        while (iterator.hasNext()) &#123;            Object next =  iterator.next();            System.out.println(next);        &#125;    &#125;&#125;class Employee&#123;    private String name;    private int age;    public Employee(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Employee employee = (Employee) o;        return age == employee.age &amp;&amp; Objects.equals(name, employee.name);    &#125;        @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;    @Override    public String toString() &#123;        return &quot;Employee&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>equals方法主要针对的是在table能否插入一个属性相同的对象，通常和hashcode一起重写。String类已经重写了equals方法，所以当</p><pre><code class="java">hashset.add(new String(&quot;hello&quot;));hashset.add(new String(&quot;hello&quot;));</code></pre><p>的时根据不能有相同元素的原则，所以只会存入一个“hello”，而重写其他类的equals也和String类的equals方法大同小异，同样是为了数据不重复。</p><h3><span id="1353-红黑树-treemap">13.5.3 红黑树 TreeMap</span></h3><pre><code class="java">public class TreeMap&lt;K,V&gt;    extends AbstractMap&lt;K,V&gt;    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</code></pre><blockquote><p>TreeMap 实现了 Map 接口。底层使用 红黑树 存储数据。</p><p>相较数组（访问快，检索、插入慢）和链表（插入快，检索、访问慢），树形数据结构（如二叉排序树）在保证数据检索速度的同时，也能保证数据插入、删除、修改的速度</p></blockquote><p><em><strong>——见 [[14.1.4.1 平衡二叉树]](<a href="https://i-melody.github.io/2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14">https://i-melody.github.io/2022/06/02/Java/入门阶段/14</a> 树&#x2F;#14-1-4-1-平衡二叉树)</strong></em></p><h4><span id="treemap-的源码">#TreeMap 的源码：</span></h4><ol><li>TreeMap 底层维护了一个二叉树，以及一个比较器</li></ol><pre><code class="java">private final Comparator&lt;? super K&gt; comparator;private transient Entry&lt;K,V&gt; root;</code></pre><ol start="2"><li>创建对象时，能采用无参构造，也能指定比较器完成构造</li></ol><p>  那个无参构造的场合，比较器为空。</p><pre><code class="java">public TreeMap() &#123;    comparator = null;&#125;public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;    this.comparator = comparator;&#125;</code></pre><p>  比较器如果为空，则&#x3D;&#x3D;要求<strong>传入的 key</strong> 必须是 Comparable 接口的实现子类&#x3D;&#x3D;，否则无法进行比较。</p><pre><code class="java">final int compare(Object k1, Object k2) &#123;    return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)        : comparator.compare((K)k1, (K)k2);&#125;</code></pre><ol start="3"><li>添加时，通过&#x3D;&#x3D;比较器(Comparator)&#x3D;&#x3D;确定那个添加位置，这一点类似于Map实现类利用equals方法来比较。&#x3D;&#x3D;<strong>如果key相等</strong>，会将原来key对应的值(value)给替换;&#x3D;&#x3D;</li></ol><pre><code class="java">public V put(K key, V value) &#123;    Entry&lt;K,V&gt; t = root;// &lt;- 树的根节点        /* 二叉树为空的场合，创建根节点，将数据放入 */    if (t == null) &#123;        compare(key, key);        root = new Entry&lt;&gt;(key, value, null);        size = 1;        modCount++;        return null;    &#125;        int cmp;// &lt;- 临时值，存放比较结果    Entry&lt;K,V&gt; parent;// &lt;- 临时值，存放父节点    Comparator&lt;? super K&gt; cpr = comparator;// &lt;- 比较器        /* 有比较器的场合，按照这个方法进行比较 */    if (cpr != null) &#123;        do &#123;            parent = t;            cmp = cpr.compare(key, t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;            else                return t.setValue(value);        &#125; while (t != null);    &#125;        /* 比较器为空的场合，按照这个方法进行比较 */    else &#123;        if (key == null) &#123;            throw new NullPointerException();        &#125;        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;        do &#123;            parent = t;            cmp = k.compareTo(t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;            else                return t.setValue(value);        &#125; while (t != null);    &#125;        /* 将数据节点放到正确的路径下 */    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);    if (cmp &lt; 0)        parent.left = e;    else        parent.right = e;        /* 此处会试着将该树转换成完全二叉树 */    fixAfterInsertion(e);    size++;    modCount++;    return null;&#125;</code></pre><ol><li>添加的最后，会试着将该树转换成完全二叉树</li></ol><pre><code class="java">private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123;    x.color = RED;    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));            if (colorOf(y) == RED) &#123;                setColor(parentOf(x), BLACK);                setColor(y, BLACK);                setColor(parentOf(parentOf(x)), RED);                x = parentOf(parentOf(x));            &#125; else &#123;                if (x == rightOf(parentOf(x))) &#123;                    x = parentOf(x);                    rotateLeft(x);                &#125;                setColor(parentOf(x), BLACK);                setColor(parentOf(parentOf(x)), RED);                rotateRight(parentOf(parentOf(x)));            &#125;        &#125; else &#123;            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));            if (colorOf(y) == RED) &#123;                setColor(parentOf(x), BLACK);                setColor(y, BLACK);                setColor(parentOf(parentOf(x)), RED);                x = parentOf(parentOf(x));            &#125; else &#123;                if (x == leftOf(parentOf(x))) &#123;                    x = parentOf(x);                    rotateRight(x);                &#125;                setColor(parentOf(x), BLACK);                setColor(parentOf(parentOf(x)), RED);                rotateLeft(parentOf(parentOf(x)));            &#125;        &#125;    &#125;    root.color = BLACK;&#125;</code></pre><h3><span id="1354-properties">13.5.4 Properties</span></h3><blockquote><p>Properties 继承自 Hashtable 并实现了 Map 接口。也使用键值对的方式保存数据</p><p>Properties 使用特点与 <strong>Hashtable</strong> 相似</p><p>Properties 还可以用于 xxx.properties 文件中，加载数据到 Properties 对象，进行读取和修改</p><p>xxx.properties 文件常作为配置文件</p></blockquote><pre><code class="java">public class Properties extends Hashtable&lt;Object,Object&gt;</code></pre><p><em><strong>——关于这些，详见 [[17 IO流 ]](<a href="https://i-melody.github.io/2022/01/06/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/17">https://i-melody.github.io/2022/01/06/Java/入门阶段/17</a> IO流&#x2F;)</strong></em></p><ul><li><p><code>String getProperty(String key)</code> ：输入一个 String 类型的 key，返回一个 String 的 value</p><pre><code class="java">public String getProperty(String key) &#123;Object oval = super.get(key);String sval = (oval instanceof String) ? (String)oval : null;return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval;&#125;</code></pre></li></ul><h2><span id="136-无序集合接口-set">13.6 无序集合接口 Set</span></h2><blockquote><p>Set 是 Collection 接口的子类接口。</p><p>Set 接口的特点是无序（添加和取出顺序不一致，其取出顺序由某个算法决定），没有索引</p><p>不允许重复元素。故而，最多包含一个 null</p></blockquote><pre><code class="java">public interface Set&lt;E&gt; extends Collection&lt;E&gt;</code></pre><h3><span id="1361-hashset">13.6.1 HashSet</span></h3><pre><code class="java">public class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><blockquote><p>HashSet 实现了 Set 接口。底层实际上使用 HashMap 来存储数据。<del>身在 Collection 心在 Map</del></p><p>HashSet 是无序的。其实际顺序取决于计算得到的 hash 值</p></blockquote><h4><span id="hashset-的源码">#HashSet 的源码</span></h4><ol><li><p>HashSet 底层是 HashMap。</p><pre><code class="java">private transient HashMap&lt;E,Object&gt; map;</code></pre></li><li><p>实例化也和 HashMap 相同</p><pre><code class="java">public HashSet() &#123;    map = new HashMap&lt;&gt;();&#125;public HashSet(int initialCapacity) &#123;    map = new HashMap&lt;&gt;(initialCapacity);&#125;public HashSet(int initialCapacity, float loadFactor) &#123;    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;</code></pre></li><li><p>添加一个元素时调用 HashMap 的方法</p><pre><code class="java">public boolean add(E e) &#123;    return map.put(e, PRESENT)==null;&#125;</code></pre></li></ol><h3><span id="1362-linkedhashset">13.6.2 LinkedHashSet</span></h3><blockquote><p>LinkedHashSet 是 HashSet 的子类</p><p>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + 双向链表。<del>有其父必有其子</del></p><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p></blockquote><pre><code class="java">public class LinkedHashSet&lt;E&gt;    extends HashSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><h4><span id="linkedhashset-的源码">#LinkedHashSet 的源码：</span></h4><ol><li><p>在类 HashSet 中，存在一个默认访问范围的构造器。该构造器不同于其他构造器，会让实例维护一个 LinkedHashMap</p><pre><code class="java">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;</code></pre><p> LinkedHashSet 的构造器即调用了该父类构造器</p><pre><code class="java">public LinkedHashSet(int initialCapacity, float loadFactor) &#123;    super(initialCapacity, loadFactor, true);&#125;public LinkedHashSet(int initialCapacity) &#123;    super(initialCapacity, .75f, true);&#125;public LinkedHashSet() &#123;    super(16, .75f, true);&#125;</code></pre></li></ol><h3><span id="1363-treeset">13.6.3 TreeSet</span></h3><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><blockquote><p>TreeSet 实现了 Set 接口，其底层是一个 TreeMap。<del>好家伙，原来 Set 全家都是卧底</del></p><p>调用无参构造器创建 TreeSet 时，&#x3D;&#x3D;默认是无序排列&#x3D;&#x3D;。也能在构造时传入一个比较器(Comparator)来完成排序的策略。有比较器的场合，&#x3D;&#x3D;比较器返回 0 时，加入不了，没有替换&#x3D;&#x3D;</p><p>&#x3D;&#x3D;不传入比较器的场合，使用的是传入对象自带的比较器&#x3D;&#x3D;。如果不传入，则要求&#x3D;&#x3D;传入的 key 对象<strong>必须</strong>是 Comparable 接口的实现子类&#x3D;&#x3D;，否则会抛出ClassCastException异常</p></blockquote><p>—&gt;因为只有实现Comparable接口才能在compare方法内部使用compareTo方法，例如下方代码比较字符串长度可以改为<code>return ((Integer)((String) o1).length()).compareTo(((Integer)((String) o2).length()));</code>，因为int类型没有实现Compare接口，而Integer实现了才能使用,转为包装类型就可以了。</p><pre><code class="java">TreeSet treeSet = new TreeSet(new Comparator() &#123;    @Override    public int compare(Object o1, Object o2) &#123;        /*按字符串比较，         如果大小相等就加不进去*/        // return ((String) o1).compareTo((String)o2);        /*按字符串长度比较，        如果按照长度，当增加同样长度的字符串是不会添加进去的*/        return ((String) o1).length() - ((String) o2).length();    &#125;&#125;);treeSet.add(&quot;hello&quot;);treeSet.add(&quot;java&quot;);treeSet.add(&quot;php&quot;);treeSet.add(&quot;java&quot;);//字符串大小相等，加不进去。                    //如果采用长度比较策略，只会加入同一长度字符串一次，后续加不进去System.out.println(treeSet);</code></pre><h2><span id="137-集合的选择">13.7 集合的选择</span></h2><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行分析选择。</p><p>判断存储的类型（一组对象 [单列]，或一组键值对 [双列]）</p><ul><li>一组对象：Collection 接口<ul><li>允许重复：List<ul><li>增删多：<code>LinkedList</code> （双向链表）</li><li>改查多：ArrayList （<code>Object[]</code> 数组）</li></ul></li><li>不允许重复：Set<ul><li>无序：HashSet （数组 + 链表 + 红黑树，底层是 HashMap）</li><li>排序：<code>TreeSet</code></li><li>顺序一致：LinkedHashSet （数组 + 双向链表，底层是 <code>LinkedHashMap</code>）</li></ul></li></ul></li><li>一组键值对：Map<ul><li>键无序：HashMap （底层是：哈希表 jdk7是数组+链表，接着是数组 + 链表 + <strong>红黑树</strong> [ JDK 8 以后 ] ）</li><li>键排序：<code>TreeMap</code></li><li>键顺序一致：<code>LinkedHashMap</code> （底层是 HashMap）</li><li>读取文件：Properties</li></ul></li></ul><h2><span id="138-工具类-collections">13.8 工具类 Collections</span></h2><blockquote><p>Collections 工具类是一个操作 &#x3D;&#x3D;Set、List、Map&#x3D;&#x3D; 等集合的工具类</p><p>其中提供了一系列静态方法，对集合元素进行 排序、查询和修改等操作</p></blockquote><h4><span id="常用方法">常用方法：</span></h4><p><strong>排序：</strong></p><ul><li><code>reverse(List)</code>：反转 List 中元素的排序</li><li><code>shuffle(List)</code>：对 <code>List </code>中元素进行随机排序</li><li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素升序排列</li><li>&#x3D;&#x3D;<code>reverse(List, Comparator)</code>：根据指定 Comparator 对 List 排序&#x3D;&#x3D;</li><li><code>swap(List, int, int)</code>：将两处元素位置互换</li></ul><p><strong>查找、替换：</strong></p><ul><li><p><code>Object max(Collection)</code>：根据元素的自然排序，返回集合中最大的元素</p></li><li><p><code>Object max(Collection, Comparator)</code>：根据比较器，返回最大元素</p></li><li><p><code>Object min(Collection)</code>：根据元素的自然排序，返回最小元素</p></li><li><p><code>Object min(Collection, Comparator)</code>：根据比较器，返回最小元素</p></li><li><p><code>int frequency(Collection, Object)</code>：返回集合中指定元素的出现次数</p></li><li><p><code>void copy(List dest, List src)</code>：将 src 的内容复制到 dest 中</p><p>  这个场合，&#x3D;&#x3D;要保证 dest 的大小不小于 src。所以，可能需要先给 dest 赋值&#x3D;&#x3D;</p></li><li><p><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：用 newVal 替换所有 oldVal 值</p></li></ul><h2><span id="139-junit">13.9 JUnit</span></h2><blockquote><p>&#x3D;&#x3D;不能在提供了有参构造器的类的方法上使用，如果方法有参数也不行。&#x3D;&#x3D;</p><p>每个方法写一个单独的测试方法，这样可以避免反复撤销的操作。</p><pre><code class="java">@Test public void testlist() &#123; &#125;@Test public void testdelete()&#123; &#125; @Test public void testupdate()&#123;&#125;</code></pre><blockquote><p>一个类有多个功能代码需要测试，为了测试，就要写入 <code>main</code> 方法中</p><p>如果有多个功能代码测试，需要反复撤销，过程繁琐</p></blockquote><blockquote><p>JUnit 是一个 Java 语言单元测试框架</p><p>多数 Java 开发环境都已集成了 JUnit 作为单元测试工具</p><p><a href="https://www.bilibili.com/video/BV1fh411y7R8?p=566&t=259.3">使用方法</a></p><p>……总的来讲，方法就是加入 <code>@Test</code>，然后 <code>alt + enter</code> 引入 JUnit 5，最后运行</p></blockquote></blockquote><h2><span id="本章作业">本章作业</span></h2><h3><span id="x3dx3d1试分析hashset和treeset分别是如何实现去重的x3dx3d">&#x3D;&#x3D;1.试分析HashSet和TreeSet分别是如何实现去重的&#x3D;&#x3D;</span></h3><ol><li>HashSet的去重机制：hashCode()+equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引的位置没有数据，就直接存放，如果有元素就进行equals(存入对象的equals方法，需要程序员重写)的比较【遍历比较】，如果比较后，不相同就加入，否则不加入。</li><li>TreeSet的去重机制：如果传入了一个Comparator匿名对象后，就使用实现的compare去重，如果方法返回0，就认为是相同的元素&#x2F;数据，就不添加，&#x3D;&#x3D;如果你没有传入一个Comparator匿名对象，则认为添加的对象实现的Comparable接口的compareTo去重&#x3D;&#x3D;。</li></ol><h3><span id="在treeset传入一个对象自定义的对象时如果它没有实现comparable接口那么当treesetadd对象的时候会抛出classcastexception的异常">在TreeSet传入一个对象(自定义的对象)时，如果它没有实现Comparable接口，那么当treeset.add(对象)的时候会抛出ClassCastException的异常。</span></h3><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310090846619.png" alt="image-20231009084651414"></p><p>add时存放的p1hash值和经过修改属性后的hash值已经不是同一个了，数值还是存放在原p1中，&#x3D;&#x3D;绕不出去的问题在于p1.name&#x3D;CC之后其实此时占用的是AA的哈希位置，所以添加进去的CC经过哈希之后不可能在原来AA的位置&#x3D;&#x3D;</p><p>new Person(new Person(1001,”AA”))可以加进去是因为原来的位置被占了，但是由于内容被改了，所以可以加在同一位置的后面。</p><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202310090912580.png" alt="image-20231009091217504"></p><h1><span id="面试题">面试题</span></h1><h3><span id="hashset的元素不能重复">HashSet的元素不能重复</span></h3><ol><li><pre><code class="java"> Set set = new HashSet(); set.add(&quot;tom&quot;); set.add(&quot;tom&quot;);//添加不了，重复了</code></pre></li><li><pre><code class="java"> set.add(new Dog(&quot;tom&quot;)); set.add(new Dog(&quot;tom&quot;));//可以添加，并不是一个元素</code></pre></li><li><pre><code class="java">  set.add(new String(&quot;tom&quot;)); set.add(new String(&quot;tom&quot;))//不能添加</code></pre><blockquote><p>第3点与<a href="####HashMap%E6%BA%90%E7%A0%81%EF%BC%9A">HashMap的底层源码</a>有关，在底层HashSet在一个数组里添加元素时会调用equals方法，如果目标索引处已经有了一个元素，那么将会调用这个equals方法（需要自己重写实现，不能单纯理解比较的是内容，每一个类都有相应的equals方法）决定能不能放进去，而String类重写了自己的equals方法，它比较的是内容，如果没有重写equals方法比较的是地址，也就是相当于“&#x3D;&#x3D;”；相同就会放弃相加，如果不相同就在当前元素位置的链表的下一个结点。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24 项目：满汉楼</title>
      <link href="/2024/02/04/Java%E5%9F%BA%E7%A1%80/24%20%E6%BB%A1%E6%B1%89%E6%A5%BC%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/02/04/Java%E5%9F%BA%E7%A1%80/24%20%E6%BB%A1%E6%B1%89%E6%A5%BC%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="24-项目满汉楼">24 项目：满汉楼</span></h1><ul><li>登录界面<ul><li>登录（账号、密码）</li><li>退出</li></ul></li><li>菜单界面<ul><li>餐桌状态（显示编号、状态）</li><li>预定餐桌（编号[核对、二次确认]、预定人名字、电话）</li><li>菜单（名称、价格、类别、编号）<ul><li>全部、分类</li></ul></li><li>点餐（桌号[核对]、菜品[核对]、数量）</li><li>账单（按照桌号分组。菜品、数量、金额、桌号、日期、状态）</li><li>结账（桌号、方式、二次确认）</li><li>退出系统</li></ul></li><li>数据库<ul><li>登录用户：login（id、name、password[md5]）</li><li>餐桌状态：table（id、order、seat、customer）</li><li>顾客：customer（id、name、card_id、call）</li><li>菜单：dishes（id、name、price、species、available）</li><li>账单：bill（id、date、customer、num、table、clear、dishes）</li></ul></li></ul><h2><span id="代码万民堂">代码：万民堂</span></h2><p><del>说是满汉楼，其实是万民堂</del></p><p><strong>没有优化过，所以健壮性不强。懒得做优化了，反正之前的项目做过了</strong></p><h3><span id="1-数据库">1. 数据库</span></h3><blockquote><pre><code class="sql">mysql://localhost:3306/wan_minAWK</code></pre></blockquote><h4><span id="表">表</span></h4><blockquote><p>以下大部分是润色后的 <code>show create table xxx</code> 的返回语句</p></blockquote><h5><span id="table餐桌">table（餐桌）</span></h5><blockquote><p>餐桌号 id（主键）、餐桌状态 order、座数 seat、订餐人 customer</p></blockquote><pre><code class="sql">CREATE TABLE `table` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT ,      `order` enum(&#39;已预定&#39;,&#39;用餐&#39;,&#39;空&#39;,&#39;不可用&#39;) COLLATE utf8_bin NOT NULL DEFAULT &#39;空&#39;,      `seat` smallint(5) unsigned NOT NULL DEFAULT &#39;2&#39;,      `customer` smallint(5) unsigned DEFAULT NULL,      PRIMARY KEY (`id`),      KEY `customer` (`customer`),      CONSTRAINT `table_ibfk_1` FOREIGN KEY (`customer`) REFERENCES `customer` (`id`)    )MYSQL</code></pre><h5><span id="dishes菜单">dishes（菜单）</span></h5><blockquote><p>餐品号 id（主键）、餐品名 name（唯一）、价格 price、分类 species、是否可用 available</p></blockquote><pre><code class="sql">CREATE TABLE `dishes` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,      `name` char(8) COLLATE utf8_bin NOT NULL,      `price` smallint(5) unsigned NOT NULL DEFAULT &#39;0&#39;,      `species` enum(&#39;主食&#39;,&#39;主菜&#39;,&#39;汤品&#39;,&#39;凉菜&#39;,&#39;甜点&#39;,&#39;饮料&#39;,&#39;&#39;) COLLATE utf8_bin NOT NULL DEFAULT &#39;&#39;,      `available` enum(&#39;y&#39;,&#39;n&#39;) COLLATE utf8_bin NOT NULL DEFAULT &#39;y&#39;,      PRIMARY KEY (`id`),      UNIQUE KEY `name` (`name`))MYSQL</code></pre><h5><span id="customer客人信息">customer（客人信息）</span></h5><blockquote><p>顾客ID id（主键）、顾客名字 name、顾客证件号 card_id（可为空）、顾客电话 call</p></blockquote><pre><code class="sql">CREATE TABLE `customer` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,      `name` varchar(12) COLLATE utf8_bin NOT NULL,      `card_id` char(18) COLLATE utf8_bin DEFAULT NULL,      `call` char(11) COLLATE utf8_bin NOT NULL,      PRIMARY KEY (`id`))MYSQL</code></pre><h5><span id="login登录验证">login（登录验证）</span></h5><blockquote><p>系统登录ID id（主键）、系统登录名 name（唯一）、密码 password（md5 加密）</p></blockquote><pre><code class="sql">CREATE TABLE `login` (      `id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,      `name` varchar(10) COLLATE utf8_bin NOT NULL,      `password` char(32) COLLATE utf8_bin NOT NULL,      PRIMARY KEY (`id`),      UNIQUE KEY `name` (`name`))MYSQL</code></pre><h5><span id="bill订单">bill（订单）</span></h5><blockquote><p>订单ID id（主键）、日期 date、顾客 customer（外键）、菜品ID id（外键）、菜品数量 num、桌号 table（外键）、结算状态 clear（枚举，y现金、alipay支付宝、wcpay微信、n未付）</p></blockquote><pre><code class="sql">CREATE TABLE `bill` (      `id` int(10) unsigned NOT NULL AUTO_INCREMENT,      `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,      `customer` smallint(5) unsigned NOT NULL,      `num` smallint(5) unsigned NOT NULL DEFAULT &#39;1&#39;,      `table` smallint(5) unsigned NOT NULL,      `clear` enum(&#39;y&#39;,&#39;n&#39;,&#39;alipay&#39;,&#39;wc_pay&#39;) COLLATE utf8_bin NOT NULL DEFAULT &#39;n&#39;,      `dishes` smallint(5) unsigned NOT NULL,      PRIMARY KEY (`id`),      KEY `customer` (`customer`),      KEY `table` (`table`),      KEY `dishes` (`dishes`),      CONSTRAINT `bill_ibfk_1` FOREIGN KEY (`customer`) REFERENCES `customer` (`id`),      CONSTRAINT `bill_ibfk_2` FOREIGN KEY (`table`) REFERENCES `table` (`id`),      CONSTRAINT `bill_ibfk_3` FOREIGN KEY (`dishes`) REFERENCES `dishes` (`id`))MYSQL</code></pre><h5><span id="detail_billview查询订单信息">detail_bill（view，查询订单信息）</span></h5><pre><code class="sql">CREATE VIEW `detail_bill` AS     select `customer`.`name` AS `name`,       `customer`.`call` AS `call`,       `bill`.`table` AS `table`,       `dishes`.`name` AS `dishes`,       `bill`.`num` AS `num`,       `bill`.`date` AS `date`,       `bill`.`clear` AS `clear`     from `bill` , `customer`, `dishes`     where (`bill`.`customer` = `customer`.`id`)         and (`bill`.`dishes` = `dishes`.`id`)MYSQL</code></pre><h3><span id="java-代码">Java 代码</span></h3><h4><span id="通用部分">通用部分</span></h4><blockquote><p>以下各包，客户端和服务端各自持有一份，存放在相同目录下。</p></blockquote><h5><span id="commelodywmtcommon">com.melody.wmt.common</span></h5><h6><span id="messagejava">Message.java</span></h6><blockquote><p><em>com.melody.wmt.common.Message.java</em></p><p>信息包。客户端、服务端的通讯依靠发送该包进行</p></blockquote><pre><code class="java">package com.melody.wmt.common;import java.io.Serializable;import java.time.Instant;/** * @author Melody * @version 1.0 */public class Message implements Serializable &#123;    private String sender;//发送者IP    private String receiver;//接收者IP    private String word;//信息标识    private Object object;//信息数据    private Instant timeStamp;//信息时间戳    public Message(String sender, String receiver, String word, Object object) &#123;        this.sender = sender;        this.receiver = receiver;        this.word = word;        this.object = object;        timeStamp = Instant.now();    &#125;    public String getSender() &#123;        return sender;    &#125;    public void setSender(String sender) &#123;        this.sender = sender;    &#125;    public String getReceiver() &#123;        return receiver;    &#125;    public void setReceiver(String receiver) &#123;        this.receiver = receiver;    &#125;    public String getWord() &#123;        return word;    &#125;    public void setWord(String word) &#123;        this.word = word;    &#125;    public Object getObject() &#123;        return object;    &#125;    public void setObject(Object object) &#123;        this.object = object;    &#125;    public Instant getTimeStamp() &#123;        return timeStamp;    &#125;    public void setTimeStamp() &#123;        this.timeStamp = Instant.now();    &#125;&#125;JAVA</code></pre><h6><span id="messagetypejava">MessageType.java</span></h6><blockquote><p><em>com.melody.wmt.common.MessageType.java</em></p><p>信息标识包。通过该包来分析信息包的种类。该包没有方法。</p></blockquote><pre><code class="java">package com.melody.wmt.common;/** * @author Melody * @version 1.0 */public interface MessageType &#123;    /*以下是服务端发送*/    String REJECT = &quot;0&quot;;//拒绝请求    String ACCEPT = &quot;A&quot;;//通过请求    String LOGIN_USER_NOT_EXIST = &quot;LUNE&quot;;//登录失败：用户不存在    String LOGIN_WRONG_PW = &quot;LWP&quot;;//登陆失败：密码错误    String WRONG_REQUEST = &quot;WR&quot;;//请求无效    String TABLE_NOT_EXIST = &quot;TNE&quot;;//餐桌不存在    String TABLE_OCCUPIED = &quot;TOP&quot;;//餐桌被占用（未点餐）    String TABLE_DINNING = &quot;TOD&quot;;//餐桌被占用（已点餐）    String TABLE_NOT_AVAILABLE = &quot;TNA&quot;;//餐桌不可用    String TABLE_AVAILABLE = &quot;TIA&quot;;//餐桌为空    String NOT_FOUND = &quot;NF&quot;;//没有找到目标    /*以下是客户端发送*/    String LOGIN = &quot;LGI&quot;;//请求登录    String SHOW_TABLES = &quot;RST&quot;;//请求返回餐桌列表    String CHECK_TABLE = &quot;RCT&quot;;//请求查询餐桌状态    String ORDER_TABLE = &quot;ROT&quot;;//请求预定餐桌    String SHOW_DISHES = &quot;RSD&quot;;//请求返回菜单列表    String CHECK_DISHES = &quot;RCD&quot;;//请求查询菜单状态    String ORDER_DISHES = &quot;ROD&quot;;//请求订餐    String SHOW_ALL_BILLS = &quot;RAB&quot;;//请求返回账单列表    String CHECK_BILLS = &quot;RCB&quot;;//请求查询账单状态    String FINISH_BILLS = &quot;RFB&quot;;//请求完成账单    String LOGOUT = &quot;LGO&quot;;//请求登出&#125;JAVA</code></pre><h5><span id="commelodywmtsql">com.melody.wmt.sql</span></h5><h6><span id="logindatajava">LoginData.java</span></h6><blockquote><p><em>com.melody.wmt.sql.LoginData.java</em></p><p>登录信息包。该包对应表 <code>login</code> 的记录。</p></blockquote><pre><code class="java">package com.melody.wmt.sql;import java.io.Serializable;/** * @author Melody * @version 1.0 */public class LoginData implements Serializable &#123;    private int id;    private String name;    private String password;    public LoginData()&#123;&#125;    public LoginData(int id, String name, String password) &#123;        this.id = id;        this.name = name;        this.password = password;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;&#125;JAVA</code></pre><h6><span id="tabledatajava">TableData.java</span></h6><blockquote><p><em>com.melody.wmt.sql.TableData.java</em></p><p>餐桌信息包。该包对应表 <code>table</code> 的记录。</p></blockquote><pre><code class="java">package com.melody.wmt.sql;import java.io.Serializable;/** * @author Melody * @version 1.0 */public class TableData implements Serializable &#123;    private int id;    private String order;    private int customer;    private int seat;    public TableData() &#123;    &#125;    public TableData(int id, String order, int customer, int seat) &#123;        this.id = id;        this.order = order;        this.customer = customer;        this.seat = seat;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getOrder() &#123;        return order;    &#125;    public void setOrder(String order) &#123;        this.order = order;    &#125;    public int getCustomer() &#123;        return customer;    &#125;    public void setCustomer(int customer) &#123;        this.customer = customer;    &#125;    public int getSeat() &#123;        return seat;    &#125;    public void setSeat(int seat) &#123;        this.seat = seat;    &#125;    @Override    public String toString() &#123;        return id + &quot;\t&quot; + seat + &quot;\t&quot; + order + &quot;\t&quot; + (customer == 0 ? &quot;-&quot; : customer);    &#125;&#125;JAVA</code></pre><h4><span id="服务端部分">服务端部分</span></h4><h5><span id="commelodywmtlibrary">com.melody.wmt.library</span></h5><blockquote><p>在目录 <em>com.melody.wmt.library</em> 下，配置以下 jar 包：</p><ul><li><code>druid-1.2.8.jar</code>：德鲁伊连接池</li><li><code>mysql-connector-java-8.0.27.jar</code>：MySQL 数据库</li><li><code>commons-dbutils-1.7.jar</code>：Apache-DBUtils</li></ul></blockquote><h5><span id="commelodywmtserver">com.melody.wmt.server</span></h5><h6><span id="serverjava">Server.java</span></h6><blockquote><p>服务端入口</p></blockquote><pre><code class="java">package com.melody.wmt.server;import java.io.IOException;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;import java.net.UnknownHostException;/** * @author Melody * @version 1.0 */public class Server &#123;    public static final String serverIP;        /* 多此一举地初始化服务端 IP 地址。其实直接写正确地址也行的 */    static &#123;        String tempIP = null;        try &#123;            tempIP = InetAddress.getLocalHost().getHostAddress();        &#125; catch (UnknownHostException e) &#123;            System.out.println(e);            tempIP = &quot;192.168.3.16&quot;;        &#125; finally &#123;            serverIP = tempIP;        &#125;    &#125;        /* 主方法    持续监听端口，每当有接入时就丢给新的 RunningServer 线程 */    public static void main(String[] args) throws IOException &#123;        ServerSocket serverSocket = new ServerSocket(9000);        while (true) &#123;            Socket accept = serverSocket.accept();            new Thread(new RunningServer(accept)).start();        &#125;    &#125;&#125;JAVA</code></pre><h6><span id="runningserverjava">RunningServer.java</span></h6><blockquote><p>服务端进程主体。由 <em>Server.java</em> 创建。</p><p>该进程能实现：用户登录验证、识别客户端请求</p></blockquote><pre><code class="java">package com.melody.wmt.server;import com.melody.wmt.common.Message;import com.melody.wmt.common.MessageType;import com.melody.wmt.sql.LoginData;import java.io.*;import java.net.Socket;import java.time.LocalDateTime;/** * @author Melody * @version 1.0 */public class RunningServer implements Runnable &#123;    private Socket socket;    private ObjectInputStream ois;//通信的输入流    private ObjectOutputStream oos;//通信的输出流    private String targetIP;//通信对象的 IP    private LoginData loginData;//通信对象声明的登录对象的信息。                                //这个信息来自数据库，不一定和通信对象声明的信息匹配    private boolean running = true;//线程运行中。false 的场合线程停止        /* 完成一些初始化 */    public RunningServer(Socket socket) &#123;        this.socket = socket;        try &#123;            ois = new ObjectInputStream(socket.getInputStream());            oos = new ObjectOutputStream(socket.getOutputStream());        &#125; catch (IOException e) &#123;            System.out.println(e);            closeAll();        &#125;        targetIP = socket.getLocalAddress().getHostAddress();    &#125;    @Override    public void run() &#123;        try &#123;            /* 接收通信对象的登录请求 */            Message message = ServerUtils.receiveMessage(ois);            /* 获得通信对象声明的登录对象信息。            这里返回 null 的场合，登录失败 */            loginData = ServerUtils.checkLogin(message);            System.out.println(targetIP + &quot; 请求登录 &lt;&quot; + message.getObject()+&quot;&gt;&quot;);            /* 登录失败的场合，发送拒绝信息，并关闭所有流 */            if (loginData == null) &#123;                ServerUtils.sendRejection(targetIP, oos);                closeAll();                return;            &#125; else &#123;            /* 登录成功，发送登录对象信息 */                ServerUtils.sendMessage(new Message(Server.serverIP, targetIP, MessageType.ACCEPT, loginData), oos);            &#125;            System.out.println(targetIP + &quot; 登录成功 &quot; + loginData.getName() + LocalDateTime.now());                        /* 直到这里，登录成功，正式开始监听客户端请求 */            while (running) &#123;                listeningRequest();            &#125;        /* 如果发生任何连接异常，我们中断连接，并关闭所有流 */        &#125; catch (Exception e) &#123;            System.out.println(targetIP + &quot; 连接中断 &quot; + loginData.getName() + LocalDateTime.now());            closeAll();        &#125;    &#125;        /* 这个方法是关闭所有流的方法。在关闭连接时会被调用 */    private void closeAll() &#123;        try &#123;            if (ois != null) &#123;                ois.close();            &#125;            if (oos != null) &#123;                oos.close();            &#125;            if (socket != null) &#123;                socket.close();            &#125;        &#125; catch (IOException e) &#123;            System.out.println(e);        &#125;    &#125;        /* 这个方法是监听客户端请求的方法。根据不同请求，做出不同反应 */    private void listeningRequest() &#123;        /* 监听请求 */        Message message = ServerUtils.receiveMessage(ois);        /* 检查收到的数据包的信息标识 */        String request = message.getWord();        /* 创建将要发送的数据包。此时，该包还是空的 */        Message toSend = new Message(Server.serverIP, targetIP, null, null);        /* 检查一下接收的数据包的用户信息。有任何问题的话我们就发送请求错误包 */        /* ……在这里解释一下：客户发送的数据包里，主要包含以下信息：        1. getWord() 返回数据包标识。客户端的任何请求会对应不同的标识        2. getObject() 一定包含一条 String 语句。该语句被转义字符 \t 分为几个部分。            第一部分一定是用户名、第二部分一定是用户密码。            根据请求需要，也会有更多其他部分 */        try &#123;            if (!ServerUtils.checkUser((String) message.getObject(), loginData)) &#123;                throw new RuntimeException();            &#125;        &#125; catch (Exception e) &#123;            System.out.println(e);            toSend.setWord(MessageType.WRONG_REQUEST);            ServerUtils.sendMessage(toSend, oos);            return;        &#125;        /* 下面，根据不同信息包标识，我们做出不同反应 */        /* 接收到返回餐桌列表的请求 */        if (request.equals(MessageType.SHOW_TABLES)) &#123;            ServerUtils.showTables(toSend, oos);        /* 接收到检查餐桌的请求 */        &#125; else if (request.equals(MessageType.CHECK_TABLE)) &#123;            ServerUtils.checkTable(message, toSend, oos);        /* 接收到预定餐桌的请求 */        &#125; else if (request.equals(MessageType.ORDER_TABLE)) &#123;            ServerUtils.orderTable(message, toSend, oos);        /* 接收到返回菜单列表的请求 */        &#125; else if (request.equals(MessageType.SHOW_DISHES)) &#123;            ServerUtils.showDishes(toSend, oos);        /* 接收到检查菜单的请求 */        &#125; else if (request.equals(MessageType.CHECK_DISHES)) &#123;            ServerUtils.checkDishes(message, toSend, oos);        /* 接收到点餐的请求 */        &#125; else if (request.equals(MessageType.ORDER_DISHES)) &#123;            ServerUtils.orderDishes(message, toSend, oos);        /* 接收到返回账单列表的请求 */        &#125; else if (request.equals(MessageType.SHOW_ALL_BILLS)) &#123;            ServerUtils.showBills(toSend, oos);        /* 接收到检查账单的请求 */        &#125; else if (request.equals(MessageType.CHECK_BILLS)) &#123;            ServerUtils.checkBills(message, toSend, oos);        /* 接收到结账的请求 */        &#125; else if (request.equals(MessageType.FINISH_BILLS)) &#123;            ServerUtils.finishBills(message, toSend, oos);        /* 接收到登出的请求 */        &#125; else if (request.equals(MessageType.LOGOUT)) &#123;            System.out.println(targetIP + &quot; 登出 &quot; + loginData.getName() + LocalDateTime.now());            running = false;            closeAll();        &#125;    &#125;&#125;JAVA</code></pre><h6><span id="serverutilsjava">ServerUtils.java</span></h6><blockquote><p>服务端进程方法包。由 <em>RunningServer.java</em> 调用</p><p>该包实现：监听客户端数据包、发送数据包、处理（各种）客户端请求</p></blockquote><pre><code class="java">package com.melody.wmt.server;import com.melody.wmt.common.Message;import com.melody.wmt.common.MessageType;import com.melody.wmt.sql.*;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.List;/** * @author Melody * @version 1.0 */public class ServerUtils &#123;    /* 监听客户端发送的数据包 */    public static Message receiveMessage(ObjectInputStream ois) &#123;        try &#123;            Message message = (Message) ois.readObject();            return message;        &#125; catch (Exception e) &#123;            System.out.println(e);            return null;        &#125;    &#125;        /* 发送登录失败回执。这个方法其实可以优化掉 */    public static boolean sendRejection(String target, ObjectOutputStream oos) &#123;        Message message = new Message(Server.serverIP, target, MessageType.REJECT, null);        try &#123;            oos.writeObject(message);            oos.flush();            return true;        &#125; catch (IOException e) &#123;            System.out.println(e);            return false;        &#125;    &#125;        /* 检查用户信息。实际上就是检查用户名 */    public static boolean checkUser(String user, LoginData loginData) &#123;        if (user == null) &#123;            return false;        &#125;        String[] toCheck = user.split(&quot;\t&quot;);        if (toCheck[0].equals(loginData.getName())) &#123;            return new LoginDAO().checkLogin(toCheck[0], toCheck[1]) != null;        &#125; else &#123;            return false;        &#125;    &#125;        /* 检查登录信息。登录成功则返回从数据库得到的登录信息包，否则返回 null */    public static LoginData checkLogin(Message message) &#123;        if (message == null) &#123;            return null;        &#125;        String word = message.getWord();        if (word == null || !word.equals(MessageType.LOGIN)) &#123;            return null;        &#125;        try &#123;            word = (String) message.getObject();        &#125; catch (Exception e) &#123;            System.out.println(e);            return null;        &#125;        String[] data = word.split(&quot;\t&quot;);        if (data.length != 2) &#123;            return null;        &#125;        return new LoginDAO().checkLogin(data[0], data[1]);    &#125;        /* 发送数据包给客户端。很多方法会调用这个方法。这个方法也会刷新数据包时间戳 */    public static void sendMessage(Message toSend, ObjectOutputStream oos) &#123;        try &#123;            Thread.currentThread().sleep(300);//人为加入 0.3 秒发送延迟            toSend.setTimeStamp();//刷新数据包时间戳            oos.writeObject(toSend);            oos.flush();        &#125; catch (Exception e) &#123;            System.out.println(e);        &#125;    &#125;        /* 返回餐桌列表 */    public static void showTables(Message toSend, ObjectOutputStream oos) &#123;        /* 调用方法得到餐桌列表 */        List&lt;TableData&gt; tableData = new TableDAO().queryAll();        /* 将餐桌列表转化成字符串。发送时只发送这个字符串 */        StringBuilder sb = new StringBuilder();        for (TableData data : tableData) &#123;            sb.append(data);            sb.append(&quot;\n&quot;);        &#125;        toSend.setObject(sb.toString());        /* 设置数据包标识为请求通过 */        toSend.setWord(MessageType.ACCEPT);        /* 发送数据包 */        sendMessage(toSend, oos);    &#125;        /* 检查餐桌    ……这是因为：用户点餐、预定餐桌等场合，需要验证输入的餐桌信息 */    public static void checkTable(Message receive, Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* 检查用户请求的餐桌号 */            int table = Integer.parseInt(((String) receive.getObject()).split(&quot;\t&quot;)[2]);            TableData tableData = new TableDAO().queryTable(table);            /* 下面是根据返回结果，为数据包添加标识语句，并装入查到的餐桌数据 */            if (tableData == null) &#123;                toSend.setWord(MessageType.TABLE_NOT_EXIST);            &#125; else if (tableData.getOrder().equals(&quot;不可用&quot;)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_NOT_AVAILABLE);            &#125; else if (tableData.getOrder().equals(&quot;已预定&quot;)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_OCCUPIED);            &#125; else if (tableData.getOrder().equals(&quot;用餐&quot;)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_DINNING);            &#125; else if (tableData.getOrder().equals(&quot;空&quot;)) &#123;                toSend.setObject(tableData);                toSend.setWord(MessageType.TABLE_AVAILABLE);            &#125; else &#123;                toSend.setWord(MessageType.REJECT);            &#125;        /* 发生任何异常的场合，设置拒绝请求的标识语句 */        &#125; catch (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;        /* 预定餐桌 */    public static void orderTable(Message receive, Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* 前面说过。接收数据包含有一条被 \t 分隔为不同部分的语句。            这里：第三部分代表餐桌号，第四部分代表顾客名，第五部分代表顾客电话*/            String[] mess = ((String) receive.getObject()).split(&quot;\t&quot;);            int table = Integer.parseInt(mess[2]);            String customerName = mess[3];            String call = mess[4];            CustomerDAO customerDAO = new CustomerDAO();            /* 根据接收的顾客信息（姓名、电话）对数据库进行查询，看看有没有这个人            这里，customer &gt; 0 的场合代表有这个人 */            int customer = customerDAO.searchCustomer(customerName, call);            /* 没有这个信息的场合，创建这个顾客信息 */            if (customer &lt; 0) &#123;                customerDAO.createCustomer(customerName, call);                customer = customerDAO.searchCustomer(customerName, call);            &#125;            /* 通常到这里不会出现查无此人的情况。如果出现，说明创建信息失败 */            if (customer &lt; 0) &#123;                throw new RuntimeException();            &#125;            /* 到这里，我们进行预定餐桌操作。返回 true 表示成功 */            if (new TableDAO().orderTable(table, customer)) &#123;                toSend.setWord(MessageType.ACCEPT);            &#125; else &#123;                toSend.setWord(MessageType.REJECT);            &#125;        /* 出现任何问题，我们设置请求拒绝标识符 */        &#125; catch (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;        /* 返回菜单列表 */    public static void showDishes(Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* 首先获取菜单列表 */            List&lt;DishesData&gt; dishes = new DishesDAO().getDishes();            /* 接下来，把菜单列表转化为字符串 */            StringBuilder staple = new StringBuilder();            StringBuilder mainDishes = new StringBuilder();            StringBuilder coldDishes = new StringBuilder();            StringBuilder beverage = new StringBuilder();            StringBuilder soup = new StringBuilder();            StringBuilder sweetmeats = new StringBuilder();            for (DishesData d : dishes) &#123;                if (d.getAvailable().equals(&quot;n&quot;)) &#123;                    continue;                &#125;                String spec = d.getSpecies();                if (spec.equals(&quot;主食&quot;)) &#123;                    staple.append(d);                    staple.append(&quot;\n&quot;);                &#125; else if (spec.equals(&quot;甜点&quot;)) &#123;                    sweetmeats.append(d);                    sweetmeats.append(&quot;\n&quot;);                &#125; else if (spec.equals(&quot;汤品&quot;)) &#123;                    soup.append(d);                    soup.append(&quot;\n&quot;);                &#125; else if (spec.equals(&quot;凉菜&quot;)) &#123;                    coldDishes.append(d);                    coldDishes.append(&quot;\n&quot;);                &#125; else if (spec.equals(&quot;饮料&quot;)) &#123;                    beverage.append(d);                    beverage.append(&quot;\n&quot;);                &#125; else if (spec.equals(&quot;主菜&quot;)) &#123;                    mainDishes.append(d);                    mainDishes.append(&quot;\n&quot;);                &#125;            &#125;            /* 合并字符串，以 ### 间隔不同种类 */            String allDishes = String.join(&quot;###&quot;, staple, mainDishes, coldDishes, soup, sweetmeats, beverage);            /* 装填数据包 */            toSend.setWord(MessageType.ACCEPT);            toSend.setObject(allDishes);        /* 出了问题就设置拒绝请求标识符 */        &#125; catch (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;        /* 检查菜单。和检查餐桌是一个道理 */    public static void checkDishes(Message receive, Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* 前面说过。接收数据包含有一条被 \t 分隔为不同部分的语句。            这里：第三部分代表查询菜品的 ID */            String[] mess = ((String) receive.getObject()).split(&quot;\t&quot;);            int id = Integer.parseInt(mess[2]);            Object o = new DishesDAO().checkDishes(id);            if (o == null) &#123;                toSend.setWord(MessageType.NOT_FOUND);            &#125; else if (!(o instanceof DishesData)) &#123;                throw new RuntimeException();            &#125; else &#123;                toSend.setWord(MessageType.ACCEPT);                toSend.setObject(o.toString());            &#125;        /* 出现任何问题就设置请求拒绝标识符 */        &#125; catch (RuntimeException e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;        /* 点餐 */    public static void orderDishes(Message receive, Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* 前面说过……反正前面说过这个 String 的事！            这里：第三部分是菜品 ID，第四部分是数量，                第五部分是桌号，第六部分是顾客号 */            String[] mess = ((String) receive.getObject()).split(&quot;\t&quot;);            int dishes = Integer.parseInt(mess[2]);            /* 检查一下菜品是不是正确 */            /* 这里有一处疏忽。应该一并检查是否菜品可用（available） */            Object o = new DishesDAO().checkDishes(dishes);            if (!(o instanceof DishesData)) &#123;                throw new RuntimeException();            &#125;            int num = Integer.parseInt(mess[3]);            int table = Integer.parseInt(mess[4]);            int customer = Integer.parseInt(mess[5]);            /* 尝试点餐 */            if (new BillDAO().order(dishes, num, table, customer)) &#123;                new TableDAO().updateTable(table, 2);                toSend.setWord(MessageType.ACCEPT);            &#125; else &#123;                toSend.setWord(MessageType.REJECT);            &#125;        /* 出现任何问题就设置请求拒绝标识符 */        &#125; catch (RuntimeException e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;        /* 返回账单列表 */    public static void showBills(Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* 和之前的方法一样。这里我们发送的是拼接起来的字符串 */            List&lt;DetailBillData&gt; billData = new BillDAO().queryBills();            StringBuilder finished = new StringBuilder();            StringBuilder unfinished = new StringBuilder();            for (DetailBillData d : billData) &#123;                if (d.getClear().equals(&quot;n&quot;)) &#123;                    unfinished.append(d);                    unfinished.append(&quot;\n&quot;);                &#125; else &#123;                    finished.append(d);                    finished.append(&quot;\n&quot;);                &#125;            &#125;            toSend.setWord(MessageType.ACCEPT);            toSend.setObject(String.join(&quot;###&quot;, finished, unfinished));        /* 出现任何问题就设置请求拒绝标识符 */        &#125; catch (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;        /* 检查订单 */    public static void checkBills(Message receive, Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* ……这里：第三部分是一个标识符。T 表示按桌号查找                    第四部分是序号。按桌号查找的话，就代表桌号                    第五部分是一个布尔值句子。true 表示查询已付订单，                        false 是未付订单。为空表示查询所有订单 */            String[] mess = ((String) receive.getObject()).split(&quot;\t&quot;);            List&lt;DetailBillData&gt; billData = null;            StringBuilder sb = new StringBuilder();            if (mess[2].equals(&quot;t&quot;) || mess[2].equals(&quot;T&quot;)) &#123;                Boolean clear;                if (mess.length &lt; 5) &#123;                    clear = null;                &#125; else if (mess[4].equals(&quot;true&quot;)) &#123;                    clear = true;                &#125; else if (mess[4].equals(&quot;false&quot;)) &#123;                    clear = false;                &#125; else &#123;                    clear = null;                &#125;                billData = new BillDAO().queryBillsByTable(Integer.parseInt(mess[3]), clear);            &#125;            /* 同样的，还是返回字符串 */            for (DetailBillData data : billData) &#123;                sb.append(billData);                sb.append(&quot;\n&quot;);            &#125;            toSend.setObject(sb.toString());            toSend.setWord(MessageType.ACCEPT);        /* 出现任何问题就设置请求拒绝标识符 */        &#125; catch (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;        /* 结算订单 */    public static void finishBills(Message receive, Message toSend, ObjectOutputStream oos) &#123;        try &#123;            /* 第三位是桌号，第四位是结算方法 */             String[] mess = ((String) receive.getObject()).split(&quot;\t&quot;);            int table = Integer.parseInt(mess[2]);            int way = Integer.parseInt(mess[3]);            /* 不光更新订单信息，也要把指定餐桌重置为空 */            boolean finish = new BillDAO().finishBill(table, way) &gt; 0 &amp;&amp; new TableDAO().clearTable(table);            toSend.setWord(finish ? MessageType.ACCEPT : MessageType.REJECT);        /* 出现任何问题就设置请求拒绝标识符 */        &#125; catch (Exception e) &#123;            toSend.setWord(MessageType.REJECT);        /* 最终一定发送数据包 */        &#125; finally &#123;            sendMessage(toSend, oos);        &#125;    &#125;&#125;JAVA</code></pre><h5><span id="commelodywmtsql">com.melody.wmt.sql</span></h5><h6><span id="wanminsqlproperties">WanMinSQL.properties</span></h6><blockquote><p>数据库配置文件</p><p>里面的密码填自己的。另外，其实上一篇笔记里故意漏的密码是假的。</p></blockquote><pre><code class="properties">driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/wan_minusername=rootpassword=******initialSize=10minIdle=5maxActive=50maxWait=5000JAVA</code></pre><h6><span id="basicdaojava">BasicDAO.java</span></h6><blockquote><p><em><strong>——详见 [[23.9 BasicDAO](<a href="https://i-melody.github.io/2022/02/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/23">https://i-melody.github.io/2022/02/20/Java/入门阶段/23</a> JDBC 和数据库连接池&#x2F;#23-9-BasicDAO)]</strong></em></p><p>代码和上面说的是一样的……大概？</p></blockquote><pre><code class="java">package com.melody.wmt.sql;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import java.sql.Connection;import java.sql.SQLException;import java.util.List;/** * @author Melody * @version 1.0 */public class BasicDAO&lt;T&gt; &#123;    private QueryRunner queryRunner = new QueryRunner();    public int update(String sql, Object... parameters)&#123;        Connection connection = null;        try &#123;            connection = JDBCUtil.connect();            return queryRunner.update(connection, sql, parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtil.close(connection, null, null);        &#125;    &#125;    public List&lt;T&gt; queryMulti(Class&lt;T&gt; tClass, String sql, Object... parameters) &#123;        Connection connection = null;        try &#123;            connection = JDBCUtil.connect();            return queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(tClass), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtil.close(connection, null, null);        &#125;    &#125;    public T querySingle(Class&lt;T&gt; tClass, String sql, Object... parameters) &#123;        Connection connection = null;        try &#123;            connection = JDBCUtil.connect();            return queryRunner.query(connection, sql, new BeanHandler&lt;&gt;(tClass), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtil.close(connection, null, null);        &#125;    &#125;    public Object queryScalar(String sql, Object... parameters) &#123;        Connection connection = null;        try &#123;            connection = JDBCUtil.connect();            return queryRunner.query(connection, sql, new ScalarHandler&lt;&gt;(), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JDBCUtil.close(connection, null, null);        &#125;    &#125;&#125;JAVA</code></pre><h6><span id="jdbcutiljava">JDBCUtil.java</span></h6><blockquote><p><em><strong>——见 [[23.7.2 Druid（德鲁伊）连接池](<a href="https://i-melody.github.io/2022/02/20/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/23">https://i-melody.github.io/2022/02/20/Java/入门阶段/23</a> JDBC 和数据库连接池&#x2F;#23-7-2-Druid（德鲁伊）连接池) ]</strong></em></p></blockquote><pre><code class="java">package com.melody.wmt.sql;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.FileReader;import java.io.IOException;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * @author Melody * @version 1.0 */public class JDBCUtil &#123;    private static DataSource dataSource = null;    static &#123;        Properties properties = new Properties();        try &#123;            properties.load(new FileReader(&quot;src\\com\\melody\\wmt\\sql\\WanMinSQL.properties&quot;));            dataSource = DruidDataSourceFactory.createDataSource(properties);        &#125; catch (Exception e) &#123;            new RuntimeException(e);        &#125;    &#125;    public static Connection connect() throws SQLException &#123;        return dataSource.getConnection();    &#125;    public static void close(Connection c, Statement s, ResultSet r) &#123;        try &#123;            if (c != null) &#123;                c.close();            &#125;            if (r != null) &#123;                r.close();            &#125;            if (s != null) &#123;                s.close();            &#125;        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;JAVA</code></pre><h6><span id="tabledaojava-tabledatajava">TableDAO.java、TableData.java</span></h6><blockquote><p>对应数据库的 <em>table</em> 表</p></blockquote><pre><code class="java">package com.melody.wmt.sql;import java.util.List;/** * @author Melody * @version 1.0 */public class TableDAO extends BasicDAO&#123;    /* 返回全部的餐桌对象 */    public List&lt;TableData&gt; queryAll()&#123;        String sql = &quot;select * from `table`&quot;;        List&lt;TableData&gt; list = queryMulti(TableData.class, sql);        return list;    &#125;        /* 返回 ID 指定的餐桌对象。没找到的场合返回 null */    public TableData queryTable(int id) &#123;        String sql = &quot;select * from `table` where `id` = ?&quot;;        TableData tableData = null;        try &#123;            tableData = (TableData) querySingle(TableData.class, sql, id);        &#125; catch (Exception e) &#123;            return null;        &#125;        return tableData;    &#125;        /* 设置指定 ID 的餐桌对象的 order 和 customer */    public boolean orderTable(int id, int customer) &#123;        TableData tableData = queryTable(id);        if (!tableData.getOrder().equals(&quot;空&quot;))&#123;            return false;        &#125;        String sql = &quot;update `table` set `order` = &#39;已预定&#39;, `customer` = ? where `id` = ?&quot;;        int update = update(sql, customer, id);        return update &gt; 0;    &#125;        /* 更新指定 ID 餐桌对象的 order 状态。一般是把 已预定 状态改为 用餐 */    public boolean updateTable(int id, int n) &#123;        String sql = &quot;update `table` set `order` = ? where `id` = ?&quot;;        String order = null;        switch (n)&#123;            case 1:                order = &quot;已预定&quot;;                break;            case 2:                order = &quot;用餐&quot;;                break;            case 3:                order = &quot;空&quot;;                break;            case 4:                order = &quot;不可用&quot;;                break;            default:                return false;        &#125;        return update(sql, order, id) &gt; 0;    &#125;        /* 清理指定 ID 的餐桌。通常是结账后调用这个方法 */    public boolean clearTable(int table) &#123;        String sql = &quot;update `table` set `order` = &#39;空&#39;, `customer` = null where `id` = ?&quot;;        return update(sql, table) &gt; 0;    &#125;&#125;JAVApackage com.melody.wmt.sql;import java.io.Serializable;/** * @author Melody * @version 1.0 */public class TableData implements Serializable &#123;    private int id;    private String order;    private int customer;    private int seat;    public TableData() &#123;    &#125;    public TableData(int id, String order, int customer, int seat) &#123;        this.id = id;        this.order = order;        this.customer = customer;        this.seat = seat;    &#125;        /* 省略了 getter 和 setter。实际代码里是有的 */    @Override    public String toString() &#123;        return id + &quot;\t&quot; + seat + &quot;\t&quot; + order + &quot;\t&quot; + (customer == 0 ? &quot;-&quot; : customer);    &#125;&#125;JAVA</code></pre><h6><span id="logindaojava-logindatajava">LoginDAO.java、LoginData.java</span></h6><blockquote><p>对应数据库的 <em>Login</em> 表</p></blockquote><pre><code class="java">package com.melody.wmt.sql;/** * @author Melody * @version 1.0 */public class LoginDAO extends BasicDAO&#123;    /* 返回指定 name 和 password 的对象。没有匹配项则返回 null */    public LoginData checkLogin(String name, String password)&#123;        try &#123;            /* 这里体现出，密码是由 md5 方法加密的 */            String sql = &quot;select * from login where name = ? and password = md5(?)&quot;;            LoginData loginData = (LoginData) querySingle(LoginData.class, sql, name, password);            return loginData;        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;&#125;JAVApublic class LoginData implements Serializable &#123;    private int id;    private String name;    private String password;    public LoginData()&#123;&#125;    public LoginData(int id, String name, String password) &#123;        this.id = id;        this.name = name;        this.password = password;    &#125;        /* 省略了 getter 和 setter。实际代码里是有的 */&#125;JAVA</code></pre><h6><span id="dishesdaojava-dishesdatajava">DishesDAO.java、DishesData.java</span></h6><blockquote><p>对应数据库的 <em>Dishes</em> 表</p></blockquote><pre><code class="java">package com.melody.wmt.sql;import java.util.List;/** * @author Melody * @version 1.0 */public class DishesDAO extends BasicDAO&#123;    /* 返回所有菜单 */    public List&lt;DishesData&gt; getDishes() &#123;        String sql = &quot;select * from `dishes`&quot;;        return queryMulti(DishesData.class, sql);    &#125;        /* 返回 ID 指定的菜单。没有则返回 null */    public Object checkDishes(int id) &#123;        String sql = &quot;select * from `dishes` where `id` = ?&quot;;        return querySingle(DishesData.class, sql, id);    &#125;&#125;JAVApublic class DishesData &#123;    private int id;    private String name;    private int price;    private String species;    private String available;    public DishesData()&#123;&#125;    public DishesData(int id, String name, int price, String species, String available) &#123;        this.id = id;        this.name = name;        this.price = price;        this.species = species;        this.available = available;    &#125;        /* 省略了 getter 和 setter。实际代码里是有的 */    @Override    public String toString() &#123;        return id + &quot;\t&quot; + name + &quot;\t&quot; + price;    &#125;&#125;JAVA</code></pre><h6><span id="customerdaojava-customerdatajava">CustomerDAO.java、CustomerData.java</span></h6><blockquote><p>对应数据库的 <em>Customer</em> 表</p></blockquote><pre><code class="java">package com.melody.wmt.sql;/** * @author Melody * @version 1.0 */public class CustomerDAO extends BasicDAO &#123;    /* 返回 name 和 call 指定的顾客信息。没有则返回 null */    public int searchCustomer(String name, String call) &#123;        String sql = &quot;select * from customer where `name` = ? and `call` = ?&quot;;        Object o = querySingle(CustomerData.class, sql, name, call);        return o == null ? -1 : ((CustomerData) o).getId();    &#125;        /* 创建顾客信息，信息包含 name 和 call */    public boolean createCustomer(String name, String call) &#123;        String sql = &quot;insert into customer (`name`, `call`) values(?, ?)&quot;;        int update = update(sql, name, call);        return update &gt; 0;    &#125;&#125;JAVApackage com.melody.wmt.sql;/** * @author Melody * @version 1.0 */public class CustomerData &#123;    private int id;    private String name;    private String card_id;    private String call;    public CustomerData()&#123;&#125;    public CustomerData(int id, String name, String card_id, String call) &#123;        this.id = id;        this.name = name;        this.card_id = card_id;        this.call = call;    &#125;        /* 省略了 getter 和 setter。实际代码里是有的 */&#125;JAVA</code></pre><h6><span id="billdaojava-billdatajava-detailbilldatajava">BillDAO.java、BillData.java、DetailBillData.java</span></h6><blockquote><p>对应数据库的 <em>Bill</em> 表，<em>Detail_Bill</em> 视图</p></blockquote><pre><code class="java">package com.melody.wmt.sql;import java.util.List;/** * @author Melody * @version 1.0 */public class BillDAO extends BasicDAO &#123;    /* 订餐。形参是 餐品号、数量、桌号、顾客号。成功的场合返回 true */    public boolean order(int dishes, int num, int table, int customer) &#123;        String sql = &quot;insert into `bill` (`dishes`, `num`, `table`, `customer`) values(?, ?, ?, ?)&quot;;        int update = update(sql, dishes, num, table, customer);        return update &gt; 0;    &#125;        /* 返回账单列表 */    public List&lt;DetailBillData&gt; queryBills() &#123;        String sql = &quot;select * from detail_bill&quot;;        return (List&lt;DetailBillData&gt;) queryMulti(DetailBillData.class, sql);    &#125;        /* 返回特定桌号的帐单列表    Boolean 为 true 则返回未付账单；false 返回已结账单；null 返回全部 */    public List&lt;DetailBillData&gt; queryBillsByTable(int table, Boolean clear) &#123;        String sql;        if (clear == null) &#123;            sql = &quot;select * from detail_bill where `table` = ?&quot;;        &#125; else &#123;            sql = &quot;select * from detail_bill where `table` = ? and &quot; + (clear ? &quot;&quot; : &quot;not&quot;) + &quot; `clear` = &#39;n&#39;&quot;;        &#125;        return (List&lt;DetailBillData&gt;) queryMulti(DetailBillData.class, sql, table);    &#125;        /* 将指定桌号的所有未付账单结算，其结算方式为 way 指定的方式 */    public int finishBill(int table, int way) &#123;        String clear;        if (way == 1) &#123;            clear = &quot;y&quot;;        &#125; else if (way == 2) &#123;            clear = &quot;alipay&quot;;        &#125; else if (way == 3) &#123;            clear = &quot;wc_pay&quot;;        &#125; else &#123;            throw new RuntimeException();        &#125;        String sql = &quot;update bill set `clear` = ? where `table` = ? and `clear` = &#39;n&#39;&quot;;        return update(sql, clear, table);    &#125;&#125;JAVApublic class BillData &#123;    private int id;    private Date date;    private int customer;    private int table;    private int num;    private String clear;    private int dishes;    public BillData() &#123;    &#125;    public BillData(int id, Date date, int customer, int table, int num, String clear, int dishes) &#123;        this.id = id;        this.date = date;        this.customer = customer;        this.table = table;        this.num = num;        this.clear = clear;        this.dishes = dishes;    &#125;    /* 省略了 getter 和 setter。实际代码里是有的 */    @Override    public String toString() &#123;        return id + &quot;\t&quot; + customer + &quot;\t&quot; + table + &quot;\t&quot; + num + &quot;\t&quot; + clear + &quot;\t&quot; + dishes + &quot;\t&quot; + date;    &#125;&#125;JAVApublic class DetailBillData &#123;    private String name;    private String call;    private int table;    private String dishes;    private int num;    private Date date;    private String clear;    public DetailBillData() &#123;    &#125;    public DetailBillData(String name, String call, int table, String dishes, int num, Date date, String clear) &#123;        this.name = name;        this.call = call;        this.table = table;        this.dishes = dishes;        this.num = num;        this.date = date;        this.clear = clear;    &#125;    /* 省略了 getter 和 setter。实际代码里是有的 */    @Override    public String toString() &#123;        return name + &quot;\t&quot; + call + &quot;\t&quot; + table + &quot;\t&quot; + dishes + &quot;\t&quot; + num + &quot;\t&quot; + date + &quot;\t&quot; + clear;    &#125;&#125;JAVA</code></pre><h4><span id="客户端管理部分">客户端（管理）部分</span></h4><h5><span id="commelodywmtclient">com.melody.wmt.client;</span></h5><h6><span id="clinetjava">Clinet.java</span></h6><blockquote><p>客户端程序主体</p><p>该包实现：登录界面、菜单界面、选择菜单</p></blockquote><pre><code class="java">package com.melody.wmt.client;import com.melody.wmt.sql.LoginData;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;/** * @author Melody * @version 1.0 */public class Client &#123;    public static String IP;//自己的 IP    public static String ServerIP = &quot;192.168.3.16&quot;;//服务端 IP    private static Scanner scanner = new Scanner(System.in);    private Socket socket;    private ObjectInputStream ois;//输入流    private ObjectOutputStream oos;//输出流                                //以上三个属性会在 connect() 方法中被赋值    public final MenuUtility menuUtility = new MenuUtility(this);                                //方法类对象，传入形参 this，形成了互相持有的结构    public final Listening listening = new Listening(this);                                //监听类对象，传入形参 this，形成了互相持有的结构    public LoginData loginData = null;                                //用户数据。登陆后服务端会发送一个该类对象过来    public boolean skipMenu = false;                                //跳过菜单显示。该属性没有投入使用        /* 多此一举地初始化自己的 IP 地址。其实可以直接写。 */    static &#123;        try &#123;            IP = InetAddress.getLocalHost().getHostAddress();        &#125; catch (UnknownHostException e) &#123;            System.out.println(e);            IP = &quot;192.168.3.16&quot;;        &#125;    &#125;    /* 展示主菜单 */    public void mainMenu() &#123;        char read;        while (true) &#123;            System.out.println(&quot;====================================&quot;);            System.out.println(&quot;\t\t1. 登 录 系 统&quot;);            System.out.println(&quot;\t\t9. 退 出 系 统&quot;);            System.out.print(&quot;请选择：&quot;);            read = scanner.next().charAt(0);            System.out.println();            System.out.println(&quot;------------------------------------&quot;);            switch (read) &#123;                case &#39;1&#39;:                    /* 这里会先建立连接 connect()，然后调用登录方法 login() */                    if (connect() &amp;&amp; menuUtility.login()) &#123;                        try &#123;                            menu_1();                        &#125; catch (Exception e) &#123;                            System.out.println(e);                            /* 有任何问题会执行 closeAll()，即关闭一切流 */                            closeAll();                        &#125;                    &#125;                    closeAll();                    break;                case &#39;9&#39;:                    if (menuUtility.out()) &#123;                        return;                    &#125;                    break;                default:                    System.out.println(&quot;输入错误。&quot;);                    break;            &#125;        &#125;    &#125;        /* 建立连接 */    public boolean connect() &#123;        try &#123;            socket = new Socket(ServerIP, 9000);            oos = new ObjectOutputStream(socket.getOutputStream());            ois = new ObjectInputStream(socket.getInputStream());            new Thread(listening).start();            return true;        &#125; catch (IOException e) &#123;            System.out.println(e);            closeAll();            return false;        &#125;    &#125;        /* 关闭所有流。通常是登出、断线或报错后执行这个方法 */    public void closeAll() &#123;        try &#123;            if (ois != null) &#123;                ois.close();            &#125;            if (oos != null) &#123;                oos.close();            &#125;            if (socket != null) &#123;                socket.close();            &#125;            listening.listening = false;        &#125; catch (IOException e) &#123;            System.out.println(e);        &#125;    &#125;        /* 显示（登录）菜单。这个类只是在屏幕上输出字符 */    public void showMenu_1() &#123;        /* 设置了跳过菜单显示的场合，仅一次菜单不显示 */        if (skipMenu)&#123;            skipMenu = false;            return;        &#125;        System.out.println(&quot;================&quot; + loginData.getName() + &quot;================&quot;);        System.out.println(&quot;\t\t1. 餐 桌 状 态&quot;);        System.out.println(&quot;\t\t2. 预 定 餐 桌&quot;);        System.out.println(&quot;\t\t3. 菜 单&quot;);        System.out.println(&quot;\t\t4. 点 餐&quot;);        System.out.println(&quot;\t\t5. 账 单&quot;);        System.out.println(&quot;\t\t6. 结 账&quot;);        System.out.println(&quot;\t\t9. 登 出 系 统&quot;);    &#125;        /* 根据菜单选择执行的功能 */    public void menu_1() &#123;        char read;        while (true) &#123;            /* 显示菜单。设置跳过的场合仅一次菜单不显示 */            showMenu_1();            System.out.print(&quot;请选择：&quot;);            read = scanner.next().charAt(0);            System.out.println(&quot;------------------------------------&quot;);            switch (read) &#123;                case &#39;1&#39;:                    menuUtility.showTables();//展示餐桌列表                    break;                case &#39;2&#39;:                    menuUtility.orderTable();//预定餐桌                    break;                case &#39;3&#39;:                    menuUtility.showList();//展示菜单列表                    break;                case &#39;4&#39;:                    menuUtility.orderDishes();//订餐                    break;                case &#39;5&#39;:                    menuUtility.showBill();//展示账单列表                    break;                case &#39;6&#39;:                    menuUtility.payBill();//结账                    break;                case &#39;9&#39;:                    if (menuUtility.logout()) &#123;//登出                        return;                    &#125;                    break;                default:                    System.out.println(&quot;输入错误。&quot;);                    break;            &#125;        &#125;    &#125;    public Socket getSocket() &#123;        return socket;    &#125;    public ObjectInputStream getOis() &#123;        return ois;    &#125;    public ObjectOutputStream getOos() &#123;        return oos;    &#125;        /* 抛出一个异常。这个方法用于抛出异常（听君一席话……） */    public void throwException(String s) &#123;        throw new RuntimeException(s);    &#125;&#125;JAVA</code></pre><h6><span id="listeningjava">Listening.java</span></h6><blockquote><p>监听服务端发送数据包的线程</p></blockquote><pre><code class="java">package com.melody.wmt.client;import com.melody.wmt.common.Message;/** * @author Melody * @version 1.0 */public class Listening implements Runnable&#123;    private Client client;//和主程序相互持有，便于调用    public Message message;//接收的数据包    public boolean listening = true;//监听中。false 会停止线程    public boolean received = false;//收到文件。                            //这是实现某个方法的过渡办法，似乎已经可以弃用    public Listening(Client client) &#123;        this.client = client;    &#125;    @Override    public void run() &#123;        listening = true;        while (listening)&#123;            try &#123;                Object o = client.getOis().readObject();                if (o == null)&#123;                    continue;                &#125;                message = (Message) o;                received = true;            &#125;catch (Exception e) &#123;                client.throwException(&quot;监听异常&quot; + e);            &#125;        &#125;        System.out.println(&quot;监听停止&quot;);    &#125;&#125;JAVA</code></pre><h6><span id="menuutilityjava">MenuUtility.java</span></h6><blockquote><p>客户端程序的方法包</p><p>该包实现：……大部分功能</p></blockquote><pre><code class="java">package com.melody.wmt.client;import com.melody.wmt.common.Message;import com.melody.wmt.common.MessageType;import com.melody.wmt.sql.LoginData;import com.melody.wmt.sql.TableData;import java.io.IOException;import java.util.Scanner;/** * @author Melody * @version 1.0 */public class MenuUtility &#123;    private Scanner scanner = new Scanner(System.in);    private Client client;//和主程序互相持有，方便调用    private String userData = null;//内容是：&quot;用户名\t密码&quot;。                            //每个发送的数据包的 Object 开头都是这个    public MenuUtility(Client client) &#123;        this.client = client;    &#125;        /* 发送数据包，并返回接收的数据包 */    /* 通常会返回接收到的数据包。也可能返回 null 代表失败 */    public Message sendAndReceive(Message message) &#123;        /* 发送包不能为 null。基本上不会出现这种情况 */        if (message == null) &#123;            System.out.println(&quot;错误：传递空包&quot;);            return null;        &#125;        /* 刷新数据包时间戳 */        message.setTimeStamp();        /* 清空监听进程里已有的数据 */        client.listening.received = false;        client.listening.message = null;        /* 接收数据包对象 */        Message receive = null;        try &#123;            /* 发送数据包 */            client.getOos().writeObject(message);            /* 标记此时的时间 */            long time = System.currentTimeMillis();            int n = 0;            /* 在指定时间内持续试图接收服务端数据包 */            /* 经测试，在 while(true) 中如果只有单一的 if 语句，                那么该 if 语句条件（或主体）只会执行一次。                这会造成客户端接收不到服务端数据包。                因此，加入了无关紧要的小动画，确保 if 语句总会重复执行。*/            while (true) &#123;                n++;                System.out.print(&quot;\r&quot;);                /* if 语句中的才是主体                    接收到数据包或者等待 5 秒以上后，拿取数据包并跳出该循环 */                if (System.currentTimeMillis() - time &gt;= 5000 | client.listening.received) &#123;                    receive = client.listening.message;                    break;                &#125;                /* 下面是一个旋转线条的小动画。                    由于上面的 \r 存在，该动画在程序继续后会被其他字符覆盖 */                switch (n % 4) &#123;                    case 1:                        System.out.print(&quot;|&quot;);                        break;                    case 2:                        System.out.print(&quot;/&quot;);                        break;                    case 3:                        System.out.print(&quot;-&quot;);                        break;                    default:                        System.out.print(&quot;\\&quot;);                        break;                &#125;            &#125;            return receive;        /* 有任何异常则返回 null */        &#125; catch (IOException e) &#123;            System.out.println(e);            return null;        &#125;    &#125;    /* 实现登录验证 */    public boolean login() &#123;        System.out.print(&quot;请输入用户名：&quot;);        String user = scanner.next();        System.out.print(&quot;请输入密码：&quot;);        String pw = scanner.next();        System.out.println();        /* 这句字符串会被重复使用 */        userData = (user + &quot;\t&quot; + pw);        /* 发送数据包。这里写得比较挤，后面我都分开写了 */        Message receive = sendAndReceive(new Message(Client.IP, Client.ServerIP, MessageType.LOGIN, userData));        /* 根据返回包做出相应提示 */        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);            return false;        &#125;        String reply = receive.getWord();        if (reply.equals(MessageType.LOGIN_USER_NOT_EXIST)) &#123;            System.out.println(&quot;错误：用户名不存在&quot;);        &#125; else if (reply.equals(MessageType.LOGIN_WRONG_PW)) &#123;            System.out.println(&quot;错误：密码错误&quot;);        &#125; else if (reply.equals(MessageType.ACCEPT)) &#123;            try &#123;                client.loginData = (LoginData) receive.getObject();            &#125; catch (Exception e) &#123;                System.out.println(&quot;未知错误&quot;);                return false;            &#125;            System.out.println(&quot;登录成功&quot;);        &#125;        /* 返回值。true 表示登陆成功 */        return receive.getWord().equals(MessageType.ACCEPT);    &#125;        /* 退出确认。这是未登录时（即，登陆界面）的退出方法 */    public boolean out() &#123;        System.out.print(&quot;确定退出吗？（Y/N）&quot;);        char answer = scanner.next().charAt(0);        return answer == &#39;Y&#39; || answer == &#39;y&#39;;    &#125;        /* 展示餐桌列表 */    public boolean showTables() &#123;        /* 发送请求，接收服务端返回的数据包 */        Message message = new Message(Client.IP, Client.ServerIP, MessageType.SHOW_TABLES, userData);        Message receive = sendAndReceive(message);        /* 根据返回包的不同作出反应 */        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);            return false;        &#125;        String r = receive.getWord();        if (r.equals(MessageType.REJECT)) &#123;            System.out.println(&quot;错误：服务器拒绝了请求&quot;);            return false;        &#125; else if (r.equals(MessageType.ACCEPT)) &#123;            System.out.println(&quot;ID\t座数\t状态\t顾客&quot;);            System.out.println(receive.getObject());            return true;        &#125; else &#123;            System.out.println(&quot;错误：未知的回执&quot; + r);            return false;        &#125;    &#125;        /* 检查餐桌状态 */    /* need：1不可用；2不存在；3占用未点餐；4占用已点餐；5未占用；6占用        根据需要的餐桌状态 need 的不同，有不同的返回方法*/    public TableData checkTable(int tableID, int need) &#123;        /* 发送验证餐桌请求，接收返回包 */        Message message = new Message(client.IP, client.ServerIP, MessageType.CHECK_TABLE, userData + &quot;\t&quot; + tableID);        Message receive = sendAndReceive(message);        /* 根据返回包做出不同反应 */        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);            return null;        &#125;        /* 如果 need 和返回结果匹配，give 值会为 true */        boolean give = false;        if (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(&quot;错误：请求被拒绝&quot;);        &#125; else if (receive.getWord().equals(MessageType.TABLE_NOT_AVAILABLE)) &#123;            give = need == 1;            System.out.print(give ? &quot;&quot; : &quot;餐桌不可用\n&quot;);        &#125; else if (receive.getWord().equals(MessageType.TABLE_NOT_EXIST)) &#123;            give = need == 2;            System.out.print(give ? &quot;&quot; : &quot;餐桌不存在\n&quot;);        &#125; else if (receive.getWord().equals(MessageType.TABLE_OCCUPIED)) &#123;            give = need == 3 || need == 6;            System.out.print(give ? &quot;&quot; : &quot;餐桌被占用（未点餐）\n&quot;);        &#125; else if (receive.getWord().equals(MessageType.TABLE_DINNING)) &#123;            give = need == 4 || need == 6;            System.out.print(give ? &quot;&quot; : &quot;餐桌被占用（已点餐）\n&quot;);        &#125; else if (receive.getWord().equals(MessageType.TABLE_AVAILABLE)) &#123;            give = need == 5;            System.out.print(give ? &quot;&quot; : &quot;餐桌为空\n&quot;);        &#125; else &#123;            System.out.println(&quot;错误：未知错误&quot;);        &#125;        try &#123;            /* 只有匹配的结果才会返回餐桌数据 */            return give ? (TableData) receive.getObject() : null;        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;        /* 预定餐桌 */    public void orderTable() &#123;        /* 首先会调用一次展示餐桌的方法 */        showTables();        /* 输入餐桌号 */        System.out.println(&quot;------------------------------------&quot;);        System.out.print(&quot;请输入预定的餐桌号码（-1取消）：&quot;);        int tableID = 0;        try &#123;            tableID = Integer.parseInt(scanner.next());            if (tableID == -1) &#123;                return;            &#125; else if (tableID &lt;= 0) &#123;                throw new RuntimeException();            &#125;        &#125; catch (Exception e) &#123;            System.out.println(&quot;输入错误。&quot;);            return;        &#125;        /* 检查一下上面输入的餐桌是否正确。这时的正确指的是餐桌为空 */        TableData tableData = checkTable(tableID, 5);        if (tableData == null) &#123;            return;        &#125;        System.out.print(&quot;请输入预定人名字：&quot;);        String name = scanner.next();        System.out.println(&quot;请输入预定人电话：&quot;);        String call = scanner.next();        System.out.println(&quot;请确认预定信息：&quot;);        System.out.println(&quot;桌号：&quot; + tableData.getId() + &quot;\t座数：&quot; + tableData.getSeat() + &quot;\t预定人：&quot; + name + &quot;\t电话：&quot; + call);        System.out.print(&quot;确定吗？（Y/N）：&quot;);        char confirm = scanner.next().charAt(0);        if (confirm != &#39;Y&#39; &amp;&amp; confirm != &#39;y&#39;) &#123;            return;        &#125;        /* 发送请求预定餐桌。前面的顾客对象不存在的话，服务端会自动创建新的对象 */        Message message = new Message(client.IP, client.ServerIP, MessageType.ORDER_TABLE, userData + &quot;\t&quot; + tableID + &quot;\t&quot; + name + &quot;\t&quot; + call);        Message receive = sendAndReceive(message);        if (receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(&quot;预定成功！&quot;);        &#125; else &#123;            System.out.println(&quot;预定失败&quot;);        &#125;    &#125;        /* 展示菜单 */    public void showList() &#123;        /* 发送展示菜单的请求 */        Message message = new Message(Client.IP, Client.ServerIP, MessageType.SHOW_DISHES, userData);        Message receive = sendAndReceive(message);        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);            return;        &#125; else if (!receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(&quot;错误：请求被拒绝&quot;);            return;        &#125;        /* 此时拿到了菜单。该菜单的不同类别是由 ### 分割的。我们再将其分开 */        String[] dishes;        try &#123;            dishes = ((String) receive.getObject()).split(&quot;###&quot;);        &#125; catch (Exception e) &#123;            System.out.println(&quot;未知错误&quot;);            return;        &#125;        char in;        /* 这其实又是一级菜单了。直到选择 9 前，该菜单会一直循环 */        while (true) &#123;            System.out.println(&quot;---------------------------------------&quot;);            System.out.println(&quot;\t\t请选择要查看的类别&quot;);            System.out.println(&quot;\t\t1. 主  食&quot;);            System.out.println(&quot;\t\t2. 主  菜&quot;);            System.out.println(&quot;\t\t3. 凉  菜&quot;);            System.out.println(&quot;\t\t4. 汤  品&quot;);            System.out.println(&quot;\t\t5. 甜  点&quot;);            System.out.println(&quot;\t\t6. 饮  料&quot;);            System.out.println(&quot;\t\t7. 点  餐&quot;);            System.out.println(&quot;\t\t9. 返  回&quot;);            System.out.print(&quot;请输入：&quot;);            in = scanner.next().charAt(0);            System.out.println(&quot;---------------------------------------&quot;);            switch (in) &#123;                case &#39;1&#39;:                    System.out.println(&quot;------------主  食------------&quot;);                    System.out.println(&quot;ID\t名称  \t价格&quot;);                    System.out.println(dishes[0]);                    break;                case &#39;2&#39;:                    System.out.println(&quot;------------主  菜------------&quot;);                    System.out.println(&quot;ID\t名称  \t价格&quot;);                    System.out.println(dishes[1]);                    break;                case &#39;3&#39;:                    System.out.println(&quot;------------凉  菜------------&quot;);                    System.out.println(&quot;ID\t名称  \t价格&quot;);                    System.out.println(dishes[2]);                    break;                case &#39;4&#39;:                    System.out.println(&quot;------------汤  品------------&quot;);                    System.out.println(&quot;ID\t名称  \t价格&quot;);                    System.out.println(dishes[3]);                    break;                case &#39;5&#39;:                    System.out.println(&quot;------------甜  点------------&quot;);                    System.out.println(&quot;ID\t名称  \t价格&quot;);                    System.out.println(dishes[4]);                    break;                case &#39;6&#39;:                    System.out.println(&quot;------------饮  料------------&quot;);                    System.out.println(&quot;ID\t名称  \t价格&quot;);                    System.out.println(dishes[5]);                    break;                case &#39;7&#39;:                    /* 这时调用订餐的方法 */                    orderDishes();                    break;                case &#39;9&#39;:                    return;                default:                    System.out.println(&quot;输入错误&quot;);                    break;            &#125;        &#125;    &#125;        /* 订餐 */    public void orderDishes() &#123;        System.out.println(&quot;请输入菜品编号（数字，-1返回）：&quot;);        int dish;        try &#123;            dish = Integer.parseInt(scanner.next());        &#125; catch (Exception e) &#123;            System.out.println(&quot;输入错误&quot;);            return;        &#125;        if (dish &lt; 0) &#123;            return;        &#125;        /* 检查输入的餐品信息。这里把一部分代码封装成了一个新方法            ……这是因为测试发现，不这样做会导致内存数据不更新，接收到的返回包总是不变 */        String dishDetail = orderDishesPart1(dish);        if (dishDetail == null) &#123;            return;        &#125;        System.out.println(&quot;请输入数量（数字，-1返回）：&quot;);        int num;        try &#123;            num = Integer.parseInt(scanner.next());        &#125; catch (Exception e) &#123;            System.out.println(&quot;输入错误&quot;);            return;        &#125;        if (num &lt; 0) &#123;            return;        &#125;        System.out.println(&quot;请输入订餐桌号（数字，-1返回）：&quot;);        int table;        try &#123;            table = Integer.parseInt(scanner.next());        &#125; catch (Exception e) &#123;            System.out.println(&quot;输入错误&quot;);            return;        &#125;        if (table &lt; 0) &#123;            return;        &#125;        /* 检查一下餐桌信息。这里，正确的状态是&#39;已占用&#39; */        TableData tableData = checkTable(table, 6);        if (tableData == null) &#123;            return;        &#125;        /* 展示一下信息 */        System.out.println(&quot;ID\t名称  \t价格 \t数量\t桌号&quot;);        System.out.println(dishDetail + &quot;\t&quot; + num + &quot;\t&quot; + tableData.getId());        System.out.print(&quot;确定吗？（Y/N）：&quot;);        char confirm = scanner.next().charAt(0);        if (confirm != &#39;Y&#39; &amp;&amp; confirm != &#39;y&#39;) &#123;            return;        &#125;        /* 发送订餐请求 */        Message message = new Message(Client.IP, Client.ServerIP, MessageType.ORDER_DISHES, null);        message.setObject(userData + &quot;\t&quot; + dish + &quot;\t&quot; + num + &quot;\t&quot; + table + &quot;\t&quot; + tableData.getCustomer());        Message receive = sendAndReceive(message);        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);        &#125; else if (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(&quot;错误：请求被拒绝&quot;);        &#125; else if (receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(&quot;预定成功&quot;);        &#125;    &#125;        /* 订餐方法中，小部分代码封装成了这个方法 */    /* 如此做是因为测试发现，不这样做会导致内存数据不更新，        接收到的服务端返回包内容总是和方法中第一次接收的返回包内容一样。        测试过很多次，问题就是出在这里。解决方法就是这样。        这样，这个方法执行完毕后，似乎会刷新内存。可能这就是垃圾处理机制吧 */    public String orderDishesPart1(int dish) &#123;        Message message = new Message(Client.IP, Client.ServerIP, MessageType.CHECK_DISHES, userData + &quot;\t&quot; + dish);        Message receive1 = sendAndReceive(message);        if (receive1 == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);            return null;        &#125; else if (!receive1.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(&quot;错误：请求被拒绝&quot;);            return null;        &#125;        System.out.println(&quot;ID\t名称  \t价格&quot;);        String dishDetail = receive1.getObject().toString();        System.out.println(dishDetail);        return dishDetail;    &#125;    /* 展示账单列表 */    public void showBill() &#123;        /* 发送请求 */        Message message = new Message(Client.IP, Client.ServerIP, MessageType.SHOW_ALL_BILLS, userData);        Message receive = sendAndReceive(message);        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);            return;        &#125; else if (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(&quot;错误：请求被拒绝&quot;);            return;        &#125;        /* 同样的，账单列表也是以 ### 分隔的 */        String[] bills;        try &#123;            bills = ((String) receive.getObject()).split(&quot;###&quot;);        &#125; catch (Exception e) &#123;            System.out.println(&quot;错误：未知错误&quot;);            return;        &#125;        /* 另一个小菜单。选择 9 前会一直循环 */        while (true) &#123;            System.out.println(&quot;---------------------------------------&quot;);            System.out.println(&quot;\t\t请选择要查看的类别&quot;);            System.out.println(&quot;\t\t1. 已完成账单&quot;);            System.out.println(&quot;\t\t2. 未完成账单&quot;);            System.out.println(&quot;\t\t9. 返  回&quot;);            System.out.print(&quot;请输入：&quot;);            char in = scanner.next().charAt(0);            System.out.println(&quot;---------------------------------------&quot;);//            System.out.println(&quot;姓名 \t电话  \t桌号\t菜名   \t数量\t日期          \t结算状态&quot;);            switch (in) &#123;                case &#39;1&#39;:                    System.out.println(bills[0].length() == 0 ? &quot;---无---&quot; : bills[0]);                    break;                case &#39;2&#39;:                    System.out.println((bills.length &lt; 2 || bills[1].length() == 0) ? &quot;---无---&quot; : bills[1]);                    break;                case &#39;9&#39;:                    return;                default:                    System.out.println(&quot;输入错误&quot;);                    break;            &#125;        &#125;    &#125;        /* 按桌号检查账单 */    public String checkBillByTable(int table) &#123;        /* 发送请求            特别一提：后面的 &quot;\t&quot; + &#39;t&#39; + &quot;\t&quot; + table + &quot;\t&quot; + &quot;true&quot;             代表 按桌号查询(t)，号码是 table，展示未结账账单(true) */        Message message = new Message(Client.IP, Client.ServerIP, MessageType.CHECK_BILLS, userData + &quot;\t&quot; + &#39;t&#39; + &quot;\t&quot; + table + &quot;\t&quot; + &quot;true&quot;);        Message receive = sendAndReceive(message);        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);            return null;        &#125; else if (receive.getWord().equals(MessageType.ACCEPT)) &#123;            return receive.getObject().toString();        &#125; else if (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(&quot;错误：请求被拒绝&quot;);            return null;        &#125; else &#123;            System.out.println(&quot;错误：未知错误&quot;);            return null;        &#125;    &#125;        /* 结账 */    public void payBill() &#123;        showTables();        System.out.print(&quot;请输入结账的桌号（-1返回）：&quot;);        int table = 0;        try &#123;            table = Integer.parseInt(scanner.next());        &#125; catch (Exception e) &#123;            System.out.println(&quot;输入错误&quot;);        &#125;        if (table &lt; 0) &#123;            return;        &#125;        /* 检查一下桌号 */        TableData tableData = checkTable(table, 4);        if (tableData == null) &#123;            return;        &#125;        /* 检查并展示那个桌号的未结账单 */        String s = checkBillByTable(table);        if (s == null) &#123;            return;        &#125;        System.out.println(s);        System.out.println(&quot;请确认以上信息（Y/N）：&quot;);        char confirm = scanner.next().charAt(0);        if (confirm != &#39;Y&#39; &amp;&amp; confirm != &#39;y&#39;)&#123;            return;        &#125;        System.out.println(&quot;请输入结算方式（1现金；2支付宝；3微信；-1返回）：&quot;);        int way = -1;        try &#123;            way = Integer.parseInt(scanner.next());            if (way &lt; -1 || way &gt; 3)&#123;                throw new RuntimeException();            &#125;        &#125; catch (Exception e) &#123;            System.out.println(&quot;输入错误&quot;);        &#125;        if (way == -1) &#123;            return;        &#125;        /* 发送结账请求 */        Message message = new Message(Client.IP, Client.ServerIP, MessageType.FINISH_BILLS, userData + &quot;\t&quot; +  table + &quot;\t&quot; + way);        Message receive = sendAndReceive(message);        if (receive == null) &#123;            System.out.println(&quot;错误：服务器无响应&quot;);        &#125; else if (receive.getWord().equals(MessageType.REJECT)) &#123;            System.out.println(&quot;错误：请求被拒绝&quot;);        &#125; else if (receive.getWord().equals(MessageType.ACCEPT)) &#123;            System.out.println(&quot;结算成功&quot;);        &#125;    &#125;        /* 登出 */    public boolean logout() &#123;        System.out.print(&quot;确定登出吗？（Y/N）：&quot;);        char confirm;        try &#123;            confirm = scanner.next().charAt(0);            if (confirm != &#39;y&#39; &amp;&amp; confirm != &#39;Y&#39;)&#123;                return false;            &#125;            Message message = new Message(Client.IP, Client.ServerIP, MessageType.LOGOUT, userData);            client.getOos().writeObject(message);            return true;        &#125; catch (IOException e) &#123;            System.out.println(&quot;传输异常&quot;);            return true;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2024/02/04/mysql/mysql/"/>
      <url>/2024/02/04/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code class="article_number"></code> <code class="site_word_count"></code></p><p><code class="site_uv"></code> <code class="site_pv"></code></p><h1><span id="单表查询">单表查询</span></h1><h2><span id="1数据库-数据库管理系统-sql">1.数据库、数据库管理系统、SQL</span></h2><p><em><strong>什么是数据库？什么是数据库管理系统？什么是SQL？他们之间的关系是什么？</strong></em></p><blockquote><p>数据库：英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p></blockquote><blockquote><p>数据库管理系统：DataBaseManagement，简称DBMS。数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</p></blockquote><blockquote><p>常见的数据库管理系统：MySQL、Oracle、MS SqlServer、DB2、sybase等….</p></blockquote><blockquote><p>SQL：结构化查询语言程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。</p><p>SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。</p></blockquote><blockquote><p>三者之间的关系？<br>DBMS–执行–&gt; SQL –操作–&gt; DB</p></blockquote><p>学习的整个过程：</p><blockquote><p>先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS<br>对SQL语句进行执行，最终来完成数据库的数据管理。</p></blockquote><h2><span id="2-安装mysql数据库管理系统">2、安装MySQL数据库管理系统</span></h2><ol><li>先安装，选择“经典版”</li><li>需要进行MySQL数据库实例配置。</li></ol><p><strong>注意：一路下一步就行了！！！！！</strong></p><p>需要注意的事项？</p><p><strong>端口号</strong>：</p><blockquote><p>端口号port是任何一个软件&#x2F;应用都会有的，端口号是应用的唯一代表。端口号通常和IP地址在一块，IP地址用来定位计算机的，端口号port是用来定位计算机上某个服务的&#x2F;某个应用的！在同一台计算机上，端口号不能重复。具有唯一性。mysql数据库启动的时候，这个服务占有的&#x3D;&#x3D;默认端口号是3306&#x3D;&#x3D;。</p></blockquote><p><strong>字符编码方式</strong>：</p><blockquote><p>设置mysql数据库的字符编码方式为 UTF8，一定要注意：先选中第3个单选按钮，然后再选择utf8字符集。</p></blockquote><p><strong>服务名称</strong></p><blockquote><p>默认是：MySQL<br>不用改。</p></blockquote><p><strong>选择配置环境变量path</strong></p><p>如果没有选择怎么办？</p><p>可以手动配置<br>path&#x3D;其它路径;C:\Program Files (x86)\MySQL\MySQL Server 5.5\bin</p><ul><li><p>mysql超级管理员用户名不能改，一定是：root<br>  你需要设置mysql数据库超级管理员的密码。</p></li><li><p>设置密码的同时，可以激活root账户远程访问。<br>  激活：表示root账号可以在外地登录。<br>  不激活：表示root账号只能在本机上使用。</p></li></ul><h2><span id="3-mysql数据库的完美卸载">3、MySQL数据库的完美卸载！</span></h2><p>第一步：双击安装包进行卸载删除。<br>第二步：删除目录：<br>把C:\ProgramData下面的MySQL目录干掉。<br>把C:\Program Files (x86)下面的MySQL目录干掉。</p><p>这样就卸载结束了！</p><h2><span id="5-在windows中使用命令来启动和关闭mysql服务">5、在windows中使用命令来启动和关闭mysql服务</span></h2><p>语法：net stop 服务名称;net start 服务名称,其它服务的启停都可以采用以上的命令。</p><h2><span id="6-登录mysql">6、登录Mysql</span></h2><pre><code>使用bin目录下的mysql.exe命令来连接mysql数据库服务器本地登录（显示编写密码的形式）：    C:\Users\Administrator&gt;mysql -uroot -p123456    Welcome to the MySQL monitor.  Commands end with ; or \g.    Your MySQL connection id is 1    Server version: 5.5.36 MySQL Community Server (GPL)    Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.    Oracle is a registered trademark of Oracle Corporation and/or its    affiliates. Other names may be trademarks of their respective    owners.    Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.    mysql&gt;本地登录（隐藏密码的形式）：    C:\Users\Administrator&gt;mysql -uroot -p    Enter password: ******    Welcome to the MySQL monitor.  Commands end with ; or \g.    Your MySQL connection id is 2    Server version: 5.5.36 MySQL Community Server (GPL)    Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.    Oracle is a registered trademark of Oracle Corporation and/or its    affiliates. Other names may be trademarks of their respective    owners.    Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.    mysql&gt;</code></pre><h2><span id="7-mysql常用命令">7、mysql常用命令：</span></h2><h3><span id="71-退出mysql-exit">7.1 退出mysql ：exit</span></h3><pre><code class="mysql">mysql&gt; show databases;使用某个数据库use test;创建数据库create database bjpowernode;show tables;</code></pre><h3><span id="72-查看版本号">7.2 查看版本号</span></h3><p>select version();</p><h3><span id="73-查看当前数据库">7.3 查看当前数据库</span></h3><p>select database();</p><p>mysql是不见“;”不执行，“;”表示结束！</p><h3><span id="74-c用来终止一条命令的输入">7.4 \c用来终止一条命令的输入。</span></h3><h2><span id="8-数据库当中最基本的单元是表table">8、数据库当中最基本的单元是表：table</span></h2><p>什么是表table？为什么用表来存储数据呢？</p><table><thead><tr><th>姓名</th><th>性别</th><th>年龄(列：字段)</th><th></th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>20</td><td>——-&gt;行（记录）</td></tr><tr><td>李四</td><td>女</td><td>20</td><td>——-&gt;行（记录）</td></tr><tr><td>王五</td><td>男</td><td>22</td><td>——-&gt;行（记录）</td></tr></tbody></table><p>数据库当中是以表格的形式表示数据的。因为表比较直观。</p><p>任何一张表都有行和列：</p><blockquote><p>行（row）：被称为数据&#x2F;记录。</p></blockquote><blockquote><p>列（column）：被称为字段。</p></blockquote><p>每一个字段都有：字段名、数据类型、约束等属性。</p><blockquote><p>字段名可以理解，是一个普通的名字，见名知意就行。<br>数据类型：字符串，数字，日期等<br>约束：约束也有很多，其中一个叫做唯一性约束，这种约束添加之后，该字段中的数据不能重复。</p></blockquote><h2><span id="9-关于sql语句的分类">9、关于SQL语句的分类？</span></h2><p>SQL语句有很多，最好进行分门别类，这样更容易记忆。<br>    分为：</p><ul><li><p><strong>DQL：数据查询语言</strong>（凡是带有select关键字的都是查询语句）</p><pre><code class="sql">select...</code></pre></li><li><p><strong>DML：数据操作语言</strong>（凡是对表当中的数据进行增删改的都是DML）</p><pre><code class="sql">insert delete updateinsert 增delete 删update 改</code></pre><p>  这个主要是操作表中的数据data。</p></li><li><p><strong>DDL数据定义语言</strong>(凡是带有create、drop、alter的都是DDL)</p><blockquote><p>DDL主要操作的是表的结构。不是表中的数据。</p></blockquote><pre><code class="sql">create：新建，等同于增drop：删除alter：修改</code></pre><p>  这个增删改和DML不同，这个主要是对表结构进行操作。</p></li><li><p><strong>TCL事务控制语言</strong><br>  不是王牌电视。是包括：</p><pre><code class="sql">commit;事务提交：rollback;事务回滚：</code></pre></li><li><p><strong>DCL数据控制语言</strong></p><pre><code>授权grant、撤销权限revoke....</code></pre></li></ul><h2><span id="10-通过cmd导入sql文件数据">10、通过cmd导入sql文件数据：</span></h2><p>bjpowernode.sql 这个文件中是我提前为大家练习准备的数据库表。<br>怎么将sql文件中的数据导入呢？<br><code>mysql&gt; source D:\course\03-MySQL\document\bjpowernode.sql</code></p><p>&#x3D;&#x3D;注意：路径中不要有中文！！！！&#x3D;&#x3D;</p><h2><span id="12-看表的结构">12、看表的结构</span></h2><p>desc 表名;</p><h2><span id="13-简单查询">13、简单查询</span></h2><h3><span id="131-查询一个字段">13.1、查询一个字段？</span></h3><p>select 字段名 from 表名;<br>其中要注意：</p><blockquote><p>select和from都是<strong>关键字</strong>。<br>字段名和表名都是<strong>标识符。</strong></p></blockquote><h3><span id="132-查询所有字段">13.2 查询所有字段</span></h3><p>第一种方式：可以把每个字段都写上<br>        select a,b,c,d,e,f… from tablename;</p><p>第二种方式：可以使用*<br>select * from dept;</p><p>这种方式的缺点：</p><p>1、效率低<br>2、可读性差。<br>在实际开发中不建议。<br>你可以在DOS命令窗口中想快速的看一看全表数据可以采用这种方式。</p><h3><span id="133-x3dx3d给查询的列起别名x3dx3d">13.3、&#x3D;&#x3D;给查询的列起别名&#x3D;&#x3D;？</span></h3><p><code>mysql&gt; select deptno,dname as deptname from dept;</code></p><p><strong>假设起别名的时候，别名里面有空格，怎么办？</strong><br>mysql&gt; select deptno,dname dept name from dept;<br>&#x3D;&#x3D;DBMS看到这样的语句，进行SQL语句的编译，不符合语法，编译报错。&#x3D;&#x3D;<br>怎么解决？<br><code>select deptno,dname &#39;dept name&#39; from dept; </code>&#x2F;&#x2F;<strong>加单引号</strong><br><code>select deptno,dname &quot;dept name&quot; from dept; </code>&#x2F;&#x2F;<strong>加双引号</strong></p><p><strong>注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准，双引号在oracle数据库中用不了。但是在mysql中可以使用。</strong></p><h2><span id="14-条件查询">14、条件查询</span></h2><h3><span id="141-什么是条件查询">14.1、什么是条件查询？</span></h3><pre><code class="sql">语法格式：select    字段1,字段2,字段3....from     表名where    条件;</code></pre><h3><span id="142-都有哪些条件">14.2、都有哪些条件？</span></h3><h4><span id="等于"><strong><code>= 等于</code></strong></span></h4><p>查询薪资等于800的员工姓名和编号？<br>    select empno,ename from emp where sal &#x3D; 800;<br>查询SMITH的编号和薪资？<br>    select empno,sal from emp where ename &#x3D; ‘SMITH’; &#x2F;&#x2F;字符串使用单引号</p><h4><span id="ltgt或x3d-不等于">&lt;&gt;或!&#x3D; 不等于</span></h4><p>查询薪资不等于800的员工姓名和编号？<br><code>select empno,ename from emp where sal != 800;</code><br><code>select empno,ename from emp where sal &lt;&gt; 800; </code>&#x2F;&#x2F; 小于号和大于号组成的不等号</p><h4><span id="lt-小于">&lt; 小于</span></h4><p>查询薪资小于2000的员工姓名和编号？<br><code>select empno,ename,sal from emp where sal &lt; 2000;</code></p><h4><span id="ltx3d-小于等于">&lt;&#x3D; 小于等于</span></h4><p>查询薪资小于等于3000的员工姓名和编号？<br><code>select empno,ename,sal from emp where sal &lt;= 3000;</code></p><h4><span id="大于">大于</span></h4><p>查询薪资大于3000的员工姓名和编号？<br>select empno,ename,sal from emp where sal &gt; 3000;</p><h4><span id="大于等于">大于等于</span></h4><p>查询薪资大于等于3000的员工姓名和编号？<br>select empno,ename,sal from emp where sal &gt;&#x3D; 3000;</p><pre><code class="sql">select     empno,ename,sal from     emp where     sal between 2450 and 3000;</code></pre><p><strong>注意：&#x3D;&#x3D;使用between and的时候，必须遵循左小右大。&#x3D;&#x3D;between and是闭区间，包括两端的值。</strong></p><p>is null 为 null（is not null 不为空）<br>查询哪些员工的津贴&#x2F;补助为null？<br>mysql&gt; select empno,ename,sal,comm from emp where comm &#x3D; null;</p><pre><code>mysql&gt; select empno,ename,sal,comm from emp where comm is null;</code></pre><p><strong>注意：在数据库当中null不能使用等号进行衡量。需要使用is null因为数据库中的null代表什么也没有，它不是一个值，所以不能使用等号衡量。</strong></p><p>查询哪些员工的津贴&#x2F;补助不为null？<br>    select empno,ename,sal,comm from emp where comm is not null;</p><h4><span id="and-并且">and 并且</span></h4><p>查询工作岗位是MANAGER并且工资大于2500的员工信息？</p><pre><code class="sql">select     empno,ename,job,sal from     emp where     job = &#39;MANAGER&#39; and sal &gt; 2500;</code></pre><h4><span id="or-或者">or 或者</span></h4><p>查询工作岗位是MANAGER和SALESMAN的员工？<br>select empno,ename,job from emp where job &#x3D; ‘MANAGER’;<br>select empno,ename,job from emp where job &#x3D; ‘SALESMAN’;</p><pre><code class="sql">select     empno,ename,jobfrom    empwhere     job = &#39;MANAGER&#39; or job = &#39;SALESMAN&#39;;</code></pre><h4><span id="and和or同时出现的话有优先级问题吗">and和or同时出现的话，有优先级问题吗？</span></h4><p>查询工资大于2500，并且部门编号为10或20部门的员工？</p><pre><code class="sql">select     *from    empwhere    sal &gt; 2500 and deptno = 10 or deptno = 20;</code></pre><p>分析以上语句的问题？</p><blockquote><p>&#x3D;&#x3D;and优先级比or高。&#x3D;&#x3D;<br>以上语句会先执行and，然后执行or。</p></blockquote><p>以上这个语句表示什么含义？</p><blockquote><p>找出工资大于2500并且部门编号为10的员工，或者20部门所有员工找出来。</p></blockquote><pre><code class="sql">select     *from    empwhere    sal &gt; 2500 and (deptno = 10 or deptno = 20);</code></pre><p>and和or同时出现，and优先级较高。如果想让or先执行，&#x3D;&#x3D;需要加“小括号”&#x3D;&#x3D;<br>以后在开发中，<strong>如果不确定优先级，就加小括号就行了。</strong></p><p>&#x3D;&#x3D;in 包含，相当于多个 or （not in 不在这个范围中）&#x3D;&#x3D;</p><p>查询工作岗位是MANAGER和SALESMAN的员工？<br>select empno,ename,job from emp where job &#x3D; ‘MANAGER’ or job &#x3D; ‘SALESMAN’;<br>select empno,ename,job from emp where job in(‘MANAGER’, ‘SALESMAN’);<br><strong>注意：in不是一个区间。in后面跟的是具体的值。</strong></p><p><strong>not in 表示不在这几个值当中的数据。</strong><br><code>select ename,sal from emp where sal not in(800, 5000, 3000);</code></p><p>not 可以取非，主要用在 is 或 in 中</p><pre><code class="sql">is nullis not nullinnot in</code></pre><h4><span id="模糊查询like">模糊查询like</span></h4><blockquote><p>支持%或下划线匹配</p></blockquote><blockquote><p>%匹配任意多个字符<br>下划线：任意一个字符。<br>%是一个特殊的符号，_ 也是一个特殊符号）</p></blockquote><pre><code class="sql">找出名字中含有O的？select ename from emp where ename like &#39;%O%&#39;;找出名字以T结尾的？select ename from emp where ename like &#39;%T&#39;;找出名字以K开始的？select ename from emp where ename like &#39;K%&#39;;找出第二个字每是A的？select ename from emp where ename like &#39;_A%&#39;;找出第三个字母是R的？select ename from emp where ename like &#39;__R%&#39;;找出名字中有“_”的？select name from t_student where name like &#39;%_%&#39;; //这样不行。select name from t_student where name like &#39;%\_%&#39;; // \转义字符。</code></pre><h2><span id="15-排序">15、排序</span></h2><h3><span id="151-查询所有员工薪资排序">15.1、查询所有员工薪资，排序？</span></h3><pre><code class="sql">select     ename,salfrom    emporder by    sal;</code></pre><p> &#x3D;&#x3D;默认是升序！！！&#x3D;&#x3D;</p><h3><span id="152-怎么降序">15.2、怎么降序？</span></h3><pre><code class="sql">指定降序：select ename,salfromemporder bysal desc;</code></pre><pre><code class="sql">指定升序？select ename,salfromemporder bysal asc;</code></pre><h3><span id="153-多个字段排序">15.3、多个字段排序</span></h3><p>查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。<br><code>select ename,salfromemporder bysal asc, ename asc;</code></p><p> sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。</p><h3><span id="154-了解根据字段的位置也可以排序">15.4、了解：根据字段的位置也可以排序</span></h3><pre><code class="sql">select ename,sal from emp order by 2; // 2表示第二列。第二列是sal按照查询结果的第2列sal排序。了解一下，不建议在开发中这样写，因为不健壮。因为列的顺序很容易发生改变，列顺序修改之后，2就废了。</code></pre><h2><span id="x3dx3d16-语句执行顺序x3dx3d">&#x3D;&#x3D;16、语句执行顺序&#x3D;&#x3D;</span></h2><p>关键字顺序不能变：</p><pre><code class="sql">select    ...from    ...where    ...order by    ...</code></pre><p>&#x3D;&#x3D;以上语句的执行顺序必须掌握：&#x3D;&#x3D;<br>    第一步：from<br>    第二步：where<br>    第三步：select<br>    第四步：order by（<strong>排序总是在最后执行！</strong>）</p><h2><span id="17-数据处理函数">17、数据处理函数</span></h2><h3><span id="171-数据处理函数又被称为单行处理函数">17.1、数据处理函数又被称为单行处理函数</span></h3><blockquote><p>单行处理函数的特点：一个输入对应一个输出。<br>和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）</p></blockquote><h3><span id="172-单行处理函数常见的有哪些">17.2、单行处理函数常见的有哪些？</span></h3><h4><span id="lower-转换小写">lower 转换小写</span></h4><p>select lower(ename) as ename from emp;</p><h4><span id="upper-转换大写">upper 转换大写</span></h4><p>select upper(name) as name from t_student;</p><h4><span id="substr-取子串">substr 取子串</span></h4><p>语法：substr( 被截取的字符串, 起始下标,截取的长度）</p><p>select substr(ename, 1, 1) as ename from emp;<br>&#x3D;&#x3D;注意：起始下标从1开始，没有0.&#x3D;&#x3D;<br>找出员工名字第一个字母是A的员工信息？</p><pre><code>第一种方式：模糊查询select ename from emp where ename like &#39;A%&#39;;第二种方式：substr函数elect     ename from     emp where     substr(ename,1,1) = &#39;A&#39;;</code></pre><h4><span id="首字母大写">首字母大写</span></h4><pre><code class="sql">select name from t_student;select upper(substr(name,1,1)) from t_student;select substr(name,2,length(name) - 1) from t_student;select concat(upper(substr(name,1,1)),substr(name,2,length(name) - 1)) as result from t_student;+----------+| result   |+----------+| Zhangsan || Lisi     || Wangwu   || Jack_son |+----------+</code></pre><h4><span id="concat函数进行字符串的拼接">concat函数进行字符串的拼接</span></h4><p>select concat(empno,ename) from emp;</p><h4><span id="length-取长度">length 取长度</span></h4><p>select length(ename) enamelength from emp;</p><h4><span id="trim-去前后空格">trim 去前后空格</span></h4><p>select * from emp where ename &#x3D; trim(‘   KING’);</p><h4><span id="str_to_date-将字符串转换成日期">str_to_date 将字符串转换成日期</span></h4><h4><span id="date_format-格式化日期">date_format 格式化日期</span></h4><h4><span id="format-设置千分位">format 设置千分位</span></h4><h4><span id="x3dx3dcasewhenthenwhenthenelseendx3dx3d">&#x3D;&#x3D;case..when..then..when..then..else..end&#x3D;&#x3D;</span></h4><p>当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%,其它正常。<br>（注意：不修改数据库，只是将查询结果显示为工资上调）</p><pre><code class="sql">select     ename,    job,     sal as oldsal,(case job when &#39;MANAGER&#39; then `sal*1.1 `when &#39;SALESMAN&#39; then sal*1.5 else sal end) as newsal from     emp;</code></pre><h4><span id="x3dx3dround-四舍五入x3dx3d">&#x3D;&#x3D;round 四舍五入&#x3D;&#x3D;</span></h4><pre><code>    select 字段 from 表名;    select ename from emp;    select &#39;abc&#39; from emp; // select后面直接跟“字面量/字面值”</code></pre><h5><span id="x3dx3d根据字面量查询x3dx3d">&#x3D;&#x3D;根据字面量查询&#x3D;&#x3D;</span></h5><p>select ‘abc’ as bieming from emp;</p><pre><code class="sql">    +---------+    | bieming |    +---------+    | abc     |    | abc     |select abc from emp;    ERROR 1054 (42S22): Unknown column &#39;abc&#39; in &#39;field list&#39;    这样肯定报错，因为会把abc当做一个字段的名字，去emp表中找abc字段去了。</code></pre><p>select 1000 as num from emp; &#x2F;&#x2F; 1000 也是被当做一个字面量&#x2F;字面值。</p><pre><code>    +------+    | num  |    +------+    | 1000 |    | 1000 |    | 1000 |    | 1000 |</code></pre><p>​&#x3D;&#x3D;结论：select后面可以跟某个表的字段名（可以等同看做变量名），也可以跟字面量&#x2F;字面值（数据）。&#x3D;&#x3D;</p><pre><code>    select 21000 as num from dept;    +-------+    | num   |    +-------+    | 21000 |    | 21000 |    | 21000 |    | 21000 |    +-------+    mysql&gt; select round(1236.567, 0) as result from emp; //保留整数位。    +--------+    | result |    +--------+    |   1237 |    |   1237 |    |   1237 |    |   1237 |    |   1237 |    |   1237 |</code></pre><p>select round(1236.567, 1) as result from emp; &#x2F;&#x2F;保留1个小数<br>select round(1236.567, 2) as result from emp; &#x2F;&#x2F;保留2个小数<br>select round(1236.567, -1) as result from emp; &#x2F;&#x2F; 保留到十位。<br>    +——–+<br>    | result |<br>    +——–+<br>    |   1240 |<br>    |   1240 |</p><p>select round(1236.567, -2) as result from emp;<br>    +——–+<br>    | result |<br>    +——–+<br>    |   1200 |<br>    |   1200 |</p><h5><span id="rand-生成随机数">rand() 生成随机数</span></h5><p>​mysql&gt; select round(rand()*100,0) from emp; &#x2F;&#x2F; 100以内的随机数<br>​+———————+<br>​| round(rand()*100,0) |<br>​+———————+<br>​|                  76 |<br>​|                  29 |<br>​|                  15 |<br>​|                  88 |<br>​|                  95 |<br>​|                   9 |<br>​</p><h4><span id="x3dx3difnull-可以将-null-转换成一个具体值x3dx3d">&#x3D;&#x3D;ifnull 可以将 null 转换成一个具体值&#x3D;&#x3D;</span></h4><p>ifnull是空处理函数。专门处理空的。<br>&#x3D;&#x3D;在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。&#x3D;&#x3D;</p><p>案例：</p><pre><code>计算每个员工的年薪？年薪 = (月薪 + 月补助) * 12select ename, (sal + comm) * 12 as yearsal from emp;+--------+----------+| ename  | yearsal  |+--------+----------+| SMITH  |     NULL || ALLEN  | 22800.00 || WARD   | 21000.00 || JONES  |     NULL || MARTIN | 31800.00 || BLAKE  |     NULL || CLARK  |     NULL || SCOTT  |     NULL || KING   |     NULL || TURNER | 18000.00 || ADAMS  |     NULL || JAMES  |     NULL || FORD   |     NULL || MILLER |     NULL |+--------+----------+</code></pre><p>&#x3D;&#x3D;注意：NULL只要参与运算，最终结果一定是NULL。为了避免这个现象，需要使用ifnull函数。&#x3D;&#x3D;<br>ifnull函数用法：ifnull(数据, 被当做哪个值)<br>如果“数据”为NULL的时候，把这个数据结构当做哪个值。</p><p>补助为NULL的时候，将补助当做0</p><pre><code class="sql">select ename, (sal + ifnull(comm, 0)) * 12 as yearsal from emp;+--------+----------+| ename  | yearsal  |+--------+----------+| SMITH  |  9600.00 || ALLEN  | 22800.00 || WARD   | 21000.00 || JONES  | 35700.00 || MARTIN | 31800.00 || BLAKE  | 34200.00 || CLARK  | 29400.00 || SCOTT  | 36000.00 || KING   | 60000.00 || TURNER | 18000.00 || ADAMS  | 13200.00 || JAMES  | 11400.00 || FORD   | 36000.00 || MILLER | 15600.00 |+--------+----------+</code></pre><h2><span id="18-分组函数多行处理函数">18、分组函数（多行处理函数）</span></h2><blockquote><p>多行处理函数的特点：输入多行，最终输出一行。</p></blockquote><ul><li><code>count</code>计数</li><li><code>sum</code>求和</li><li><code>avg</code>平均值</li><li><code>max</code>最大值</li><li><code>min</code>最小值</li></ul><blockquote><p><strong>注意：分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。</strong></p></blockquote><pre><code>计算工资和：    mysql&gt; select sum(sal) from emp;    +----------+    | sum(sal) |    +----------+    | 29025.00 |    +----------+计算平均工资：    mysql&gt; select avg(sal) from emp;    +-------------+    | avg(sal)    |    +-------------+    | 2073.214286 |    +-------------+    14个工资全部加起来，然后除以14。计算员工数量？    mysql&gt; select count(ename) from emp;    +--------------+    | count(ename) |    +--------------+    |           14 |    +--------------+</code></pre><p>​</p><p>&#x3D;&#x3D;分组函数在使用的时候需要注意哪些？&#x3D;&#x3D;</p><ol><li>分组函数&#x3D;&#x3D;自动忽略NULL&#x3D;&#x3D;，你不需要提前对NULL进行处理。</li><li>分组函数中count(*)和count(具体字段)有什么区别？</li></ol><pre><code>mysql&gt; select count(*) from emp;+----------+| count(*) |+----------+|       14 |+----------+mysql&gt; select count(comm) from emp;+-------------+| count(comm) |+-------------+|           4 |+-------------+</code></pre><p><strong>count(具体字段)：表示统计该字段下所有不为NULL的元素的总数</strong>。<br><strong>count(*)：统计表当中的总行数。</strong>（只要有一行数据count则++）<br><strong>因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。</strong></p><ol start="3"><li><p>&#x3D;&#x3D;分组函数不能够直接使用在where子句中。&#x3D;&#x3D;</p></li><li><p>所有的分组函数可以组合起来一起用。</p></li></ol><pre><code class="sql">select sum(sal),min(sal),max(sal),avg(sal),count(*) from emp;+----------+----------+----------+-------------+----------+| sum(sal) | min(sal) | max(sal) | avg(sal)    | count(*) |+----------+----------+----------+-------------+----------+| 29025.00 |   800.00 |  5000.00 | 2073.214286 |       14 |+----------+----------+----------+-------------+----------+</code></pre><h2><span id="x3dx3d19-分组查询非常重要五颗星x3dx3d">&#x3D;&#x3D;19、分组查询（非常重要：五颗星）&#x3D;&#x3D;</span></h2><p>19.2、将之前的关键字全部组合在一起，来看一下他们的执行顺序？</p><pre><code>select    ...from    ...where    ...group by    ...order by    ...</code></pre><p>以上关键字的顺序不能颠倒，需要记忆。<br>执行顺序是什么？<br>    1. from<br>    2. where<br>    3. group by<br>    4. select<br>    5. order by</p><p><strong>为什么分组函数不能直接使用在where后面？</strong></p><p>select ename,sal from emp where sal &gt; min(sal);&#x2F;&#x2F;报错。<br>因为分组函数在使用的时候必须先分组之后才能使用。<br>where执行的时候，还没有分组。所以where后面不能出现分组函数。</p><p>select sum(sal) from emp;<br>这个没有分组，为啥sum()函数可以用呢？<br>因为select在group by之后执行。</p><pre><code>select ename,job,sum(sal) from emp group by job;+-------+-----------+----------+| ename | job       | sum(sal) |+-------+-----------+----------+| SCOTT | ANALYST   |  6000.00 || SMITH | CLERK     |  4150.00 || JONES | MANAGER   |  8275.00 || KING  | PRESIDENT |  5000.00 || ALLEN | SALESMAN  |  5600.00 |+-------+-----------+----------+</code></pre><blockquote><p>以上语句在mysql中可以执行，但是毫无意义。<br>以上语句在oracle中执行报错。<br>oracle的语法比mysql的语法严格。（mysql的语法相对来说松散一些！）</p><p>&#x3D;&#x3D;重点结论：在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。&#x3D;&#x3D;</p></blockquote><p>找出“每个部门，不同工作岗位”的最高薪资？</p><pre><code>+--------+-----------+---------+--------+| ename  | job       | sal     | deptno |+--------+-----------+---------+--------+| MILLER | CLERK     | 1300.00 |     10 || KING   | PRESIDENT | 5000.00 |     10 || CLARK  | MANAGER   | 2450.00 |     10 || FORD   | ANALYST   | 3000.00 |     20 || ADAMS  | CLERK     | 1100.00 |     20 || SCOTT  | ANALYST   | 3000.00 |     20 || JONES  | MANAGER   | 2975.00 |     20 || SMITH  | CLERK     |  800.00 |     20 || BLAKE  | MANAGER   | 2850.00 |     30 || MARTIN | SALESMAN  | 1250.00 |     30 || ALLEN  | SALESMAN  | 1600.00 |     30 || TURNER | SALESMAN  | 1500.00 |     30 || WARD   | SALESMAN  | 1250.00 |     30 || JAMES  | CLERK     |  950.00 |     30 |+--------+-----------+---------+--------+技巧：两个字段联合成1个字段看。（两个字段联合分组）select     deptno, job, max(sal)from    empgroup by    deptno, job;+--------+-----------+----------+| deptno | job       | max(sal) |+--------+-----------+----------+|     10 | CLERK     |  1300.00 ||     10 | MANAGER   |  2450.00 ||     10 | PRESIDENT |  5000.00 ||     20 | ANALYST   |  3000.00 ||     20 | CLERK     |  1100.00 ||     20 | MANAGER   |  2975.00 ||     30 | CLERK     |   950.00 ||     30 | MANAGER   |  2850.00 ||     30 | SALESMAN  |  1600.00 |+--------+-----------+----------+</code></pre><p>​</p><h3><span id="having">having</span></h3><ul><li>having可以对分完组之后的数据进一步过滤。</li><li>having不能单独使用，having不能代替where，&#x3D;&#x3D;having必须和group by联合使用。&#x3D;&#x3D;</li></ul><p>找出每个部门最高薪资，要求显示最高薪资大于3000的？</p><pre><code class="sql">select     deptno,max(sal) from     emp group by     deptnohaving    max(sal) &gt; 3000;+--------+----------+| deptno | max(sal) |+--------+----------+|     10 |  5000.00 |+--------+----------+</code></pre><p>思考一个问题：以上的sql语句执行效率是不是低？</p><blockquote><p>比较低，实际上可以这样考虑：先将大于3000的都找出来，然后再分组。</p></blockquote><pre><code>select     deptno,max(sal)from    empwhere    sal &gt; 3000group by    deptno;+--------+----------+| deptno | max(sal) |+--------+----------+|     10 |  5000.00 |+--------+----------+</code></pre><p>&#x3D;&#x3D;优化策略：where和having，优先选择where，where实在完成不了了，再选择having。&#x3D;&#x3D;</p><p><em><strong>where没办法的？？？？</strong></em></p><blockquote><p>找出每个部门平均薪资，要求显示平均薪资高于2500的。</p></blockquote><p>第一步：找出每个部门平均薪资</p><pre><code class="sql">select deptno,avg(sal) from emp group by deptno;+--------+-------------+| deptno | avg(sal)    |+--------+-------------+|     10 | 2916.666667 ||     20 | 2175.000000 ||     30 | 1566.666667 |+--------+-------------+</code></pre><p>第二步：要求显示平均薪资高于2500的</p><pre><code class="sql">select     deptno,avg(sal) from     emp group by     deptnohaving    avg(sal) &gt; 2500;+--------+-------------+| deptno | avg(sal)    |+--------+-------------+|     10 | 2916.666667 |+--------+-------------+</code></pre><h2><span id="x3dx3d20-大总结单表的查询学完了x3dx3d">&#x3D;&#x3D;20、大总结（单表的查询学完了）&#x3D;&#x3D;</span></h2><pre><code>select     ...from    ...where    ...group by    ...having    ...order by    ...</code></pre><p>&#x3D;&#x3D;以上关键字只能按照这个顺序来，不能颠倒。&#x3D;&#x3D;</p><p><em><strong>执行顺序？</strong></em></p><ol><li>from</li><li>where</li><li>group by</li><li>having</li><li>select</li><li>order by</li></ol><blockquote><p>从某张表中查询数据，<br>先经过where条件筛选出有价值的数据。<br>对这些有价值的数据进行分组。<br>分组之后可以使用having继续筛选。<br>select查询出来。<br>最后排序输出！</p></blockquote><p>找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，<br>要求按照平均薪资降序排。</p><pre><code class="sql">select     job, avg(sal) as avgsalfrom    empwhere    job &lt;&gt; &#39;MANAGER&#39;group by    jobhaving    avg(sal) &gt; 1500order by    avgsal desc;+-----------+-------------+| job       | avgsal      |+-----------+-------------+| PRESIDENT | 5000.000000 || ANALYST   | 3000.000000 |+-----------+-------------+</code></pre><h1><span id="多表查询">多表查询</span></h1><h2><span id="1-把查询结果去除重复记录distinct">1、把查询结果去除重复记录【distinct】</span></h2><pre><code>注意：原表数据不会被修改，只是查询结果去重。去重需要使用一个关键字：distinctmysql&gt; select distinct job from emp;+-----------+| job       |+-----------+| CLERK     || SALESMAN  || MANAGER   || ANALYST   || PRESIDENT |+-----------+// 这样编写是错误的，语法错误。// distinct只能出现在所有字段的最前方。mysql&gt; select ename,distinct job from emp;// distinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。mysql&gt; select distinct job,deptno from emp;+-----------+--------+| job       | deptno |+-----------+--------+| CLERK     |     20 || SALESMAN  |     30 || MANAGER   |     20 || MANAGER   |     30 || MANAGER   |     10 || ANALYST   |     20 || PRESIDENT |     10 || CLERK     |     30 || CLERK     |     10 |+-----------+--------+统计一下工作岗位的数量？    select count(distinct job) from emp;    +---------------------+    | count(distinct job) |    +---------------------+    |                   5 |    +---------------------+</code></pre><h2><span id="2-连接查询">2、连接查询</span></h2><h3><span id="21-什么是连接查询">2.1、什么是连接查询？</span></h3><pre><code>从一张表中单独查询，称为单表查询。emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，被称为连接查询。</code></pre><h3><span id="22-连接查询的分类">2.2、连接查询的分类？</span></h3><pre><code>根据语法的年代分类：    SQL92：1992年的时候出现的语法    SQL99：1999年的时候出现的语法    我们这里重点学习SQL99.(这个过程中简单演示一个SQL92的例子)根据表连接的方式分类：    内连接：        等值连接        非等值连接        自连接    外连接：        左外连接（左连接）        右外连接（右连接）    全连接（不讲）</code></pre><h3><span id="23-当两张表进行连接查询时没有任何条件的限制会发生什么现象">2.3、当两张表进行连接查询时，没有任何条件的限制会发生什么现象？</span></h3><pre><code>案例：查询每个员工所在部门名称？    mysql&gt; select ename,deptno from emp;    +--------+--------+    | ename  | deptno |    +--------+--------+    | SMITH  |     20 |    | ALLEN  |     30 |    | WARD   |     30 |    | JONES  |     20 |    | MARTIN |     30 |    | BLAKE  |     30 |    | CLARK  |     10 |    | SCOTT  |     20 |    | KING   |     10 |    | TURNER |     30 |    | ADAMS  |     20 |    | JAMES  |     30 |    | FORD   |     20 |    | MILLER |     10 |    +--------+--------+    mysql&gt; select * from dept;    +--------+------------+----------+    | DEPTNO | DNAME      | LOC      |    +--------+------------+----------+    |     10 | ACCOUNTING | NEW YORK |    |     20 | RESEARCH   | DALLAS   |    |     30 | SALES      | CHICAGO  |    |     40 | OPERATIONS | BOSTON   |    +--------+------------+----------+    两张表连接没有任何条件限制：    select ename,dname from emp, dept;    +--------+------------+    | ename  | dname      |    +--------+------------+    | SMITH  | ACCOUNTING |    | SMITH  | RESEARCH   |    | SMITH  | SALES      |    | SMITH  | OPERATIONS |    | ALLEN  | ACCOUNTING |    | ALLEN  | RESEARCH   |    | ALLEN  | SALES      |    | ALLEN  | OPERATIONS |    ...    56 rows in set (0.00 sec)    14 * 4 = 56    当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是    两张表条数的乘积，这种现象被称为：笛卡尔积现象。（笛卡尔发现的，这是    一个数学现象。）</code></pre><h3><span id="24-怎么避免笛卡尔积现象">2.4、怎么避免笛卡尔积现象？</span></h3><pre><code>连接时加条件，满足这个条件的记录被筛选出来！select     ename,dname from     emp, deptwhere    emp.deptno = dept.deptno;select     emp.ename,dept.dname from     emp, deptwhere    emp.deptno = dept.deptno;// 表起别名。很重要。效率问题。select     e.ename,d.dname from     emp e, dept dwhere    e.deptno = d.deptno; //SQL92语法。+--------+------------+| ename  | dname      |+--------+------------+| CLARK  | ACCOUNTING || KING   | ACCOUNTING || MILLER | ACCOUNTING || SMITH  | RESEARCH   || JONES  | RESEARCH   || SCOTT  | RESEARCH   || ADAMS  | RESEARCH   || FORD   | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || MARTIN | SALES      || BLAKE  | SALES      || TURNER | SALES      || JAMES  | SALES      |+--------+------------+思考：最终查询的结果条数是14条，但是匹配的过程中，匹配的次数减少了吗？    还是56次，只不过进行了四选一。次数没有减少。注意：通过笛卡尔积现象得出，表的连接次数越多效率越低，尽量避免表的连接次数。</code></pre><h3><span id="25-内连接之等值连接">2.5、内连接之等值连接。</span></h3><p>案例：查询每个员工所在部门名称，显示员工名和部门名？<br>emp e和dept d表进行连接。条件是：e.deptno &#x3D; d.deptno</p><p>SQL92语法：<br>    select<br>        e.ename,d.dname<br>    from<br>        emp e, dept d<br>    where<br>        e.deptno &#x3D; d.deptno;</p><pre><code>sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。</code></pre><p>SQL99语法：<br>    select<br>        e.ename,d.dname<br>    from<br>        emp e<br>    join<br>        dept d<br>    on<br>        e.deptno &#x3D; d.deptno;</p><pre><code>//inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）select     e.ename,d.dnamefrom    emp einner join    dept don    e.deptno = d.deptno; // 条件是等量关系，所以被称为等值连接。</code></pre><p>​sql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where<br>​<br>​SQL99语法：<br>​select<br>​…<br>​from<br>​a<br>​join<br>​b<br>​on<br>​a和b的连接条件<br>​where<br>​筛选条件</p><h3><span id="26-内连接之非等值连接">2.6、内连接之非等值连接</span></h3><p>案例：找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？<br>mysql&gt; select * from emp; e<br>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>….</p><p>mysql&gt; select * from salgrade; s<br>+——-+——-+——-+<br>| GRADE | LOSAL | HISAL |<br>+——-+——-+——-+<br>|     1 |   700 |  1200 |<br>|     2 |  1201 |  1400 |<br>|     3 |  1401 |  2000 |<br>|     4 |  2001 |  3000 |<br>|     5 |  3001 |  9999 |<br>+——-+——-+——-+</p><p>select<br>    e.ename, e.sal, s.grade<br>from<br>    emp e<br>join<br>    salgrade s<br>on<br>    e.sal between s.losal and s.hisal; &#x2F;&#x2F; 条件不是一个等量关系，称为非等值连接。</p><p>select<br>    e.ename, e.sal, s.grade<br>from<br>    emp e<br>inner join<br>    salgrade s<br>on<br>    e.sal between s.losal and s.hisal;</p><p>+——–+———+——-+<br>| ename  | sal     | grade |<br>+——–+———+——-+<br>| SMITH  |  800.00 |     1 |<br>| ALLEN  | 1600.00 |     3 |<br>| WARD   | 1250.00 |     2 |<br>| JONES  | 2975.00 |     4 |<br>| MARTIN | 1250.00 |     2 |<br>| BLAKE  | 2850.00 |     4 |<br>| CLARK  | 2450.00 |     4 |<br>| SCOTT  | 3000.00 |     4 |<br>| KING   | 5000.00 |     5 |<br>| TURNER | 1500.00 |     3 |<br>| ADAMS  | 1100.00 |     1 |<br>| JAMES  |  950.00 |     1 |<br>| FORD   | 3000.00 |     4 |<br>| MILLER | 1300.00 |     2 |<br>+——–+———+——-+</p><h3><span id="27-内连接之自连接">2.7、内连接之自连接</span></h3><p>案例：查询员工的上级领导，要求显示员工名和对应的领导名？</p><p>mysql&gt; select empno,ename,mgr from emp;<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+</p><p>技巧：一张表看成两张表。<br>emp a 员工表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+</p><p>emp b 领导表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+</p><p>select<br>    a.ename as ‘员工名’, b.ename as ‘领导名’<br>from<br>    emp a<br>join<br>    emp b<br>on<br>    a.mgr &#x3D; b.empno; &#x2F;&#x2F;员工的领导编号 &#x3D; 领导的员工编号</p><p>+——–+——–+<br>| 员工名 | 领导名|<br>+——–+——–+<br>| SMITH  | FORD   |<br>| ALLEN  | BLAKE  |<br>| WARD   | BLAKE  |<br>| JONES  | KING   |<br>| MARTIN | BLAKE  |<br>| BLAKE  | KING   |<br>| CLARK  | KING   |<br>| SCOTT  | JONES  |<br>| TURNER | BLAKE  |<br>| ADAMS  | SCOTT  |<br>| JAMES  | BLAKE  |<br>| FORD   | JONES  |<br>| MILLER | CLARK  |<br>+——–+——–+<br>13条记录，没有KING。《内连接》</p><p>以上就是内连接中的：自连接，技巧：一张表看做两张表。</p><h3><span id="28-外连接">2.8、外连接</span></h3><p>mysql&gt; select * from emp; e<br>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+</p><p>mysql&gt; select * from dept; d<br>+——–+————+———-+<br>| DEPTNO | DNAME      | LOC      |<br>+——–+————+———-+<br>|     10 | ACCOUNTING | NEW YORK |<br>|     20 | RESEARCH   | DALLAS   |<br>|     30 | SALES      | CHICAGO  |<br>|     40 | OPERATIONS | BOSTON   |<br>+——–+————+———-+</p><p>内连接：（A和B连接，AB两张表没有主次关系。平等的。）<br>select<br>    e.ename,d.dname<br>from<br>    emp e<br>join<br>    dept d<br>on<br>    e.deptno &#x3D; d.deptno; &#x2F;&#x2F;内连接的特点：完成能够匹配上这个条件的数据查询出来。</p><p>+——–+————+<br>| ename  | dname      |<br>+——–+————+<br>| CLARK  | ACCOUNTING |<br>| KING   | ACCOUNTING |<br>| MILLER | ACCOUNTING |<br>| SMITH  | RESEARCH   |<br>| JONES  | RESEARCH   |<br>| SCOTT  | RESEARCH   |<br>| ADAMS  | RESEARCH   |<br>| FORD   | RESEARCH   |<br>| ALLEN  | SALES      |<br>| WARD   | SALES      |<br>| MARTIN | SALES      |<br>| BLAKE  | SALES      |<br>| TURNER | SALES      |<br>| JAMES  | SALES      |<br>+——–+————+</p><p>外连接（右外连接）：<br>select<br>    e.ename,d.dname<br>from<br>    emp e<br>right join<br>    dept d<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>&#x2F;&#x2F; outer是可以省略的，带着可读性强。<br>select<br>    e.ename,d.dname<br>from<br>    emp e<br>right outer join<br>    dept d<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>right代表什么：表示将join关键字右边的这张表看成主表，主要是为了将<br>这张表的数据全部查询出来，捎带着关联查询左边的表。<br>在外连接当中，两张表连接，产生了主次关系。</p><p>外连接（左外连接）：<br>select<br>    e.ename,d.dname<br>from<br>    dept d<br>left join<br>    emp e<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>&#x2F;&#x2F; outer是可以省略的，带着可读性强。<br>select<br>    e.ename,d.dname<br>from<br>    dept d<br>left outer join<br>    emp e<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>带有right的是右外连接，又叫做右连接。<br>带有left的是左外连接，又叫做左连接。<br>任何一个右连接都有左连接的写法。<br>任何一个左连接都有右连接的写法。</p><p>+——–+————+<br>| ename  | dname      |<br>+——–+————+<br>| CLARK  | ACCOUNTING |<br>| KING   | ACCOUNTING |<br>| MILLER | ACCOUNTING |<br>| SMITH  | RESEARCH   |<br>| JONES  | RESEARCH   |<br>| SCOTT  | RESEARCH   |<br>| ADAMS  | RESEARCH   |<br>| FORD   | RESEARCH   |<br>| ALLEN  | SALES      |<br>| WARD   | SALES      |<br>| MARTIN | SALES      |<br>| BLAKE  | SALES      |<br>| TURNER | SALES      |<br>| JAMES  | SALES      |<br>| NULL   | OPERATIONS |<br>+——–+————+</p><p>思考：外连接的查询结果条数一定是 &gt;&#x3D; 内连接的查询结果条数？<br>    正确。</p><p>案例：查询每个员工的上级领导，要求显示所有员工的名字和领导名？<br>    select<br>        a.ename as ‘员工名’, b.ename as ‘领导名’<br>    from<br>        emp a<br>    left join<br>        emp b<br>    on<br>        a.mgr &#x3D; b.empno; </p><pre><code>+--------+--------+| 员工名      | 领导名     |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || KING   | NULL   || TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+</code></pre><h3><span id="29-三张表四张表怎么连接">2.9、三张表，四张表怎么连接？</span></h3><pre><code>语法：    select         ...    from        a    join        b    on        a和b的连接条件    join        c    on        a和c的连接条件    right join        d    on        a和d的连接条件    一条SQL中内连接和外连接可以混合。都可以出现！案例：找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？select     e.ename,e.sal,d.dname,s.gradefrom    emp ejoin    dept don     e.deptno = d.deptnojoin    salgrade son    e.sal between s.losal and s.hisal;+--------+---------+------------+-------+| ename  | sal     | dname      | grade |+--------+---------+------------+-------+| SMITH  |  800.00 | RESEARCH   |     1 || ALLEN  | 1600.00 | SALES      |     3 || WARD   | 1250.00 | SALES      |     2 || JONES  | 2975.00 | RESEARCH   |     4 || MARTIN | 1250.00 | SALES      |     2 || BLAKE  | 2850.00 | SALES      |     4 || CLARK  | 2450.00 | ACCOUNTING |     4 || SCOTT  | 3000.00 | RESEARCH   |     4 || KING   | 5000.00 | ACCOUNTING |     5 || TURNER | 1500.00 | SALES      |     3 || ADAMS  | 1100.00 | RESEARCH   |     1 || JAMES  |  950.00 | SALES      |     1 || FORD   | 3000.00 | RESEARCH   |     4 || MILLER | 1300.00 | ACCOUNTING |     2 |+--------+---------+------------+-------+案例：找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？select     e.ename,e.sal,d.dname,s.grade,l.enamefrom    emp ejoin    dept don     e.deptno = d.deptnojoin    salgrade son    e.sal between s.losal and s.hisalleft join    emp lon    e.mgr = l.empno;+--------+---------+------------+-------+-------+| ename  | sal     | dname      | grade | ename |+--------+---------+------------+-------+-------+| SMITH  |  800.00 | RESEARCH   |     1 | FORD  || ALLEN  | 1600.00 | SALES      |     3 | BLAKE || WARD   | 1250.00 | SALES      |     2 | BLAKE || JONES  | 2975.00 | RESEARCH   |     4 | KING  || MARTIN | 1250.00 | SALES      |     2 | BLAKE || BLAKE  | 2850.00 | SALES      |     4 | KING  || CLARK  | 2450.00 | ACCOUNTING |     4 | KING  || SCOTT  | 3000.00 | RESEARCH   |     4 | JONES || KING   | 5000.00 | ACCOUNTING |     5 | NULL  || TURNER | 1500.00 | SALES      |     3 | BLAKE || ADAMS  | 1100.00 | RESEARCH   |     1 | SCOTT || JAMES  |  950.00 | SALES      |     1 | BLAKE || FORD   | 3000.00 | RESEARCH   |     4 | JONES || MILLER | 1300.00 | ACCOUNTING |     2 | CLARK |+--------+---------+------------+-------+-------+</code></pre><h2><span id="3-子查询">3、子查询？</span></h2><h3><span id="31-什么是子查询">3.1、什么是子查询？</span></h3><pre><code>select语句中嵌套select语句，被嵌套的select语句称为子查询。</code></pre><h3><span id="32-子查询都可以出现在哪里呢">3.2、子查询都可以出现在哪里呢？</span></h3><pre><code>select    ..(select).from    ..(select).where    ..(select).</code></pre><h3><span id="33-where子句中的子查询">3.3、where子句中的子查询</span></h3><pre><code>案例：找出比最低工资高的员工姓名和工资？    select         ename,sal    from        emp     where        sal &gt; min(sal);    ERROR 1111 (HY000): Invalid use of group function    where子句中不能直接使用分组函数。实现思路：    第一步：查询最低工资是多少        select min(sal) from emp;        +----------+        | min(sal) |        +----------+        |   800.00 |        +----------+    第二步：找出&gt;800的        select ename,sal from emp where sal &gt; 800;        第三步：合并        select ename,sal from emp where sal &gt; (select min(sal) from emp);        +--------+---------+        | ename  | sal     |        +--------+---------+        | ALLEN  | 1600.00 |        | WARD   | 1250.00 |        | JONES  | 2975.00 |        | MARTIN | 1250.00 |        | BLAKE  | 2850.00 |        | CLARK  | 2450.00 |        | SCOTT  | 3000.00 |        | KING   | 5000.00 |        | TURNER | 1500.00 |        | ADAMS  | 1100.00 |        | JAMES  |  950.00 |        | FORD   | 3000.00 |        | MILLER | 1300.00 |        +--------+---------+</code></pre><h3><span id="34-from子句中的子查询">3.4、from子句中的子查询</span></h3><pre><code>注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）案例：找出每个岗位的平均工资的薪资等级。第一步：找出每个岗位的平均工资（按照岗位分组求平均值）    select job,avg(sal) from emp group by job;    +-----------+-------------+    | job       | avgsal      |    +-----------+-------------+    | ANALYST   | 3000.000000 |    | CLERK     | 1037.500000 |    | MANAGER   | 2758.333333 |    | PRESIDENT | 5000.000000 |    | SALESMAN  | 1400.000000 |    +-----------+-------------+t表第二步：克服心理障碍，把以上的查询结果就当做一张真实存在的表t。mysql&gt; select * from salgrade; s表+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+t表和s表进行表连接，条件：t表avg(sal) between s.losal and s.hisal;        select         t.*, s.grade    from        (select job,avg(sal) as avgsal from emp group by job) t    join        salgrade s    on        t.avgsal between s.losal and s.hisal;        +-----------+-------------+-------+    | job       | avgsal      | grade |    +-----------+-------------+-------+    | CLERK     | 1037.500000 |     1 |    | SALESMAN  | 1400.000000 |     2 |    | ANALYST   | 3000.000000 |     4 |    | MANAGER   | 2758.333333 |     4 |    | PRESIDENT | 5000.000000 |     5 |    +-----------+-------------+-------+</code></pre><h3><span id="35-select后面出现的子查询这个内容不需要掌握了解即可">3.5、select后面出现的子查询（这个内容不需要掌握，了解即可！！！）</span></h3><p>案例：找出每个员工的部门名称，要求显示员工名，部门名？<br>    select<br>        e.ename,e.deptno,(select d.dname from dept d where e.deptno &#x3D; d.deptno) as dname<br>    from<br>        emp e;</p><pre><code>+--------+--------+------------+| ename  | deptno | dname      |+--------+--------+------------+| SMITH  |     20 | RESEARCH   || ALLEN  |     30 | SALES      || WARD   |     30 | SALES      || JONES  |     20 | RESEARCH   || MARTIN |     30 | SALES      || BLAKE  |     30 | SALES      || CLARK  |     10 | ACCOUNTING || SCOTT  |     20 | RESEARCH   || KING   |     10 | ACCOUNTING || TURNER |     30 | SALES      || ADAMS  |     20 | RESEARCH   || JAMES  |     30 | SALES      || FORD   |     20 | RESEARCH   || MILLER |     10 | ACCOUNTING |+--------+--------+------------+//错误：ERROR 1242 (21000): Subquery returns more than 1 rowselect     e.ename,e.deptno,(select dname from dept) as dnamefrom    emp e;注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果，多于1条，就报错了。！</code></pre><h2><span id="4-union合并查询结果集">4、union合并查询结果集</span></h2><pre><code>案例：查询工作岗位是MANAGER和SALESMAN的员工？    select ename,job from emp where job = &#39;MANAGER&#39; or job = &#39;SALESMAN&#39;;    select ename,job from emp where job in(&#39;MANAGER&#39;,&#39;SALESMAN&#39;);    +--------+----------+    | ename  | job      |    +--------+----------+    | ALLEN  | SALESMAN |    | WARD   | SALESMAN |    | JONES  | MANAGER  |    | MARTIN | SALESMAN |    | BLAKE  | MANAGER  |    | CLARK  | MANAGER  |    | TURNER | SALESMAN |    +--------+----------+</code></pre><pre><code>select ename,job from emp where job = &#39;MANAGER&#39;unionselect ename,job from emp where job = &#39;SALESMAN&#39;;+--------+----------+| ename  | job      |+--------+----------+| JONES  | MANAGER  || BLAKE  | MANAGER  || CLARK  | MANAGER  || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+union的效率要高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。。。但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。a 连接 b 连接 ca 10条记录b 10条记录c 10条记录匹配次数是：1000a 连接 b一个结果：10 * 10 --&gt; 100次a 连接 c一个结果：10 * 10 --&gt; 100次使用union的话是：100次 + 100次 = 200次。（union把乘法变成了加法运算）</code></pre><p>union在使用的时候有注意事项吗？</p><pre><code>//错误的：union在进行结果集合并的时候，要求两个结果集的列数相同。select ename,job from emp where job = &#39;MANAGER&#39;unionselect ename from emp where job = &#39;SALESMAN&#39;;// MYSQL可以，oracle语法严格 ，不可以，报错。要求：结果集合并时列和列的数据类型也要一致。select ename,job from emp where job = &#39;MANAGER&#39;unionselect ename,sal from emp where job = &#39;SALESMAN&#39;;+--------+---------+| ename  | job     |+--------+---------+| JONES  | MANAGER || BLAKE  | MANAGER || CLARK  | MANAGER || ALLEN  | 1600    || WARD   | 1250    || MARTIN | 1250    || TURNER | 1500    |+--------+---------+</code></pre><h2><span id="5-limit非常重要">5、limit（非常重要）</span></h2><h3><span id="51-limit作用将查询结果集的一部分取出来-通常使用在分页查询当中">5.1、limit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。</span></h3><p>百度默认：一页显示10条记录。<br>分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。<br>可以一页一页翻页看。</p><h3><span id="52-limit怎么用呢">5.2、limit怎么用呢？</span></h3><pre><code>完整用法：limit startIndex, length    startIndex是起始下标，length是长度。    起始下标从0开始。缺省用法：limit 5; 这是取前5.按照薪资降序，取出排名在前5名的员工？select     ename,salfrom    emporder by     sal desclimit 5; //取前5select     ename,salfrom    emporder by     sal desclimit 0,5;+-------+---------+| ename | sal     |+-------+---------+| KING  | 5000.00 || SCOTT | 3000.00 || FORD  | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+</code></pre><h3><span id="53-注意mysql当中limit在order-by之后执行">5.3、注意：mysql当中limit在order by之后执行！！！！！！</span></h3><h3><span id="54-取出工资排名在3-5名的员工">5.4、取出工资排名在[3-5]名的员工？</span></h3><pre><code>select     ename,salfrom    emporder by    sal desclimit    2, 3;2表示起始位置从下标2开始，就是第三条记录。3表示长度。+-------+---------+| ename | sal     |+-------+---------+| FORD  | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+</code></pre><h3><span id="55-取出工资排名在5-9名的员工">5.5、取出工资排名在[5-9]名的员工？</span></h3><pre><code>select     ename,salfrom    emporder by     sal desclimit    4, 5;+--------+---------+| ename  | sal     |+--------+---------+| BLAKE  | 2850.00 || CLARK  | 2450.00 || ALLEN  | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 |+--------+---------+</code></pre><h3><span id="56-分页">5.6、分页</span></h3><p>每页显示3条记录<br>    第1页：limit 0,3[0 1 2]<br>    第2页：limit 3,3[3 4 5]<br>    第3页：limit 6,3[6 7 8]<br>    第4页：limit 9,3[9 10 11]</p><p>每页显示pageSize条记录<br>    &#x3D;&#x3D;第pageNo页：limit (pageNo - 1) * pageSize  , pageSize&#x3D;&#x3D;</p><pre><code>public static void main(String[] args)&#123;    // 用户提交过来一个页码，以及每页显示的记录条数    int pageNo = 5; //第5页    int pageSize = 10; //每页显示10条    int startIndex = (pageNo - 1) * pageSize;    String sql = &quot;select ...limit &quot; + startIndex + &quot;, &quot; + pageSize;&#125;</code></pre><p>记公式：<br>    limit (pageNo-1)*pageSize , pageSize</p><h2><span id="6-关于dql语句的大总结">6、关于DQL语句的大总结：</span></h2><pre><code>select     ...from    ...where    ...group by    ...having    ...order by    ...limit    ...执行顺序？    1.from    2.where    3.group by    4.having    5.select    6.order by    7.limit..</code></pre><h2><span id="7-表的创建建表">7、表的创建（建表）</span></h2><h3><span id="71-建表的语法格式建表属于ddl语句ddl包括create-drop-alter">7.1、建表的语法格式：(建表属于DDL语句，DDL包括：create drop alter)</span></h3><pre><code>create table 表名(字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型);create table 表名(    字段名1 数据类型,     字段名2 数据类型,     字段名3 数据类型);表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。字段名：见名知意。表名和字段名都属于标识符。</code></pre><h3><span id="72-关于mysql中的数据类型">7.2、关于mysql中的数据类型？</span></h3><pre><code>很多数据类型，我们只需要掌握一些常见的数据类型即可。    varchar(最长255)        可变长度的字符串        比较智能，节省空间。        会根据实际的数据长度动态分配空间。        优点：节省空间        缺点：需要动态分配空间，速度慢。    char(最长255)        定长字符串        不管实际的数据长度是多少。        分配固定长度的空间去存储数据。        使用不恰当的时候，可能会导致空间的浪费。        优点：不需要动态分配空间，速度快。        缺点：使用不当可能会导致空间的浪费。        varchar和char我们应该怎么选择？            性别字段你选什么？因为性别是固定长度的字符串，所以选择char。            姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。    int(最长11)        数字中的整数型。等同于java的int。    bigint        数字中的长整型。等同于java中的long。    float        单精度浮点型数据    double        双精度浮点型数据    date        短日期类型    datetime        长日期类型    clob        字符大对象        最多可以存储4G的字符串。        比如：存储一篇文章，存储一个说明。        超过255个字符的都要采用CLOB字符大对象来存储。        Character Large OBject:CLOB    blob        二进制大对象        Binary Large OBject        专门用来存储图片、声音、视频等流媒体数据。        往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，        你需要使用IO流才行。t_movie 电影表（专门存储电影信息的）编号名字故事情节上映日期时长海报类型no(bigint)name(varchar)history(clob)playtime(date)time(double)image(blob)type(char)------------------------------------------------------------------------------------------------------------------10000哪吒...........2019-10-112.5....&#39;1&#39;10001林正英之娘娘   ...........2019-11-111.5....&#39;2&#39;....</code></pre><h3><span id="73-创建一个学生表">7.3、创建一个学生表？</span></h3><pre><code>学号、姓名、年龄、性别、邮箱地址create table t_student(    no int,    name varchar(32),    sex char(1),    age int(3),    email varchar(255));删除表：    drop table t_student; // 当这张表不存在的时候会报错！    // 如果这张表存在的话，删除    drop table if exists t_student;</code></pre><h3><span id="74-插入数据insert-dml">7.4、插入数据insert （DML）</span></h3><p>​</p><pre><code>语法格式：    insert into 表名(字段名1,字段名2,字段名3...) values(值1,值2,值3);    注意：字段名和值要一一对应。什么是一一对应？        数量要对应。数据类型要对应。insert into t_student(no,name,sex,age,email) values(1,&#39;zhangsan&#39;,&#39;m&#39;,20,&#39;zhangsan@123.com&#39;);insert into t_student(email,name,sex,age,no) values(&#39;lisi@123.com&#39;,&#39;lisi&#39;,&#39;f&#39;,20,2);insert into t_student(no) values(3);+------+----------+------+------+------------------+| no   | name     | sex  | age  | email            |+------+----------+------+------+------------------+|    1 | zhangsan | m    |   20 | zhangsan@123.com ||    2 | lisi     | f    |   20 | lisi@123.com     ||    3 | NULL     | NULL | NULL | NULL             |+------+----------+------+------+------------------+insert into t_student(name) values(&#39;wangwu&#39;);+------+----------+------+------+------------------+| no   | name     | sex  | age  | email            |+------+----------+------+------+------------------+|    1 | zhangsan | m    |   20 | zhangsan@123.com ||    2 | lisi     | f    |   20 | lisi@123.com     ||    3 | NULL     | NULL | NULL | NULL             || NULL | wangwu   | NULL | NULL | NULL             |+------+----------+------+------+------------------+注意：insert语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。drop table if exists t_student;create table t_student(    no int,    name varchar(32),    sex char(1) default &#39;m&#39;,    age int(3),    email varchar(255));+-------+--------------+------+-----+---------+-------+| Field | Type         | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| no    | int(11)      | YES  |     | NULL    |       || name  | varchar(32)  | YES  |     | NULL    |       || sex   | char(1)      | YES  |     | m       |       || age   | int(3)       | YES  |     | NULL    |       || email | varchar(255) | YES  |     | NULL    |       |+-------+--------------+------+-----+---------+-------+insert into t_student(no) values(1);mysql&gt; select * from t_student;+------+------+------+------+-------+| no   | name | sex  | age  | email |+------+------+------+------+-------+|    1 | NULL | m    | NULL | NULL  |+------+------+------+------+-------+insert语句中的“字段名”可以省略吗？可以    insert into t_student values(2); //错误的    // 注意：前面的字段名省略的话，等于都写上了！所以值也要都写上！    insert into t_student values(2, &#39;lisi&#39;, &#39;f&#39;, 20, &#39;lisi@123.com&#39;);    +------+------+------+------+--------------+    | no   | name | sex  | age  | email        |    +------+------+------+------+--------------+    |    1 | NULL | m    | NULL | NULL         |    |    2 | lisi | f    |   20 | lisi@123.com |    +------+------+------+------+--------------+</code></pre><h3><span id="75-insert插入日期">7.5、insert插入日期</span></h3><pre><code>数字格式化：format    select ename,sal from emp;    +--------+---------+    | ename  | sal     |    +--------+---------+    | SMITH  |  800.00 |    | ALLEN  | 1600.00 |    | WARD   | 1250.00 |    | JONES  | 2975.00 |    | MARTIN | 1250.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | SCOTT  | 3000.00 |    | KING   | 5000.00 |    | TURNER | 1500.00 |    | ADAMS  | 1100.00 |    | JAMES  |  950.00 |    | FORD   | 3000.00 |    | MILLER | 1300.00 |    +--------+---------+    格式化数字：format(数字, &#39;格式&#39;)        select ename,format(sal, &#39;$999,999&#39;) as sal from emp;        +--------+-------+        | ename  | sal   |        +--------+-------+        | SMITH  | 800   |        | ALLEN  | 1,600 |        | WARD   | 1,250 |        | JONES  | 2,975 |        | MARTIN | 1,250 |        | BLAKE  | 2,850 |        | CLARK  | 2,450 |        | SCOTT  | 3,000 |        | KING   | 5,000 |        | TURNER | 1,500 |        | ADAMS  | 1,100 |        | JAMES  | 950   |        | FORD   | 3,000 |        | MILLER | 1,300 |        +--------+-------+str_to_date：将字符串varchar类型转换成date类型date_format：将date类型转换成具有一定格式的varchar字符串类型。drop table if exists t_user;create table t_user(    id int,    name varchar(32),    birth date // 生日也可以使用date日期类型);create table t_user(    id int,    name varchar(32),    birth char(10) // 生日可以使用字符串，没问题。);生日：1990-10-11 （10个字符）注意：数据库中的有一条命名规范：    所有的标识符都是全部小写，单词和单词之间使用下划线进行衔接。mysql&gt; desc t_user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(32) | YES  |     | NULL    |       || birth | date        | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+插入数据？    insert into t_user(id,name,birth) values(1, &#39;zhangsan&#39;, &#39;01-10-1990&#39;); // 1990年10月1日    出问题了：原因是类型不匹配。数据库birth是date类型，这里给了一个字符串varchar。    怎么办？可以使用str_to_date函数进行类型转换。    str_to_date函数可以将字符串转换成日期类型date？    语法格式：        str_to_date(&#39;字符串日期&#39;, &#39;日期格式&#39;)    mysql的日期格式：        %Y年        %m 月        %d 日        %h时        %i分        %s秒        insert into t_user(id,name,birth) values(1, &#39;zhangsan&#39;, str_to_date(&#39;01-10-1990&#39;,&#39;%d-%m-%Y&#39;));    str_to_date函数可以把字符串varchar转换成日期date类型数据，    通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，    需要通过该函数将字符串转换成date。好消息？    如果你提供的日期字符串是这个格式，str_to_date函数就不需要了！！！        %Y-%m-%d    insert into t_user(id,name,birth) values(2, &#39;lisi&#39;, &#39;1990-10-01&#39;);查询的时候可以以某个特定的日期格式展示吗？    date_format    这个函数可以将日期类型转换成特定格式的字符串。    select id,name,date_format(birth, &#39;%m/%d/%Y&#39;) as birth from t_user;    +------+----------+------------+    | id   | name     | birth      |    +------+----------+------------+    |    1 | zhangsan | 10/01/1990 |    |    2 | lisi     | 10/01/1990 |    +------+----------+------------+    date_format函数怎么用？        date_format(日期类型数据, &#39;日期格式&#39;)        这个函数通常使用在查询日期方面。设置展示的日期格式。        mysql&gt; select id,name,birth from t_user;    +------+----------+------------+    | id   | name     | birth      |    +------+----------+------------+    |    1 | zhangsan | 1990-10-01 |    |    2 | lisi     | 1990-10-01 |    +------+----------+------------+    以上的SQL语句实际上是进行了默认的日期格式化，    自动将数据库中的date类型转换成varchar类型。    并且采用的格式是mysql默认的日期格式：&#39;%Y-%m-%d&#39;    select id,name,date_format(birth,&#39;%Y/%m/%d&#39;) as birth from t_user;        java中的日期格式？        yyyy-MM-dd HH:mm:ss SSS</code></pre><h3><span id="76-date和datetime两个类型的区别">7.6、date和datetime两个类型的区别？</span></h3><pre><code>date是短日期：只包括年月日信息。datetime是长日期：包括年月日时分秒信息。drop table if exists t_user;create table t_user(    id int,    name varchar(32),    birth date,    create_time datetime);id是整数name是字符串birth是短日期create_time是这条记录的创建时间：长日期类型mysql短日期默认格式：%Y-%m-%dmysql长日期默认格式：%Y-%m-%d %h:%i:%sinsert into t_user(id,name,birth,create_time) values(1,&#39;zhangsan&#39;,&#39;1990-10-01&#39;,&#39;2020-03-18 15:49:50&#39;);在mysql当中怎么获取系统当前时间？    now() 函数，并且获取的时间带有：时分秒信息！！！！是datetime类型的。    insert into t_user(id,name,birth,create_time) values(2,&#39;lisi&#39;,&#39;1991-10-01&#39;,now());</code></pre><h3><span id="77-修改updatedml">7.7、修改update（DML）</span></h3><p>语法格式：<br>    update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2,字段名3&#x3D;值3… where 条件;</p><pre><code>注意：没有条件限制会导致所有数据全部更新。update t_user set name = &#39;jack&#39;, birth = &#39;2000-10-11&#39; where id = 2;+------+----------+------------+---------------------+| id   | name     | birth      | create_time         |+------+----------+------------+---------------------+|    1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 ||    2 | jack     | 2000-10-11 | 2020-03-18 15:51:23 |+------+----------+------------+---------------------+update t_user set name = &#39;jack&#39;, birth = &#39;2000-10-11&#39;, create_time = now() where id = 2;更新所有？    update t_user set name = &#39;abc&#39;;</code></pre><h3><span id="78-删除数据-delete-dml">7.8、删除数据 delete （DML）</span></h3><pre><code>语法格式？    delete from 表名 where 条件;注意：没有条件，整张表的数据会全部删除！delete from t_user where id = 2;insert into t_user(id) values(2);delete from t_user; // 删除所有！</code></pre><h1><span id="mysql-day03课堂笔记">mysql day03课堂笔记</span></h1><h2><span id="1-查询每一个员工的所在部门名称要求显示员工名和部门名">1、查询每一个员工的所在部门名称？要求显示员工名和部门名。</span></h2><pre><code>mysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+</code></pre><pre><code>mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+</code></pre><p>从emp表中取ename，从dept表中取dname，没有条件限制最终查询结果是？</p><pre><code>ENAMEDNAMESMITHACCOUNTING无效记录SMITHRESEARCH有效记录SMITHSALES无效记录SMITHOPERATIONS无效记录ALLENACCOUNTINGALLENRESEARCHALLENSALESALLENOPERATIONS.....56条记录。加个条件是为了达到4选1，也是</code></pre><p>为了数据的有效性。</p><pre><code>select     e.ename,d.dnamefrom    emp ejoin    dept don    e.deptno = d.deptno;加条件只是为了避免笛卡尔积现象，只是为了查询出有效的组合记录。匹配的次数一次都没有少，还是56次。</code></pre><h2><span id="2-insert语句可以一次插入多条记录吗掌握">2、insert语句可以一次插入多条记录吗？【掌握】</span></h2><pre><code>可以的！mysql&gt; desc t_user;+-------------+-------------+------+-----+---------+-------+| Field       | Type        | Null | Key | Default | Extra |+-------------+-------------+------+-----+---------+-------+| id          | int(11)     | YES  |     | NULL    |       || name        | varchar(32) | YES  |     | NULL    |       || birth       | date        | YES  |     | NULL    |       || create_time | datetime    | YES  |     | NULL    |       |+-------------+-------------+------+-----+---------+-------+一次可以插入多条记录：    insert into t_user(id,name,birth,create_time) values    (1,&#39;zs&#39;,&#39;1980-10-11&#39;,now()),     (2,&#39;lisi&#39;,&#39;1981-10-11&#39;,now()),    (3,&#39;wangwu&#39;,&#39;1982-10-11&#39;,now());    语法：insert into t_user(字段名1,字段名2) values(),(),(),();mysql&gt; select * from t_user;+------+--------+------------+---------------------+| id   | name   | birth      | create_time         |+------+--------+------------+---------------------+|    1 | zs     | 1980-10-11 | 2020-03-19 09:37:01 ||    2 | lisi   | 1981-10-11 | 2020-03-19 09:37:01 ||    3 | wangwu | 1982-10-11 | 2020-03-19 09:37:01 |+------+--------+------------+---------------------+</code></pre><h2><span id="3-快速创建表了解内容">3、快速创建表？【了解内容】</span></h2><pre><code>mysql&gt; create table emp2 as select * from emp;原理：    将一个查询结果当做一张表新建！！！！！    这个可以完成表的快速复制！！！！    表创建出来，同时表中的数据也存在了！！！create table mytable as select empno,ename from emp where job = &#39;MANAGER&#39;;</code></pre><h2><span id="4-x3dx3d将查询结果插入到一张表当中x3dx3dinsert相关的了解内容">4、&#x3D;&#x3D;将查询结果插入到一张表当中&#x3D;&#x3D;？insert相关的！！！【了解内容】</span></h2><pre><code>create table dept_bak as select * from dept;mysql&gt; select * from dept_bak;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+insert into dept_bak select * from dept; //很少用！mysql&gt; select * from dept_bak;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   ||     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+</code></pre><h2><span id="5-快速删除表中的数据truncate比较重要必须掌握">5、快速删除表中的数据？【truncate比较重要，必须掌握】</span></h2><pre><code>//删除dept_bak表中的数据delete from dept_bak; //这种删除数据的方式比较慢。mysql&gt; select * from dept_bak;Empty set (0.00 sec)delete语句删除数据的原理？（delete属于DML语句！！！）    表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！    这种删除缺点是：删除效率比较低。    这种删除优点是：支持回滚，后悔了可以再恢复数据！！！truncate语句删除数据的原理？    这种删除效率比较高，表被一次截断，物理删除。    这种删除缺点：不支持回滚。    这种删除优点：快速。用法：truncate table dept_bak; （这种操作属于DDL操作。）大表非常大，上亿条记录？？？？    删除的时候，使用delete，也许需要执行1个小时才能删除完！效率较低。    可以选择使用truncate删除表中的数据。只需要不到1秒钟的时间就删除结束。效率较高。    但是使用truncate之前，必须仔细询问客户是否真的要删除，并警告删除之后不可恢复！    truncate是删除表中的数据，表还在！删除表操作？    drop table 表名; // 这不是删除表中的数据，这是把表删除。</code></pre><h2><span id="6-对表结构的增删改">6、对表结构的增删改？</span></h2><p>​</p><pre><code>什么是对表结构的修改？    添加一个字段，删除一个字段，修改一个字段！！！对表结构的修改需要使用：alter属于DDL语句DDL包括：create drop alter第一：在实际的开发中，需求一旦确定之后，表一旦设计好之后，很少的进行表结构的修改。因为开发进行中的时候，修改表结构，成本比较高。修改表的结构，对应的java代码就需要进行大量的修改。成本是比较高的。这个责任应该由设计人员来承担！第二：由于修改表结构的操作很少，所以我们不需要掌握，如果有一天真的要修改表结构，你可以使用工具！！！！修改表结构的操作是不需要写到java程序中的。实际上也不是java程序员的范畴。</code></pre><h2><span id="7-约束非常重要五颗星">7、约束（非常重要，五颗星*****）</span></h2><h3><span id="71-什么是约束">7.1、什么是约束？</span></h3><pre><code>约束对应的英语单词：constraint在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！约束的作用就是为了保证：表中的数据有效！！</code></pre><h3><span id="72-约束包括哪些">7.2、约束包括哪些？</span></h3><pre><code>非空约束：not null唯一性约束: unique主键约束: primary key （简称PK）外键约束：foreign key（简称FK）检查约束：check（mysql不支持，oracle支持）我们这里重点学习四个约束：    not null    unique    primary key    foreign key</code></pre><h3><span id="73-非空约束not-null">7.3、非空约束：not null</span></h3><p>null和任何值运算得到的结果仍然是null，这点需要注意，不要在表达式中对null值进行运算。</p><pre><code>非空约束not null约束的字段不能为NULL。drop table if exists t_vip;create table t_vip(    id int,    name varchar(255) not null  // not null只有列级约束，没有表级约束！);insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);insert into t_vip(id,name) values(2,&#39;lisi&#39;);insert into t_vip(id) values(3);ERROR 1364 (HY000): Field &#39;name&#39; doesn&#39;t have a default value小插曲：    xxxx.sql这种文件被称为sql脚本文件。    sql脚本文件中编写了大量的sql语句。    我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！    批量的执行SQL语句，可以使用sql脚本文件。    在mysql当中怎么执行sql脚本呢？        mysql&gt; source D:\course\03-MySQL\document\vip.sql        你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，    你执行这个脚本文件，你电脑上的数据库数据就有了！</code></pre><h3><span id="74-唯一性约束-unique">7.4、唯一性约束: unique</span></h3><pre><code>唯一性约束unique约束的字段不能重复，但是可以为NULL。drop table if exists t_vip;create table t_vip(    id int,    name varchar(255) unique,    email varchar(255));insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);insert into t_vip(id,name,email) values(2,&#39;lisi&#39;,&#39;lisi@123.com&#39;);insert into t_vip(id,name,email) values(3,&#39;wangwu&#39;,&#39;wangwu@123.com&#39;);select * from t_vip;insert into t_vip(id,name,email) values(4,&#39;wangwu&#39;,&#39;wangwu@sina.com&#39;);ERROR 1062 (23000): Duplicate entry &#39;wangwu&#39; for key &#39;name&#39;insert into t_vip(id) values(4);insert into t_vip(id) values(5);+------+----------+------------------+| id   | name     | email            |+------+----------+------------------+|    1 | zhangsan | zhangsan@123.com ||    2 | lisi     | lisi@123.com     ||    3 | wangwu   | wangwu@123.com   ||    4 | NULL     | NULL             ||    5 | NULL     | NULL             |+------+----------+------------------+name字段虽然被unique约束了，但是可以为NULL。新需求：name和email两个字段联合起来具有唯一性！！！！    drop table if exists t_vip;    create table t_vip(        id int,        name varchar(255) unique,  // 约束直接添加到列后面的，叫做列级约束。        email varchar(255) unique    );    这张表这样创建是不符合我以上“新需求”的。    这样创建表示：name具有唯一性，email具有唯一性。各自唯一。    以下这样的数据是符合我“新需求”的。    但如果采用以上方式创建表的话，肯定创建失败，因为&#39;zhangsan&#39;和&#39;zhangsan&#39;重复了。    insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);    insert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);    怎么创建这样的表，才能符合新需求呢？        drop table if exists t_vip;        create table t_vip(            id int,            name varchar(255),            email varchar(255),            unique(name,email) // 约束没有添加在列的后面，这种约束被称为表级约束。        );        insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);        insert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);        select * from t_vip;        name和email两个字段联合起来唯一！！！        insert into t_vip(id,name,email) values(3,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);        ERROR 1062 (23000): Duplicate entry &#39;zhangsan-zhangsan@sina.com&#39; for key &#39;name&#39;    什么时候使用表级约束呢？        需要给多个字段联合起来添加某一个约束的时候，需要使用表级约束。unique 和not null可以联合吗？    drop table if exists t_vip;    create table t_vip(        id int,        name varchar(255) not null unique    );    mysql&gt; desc t_vip;    +-------+--------------+------+-----+---------+-------+    | Field | Type         | Null | Key | Default | Extra |    +-------+--------------+------+-----+---------+-------+    | id    | int(11)      | YES  |     | NULL    |       |    | name  | varchar(255) | NO   | PRI | NULL    |       |    +-------+--------------+------+-----+---------+-------+    在mysql当中，如果一个字段同时被not null和unique约束的话，    该字段自动变成主键字段。（注意：oracle中不一样！）    insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);    insert into t_vip(id,name) values(2,&#39;zhangsan&#39;); //错误了：name不能重复    insert into t_vip(id) values(2); //错误了：name不能为NULL。</code></pre><h3><span id="75-主键约束primary-key简称pk非常重要五颗星">7.5、主键约束（primary key，简称PK）非常重要五颗星*****</span></h3><pre><code>主键约束的相关术语？    主键约束：就是一种约束。    主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段    主键值：主键字段中的每一个值都叫做：主键值。什么是主键？有啥用？    主键值是每一行记录的唯一标识。    主键值是每一行记录的身份证号！！！记住：任何一张表都应该有主键，没有主键，表无效！！主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）怎么给一张表添加主键约束呢？    drop table if exists t_vip;    // 1个字段做主键，叫做：单一主键    create table t_vip(        id int primary key,  //列级约束        name varchar(255)    );    insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);    insert into t_vip(id,name) values(2,&#39;lisi&#39;);    //错误：不能重复    insert into t_vip(id,name) values(2,&#39;wangwu&#39;);    ERROR 1062 (23000): Duplicate entry &#39;2&#39; for key &#39;PRIMARY&#39;    //错误：不能为NULL    insert into t_vip(name) values(&#39;zhaoliu&#39;);    ERROR 1364 (HY000): Field &#39;id&#39; doesn&#39;t have a default value可以这样添加主键吗，使用表级约束？    drop table if exists t_vip;    create table t_vip(        id int,        name varchar(255),        primary key(id)  // 表级约束    );    insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);    //错误    insert into t_vip(id,name) values(1,&#39;lisi&#39;);    ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39;表级约束主要是给多个字段联合起来添加约束？    drop table if exists t_vip;    // id和name联合起来做主键：复合主键！！！！    create table t_vip(        id int,        name varchar(255),        email varchar(255),        primary key(id,name)    );    insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);    insert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);    //错误：不能重复    insert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);    ERROR 1062 (23000): Duplicate entry &#39;1-lisi&#39; for key &#39;PRIMARY&#39;    在实际开发中不建议使用：复合主键。建议使用单一主键！    因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。    复合主键比较复杂，不建议使用！！！一个表中主键约束能加两个吗？    drop table if exists t_vip;    create table t_vip(        id int primary key,        name varchar(255) primary key    );    ERROR 1068 (42000): Multiple primary key defined    结论：一张表，主键约束只能添加1个。（主键只能有1个。）主键值建议使用：    int    bigint    char    等类型。    不建议使用：varchar来做主键。主键值一般都是数字，一般都是定长的！主键除了：单一主键和复合主键之外，还可以这样进行分类？    自然主键：主键值是一个自然数，和业务没关系。    业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！    在实际开发中使用业务主键多，还是使用自然主键多一些？        自然主键使用比较多，因为主键只要做到不重复就行，不需要有意义。        业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候，        可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。在mysql当中，有一种机制，可以帮助我们自动维护一个主键值？    drop table if exists t_vip;    create table t_vip(        id int primary key auto_increment, //auto_increment表示自增，从1开始，以1递增！        name varchar(255)    );    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    select * from t_vip;    +----+----------+    | id | name     |    +----+----------+    |  1 | zhangsan |    |  2 | zhangsan |    |  3 | zhangsan |    |  4 | zhangsan |    |  5 | zhangsan |    |  6 | zhangsan |    |  7 | zhangsan |    |  8 | zhangsan |    +----+----------+</code></pre><h3><span id="76-外键约束foreign-key简称fk非常重要五颗星">7.6、外键约束（foreign key，简称FK）非常重要五颗星*****</span></h3><pre><code>外键约束涉及到的相关术语：    外键约束：一种约束（foreign key）    外键字段：该字段上添加了外键约束    外键值：外键字段当中的每一个值。业务背景：    请设计数据库表，来描述“班级和学生”的信息？    第一种方案：班级和学生存储在一张表中？？？    t_student    no(pk)nameclassnoclassname    ----------------------------------------------------------------------------------    1jack100北京市大兴区亦庄镇第二中学高三1班    2lucy100北京市大兴区亦庄镇第二中学高三1班    3lilei100北京市大兴区亦庄镇第二中学高三1班    4hanmeimei100北京市大兴区亦庄镇第二中学高三1班    5zhangsan101北京市大兴区亦庄镇第二中学高三2班    6lisi101北京市大兴区亦庄镇第二中学高三2班    7wangwu101北京市大兴区亦庄镇第二中学高三2班    8zhaoliu101北京市大兴区亦庄镇第二中学高三2班    分析以上方案的缺点：        数据冗余，空间浪费！！！！        这个设计是比较失败的！        第二种方案：班级一张表、学生一张表？？        t_class 班级表    classno(pk)classname    ------------------------------------------------------    100北京市大兴区亦庄镇第二中学高三1班    101北京市大兴区亦庄镇第二中学高三1班    t_student 学生表    no(pk)namecno(FK引用t_class这张表的classno)    ----------------------------------------------------------------    1jack100    2lucy100    3lilei100    4hanmeimei100    5zhangsan101    6lisi101    7wangwu101    8zhaoliu101    当cno字段没有任何约束的时候，可能会导致数据无效。可能出现一个102，但是102班级不存在。    所以为了保证cno字段中的值都是100和101，需要给cno字段添加外键约束。    那么：cno字段就是外键字段。cno字段中的每一个值都是外键值。    注意：        t_class是父表        t_student是子表        删除表的顺序？            先删子，再删父。        创建表的顺序？            先创建父，再创建子。        删除数据的顺序？            先删子，再删父。        插入数据的顺序？            先插入父，再插入子。    思考：子表中的外键引用的父表中的某个字段，被引用的这个字段必须是主键吗？        不一定是主键，但至少具有unique约束。    测试：外键可以为NULL吗？        外键值可以为NULL。</code></pre><h2><span id="8-存储引擎了解内容">8、存储引擎（了解内容）</span></h2><h3><span id="81-什么是存储引擎有什么用呢">8.1、什么是存储引擎，有什么用呢？</span></h3><pre><code>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）存储引擎这个名字高端大气上档次。实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。</code></pre><h3><span id="82-怎么给表添加x2f指定存储引擎呢">8.2、怎么给表添加&#x2F;指定“存储引擎”呢？</span></h3><pre><code>show create table t_student;可以在建表的时候给表指定存储引擎。CREATE TABLE `t_student` (  `no` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `cno` int(11) DEFAULT NULL,  PRIMARY KEY (`no`),  KEY `cno` (`cno`),  CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`classno`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8在建表的时候可以在最后小括号的&quot;)&quot;的右边使用：    ENGINE来指定存储引擎。    CHARSET来指定这张表的字符编码方式。    结论：        mysql默认的存储引擎是：InnoDB        mysql默认的字符编码方式是：utf8建表时指定存储引擎，以及字符编码方式。create table t_product(    id int primary key,    name varchar(255))engine=InnoDB default charset=gbk;</code></pre><h3><span id="83-怎么查看mysql支持哪些存储引擎呢">8.3、怎么查看mysql支持哪些存储引擎呢？</span></h3><p>mysql&gt; select version();<br>+———–+<br>| version() |<br>+———–+<br>| 5.5.36    |<br>+———–+</p><p>命令： show engines \G</p><p>*************************** 1. row ***************************<br>      Engine: FEDERATED<br>     Support: NO<br>     Comment: Federated MySQL storage engine<br>Transactions: NULL<br>          XA: NULL<br>  Savepoints: NULL<br>*************************** 2. row ***************************<br>      Engine: MRG_MYISAM<br>     Support: YES<br>     Comment: Collection of identical MyISAM tables<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 3. row ***************************<br>      Engine: MyISAM<br>     Support: YES<br>     Comment: MyISAM storage engine<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 4. row ***************************<br>      Engine: BLACKHOLE<br>     Support: YES<br>     Comment: &#x2F;dev&#x2F;null storage engine (anything you write to it disappears<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 5. row ***************************<br>      Engine: CSV<br>     Support: YES<br>     Comment: CSV storage engine<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 6. row ***************************<br>      Engine: MEMORY<br>     Support: YES<br>     Comment: Hash based, stored in memory, useful for temporary tables<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 7. row ***************************<br>      Engine: ARCHIVE<br>     Support: YES<br>     Comment: Archive storage engine<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 8. row ***************************<br>      Engine: InnoDB<br>     Support: DEFAULT<br>     Comment: Supports transactions, row-level locking, and foreign keys<br>Transactions: YES<br>          XA: YES<br>  Savepoints: YES<br>*************************** 9. row ***************************<br>      Engine: PERFORMANCE_SCHEMA<br>     Support: YES<br>     Comment: Performance Schema<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO</p><p>mysql支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。</p><h3><span id="84-关于mysql常用的存储引擎介绍一下">8.4、关于mysql常用的存储引擎介绍一下</span></h3><p>MyISAM存储引擎？<br>    它管理的表具有以下特征：<br>        使用三个文件表示每个表：<br>            格式文件 — 存储表结构的定义（mytable.frm）<br>            数据文件 — 存储表行的内容（mytable.MYD）<br>            索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。<br>        可被转换为压缩、只读表来节省空间</p><pre><code>    提示一下：        对于一张表来说，只要是主键，        或者加有unique约束的字段上会自动创建索引。    MyISAM存储引擎特点：        可被转换为压缩、只读表来节省空间        这是这种存储引擎的优势！！！！        MyISAM不支持事务机制，安全性低。</code></pre><p>InnoDB存储引擎？<br>    这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。<br>    InnoDB支持事务，支持数据库崩溃后自动恢复机制。<br>    InnoDB存储引擎最主要的特点是：非常安全。</p><pre><code>它管理的表具有下列主要特征：    – 每个 InnoDB 表在数据库目录中以.frm 格式文件表示    – InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）    – 提供一组用来记录事务性活动的日志文件    – 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理    – 提供全 ACID 兼容    – 在 MySQL 服务器崩溃后提供自动恢复    – 多版本（MVCC）和行级锁定    – 支持外键及引用的完整性，包括级联删除和更新InnoDB最大的特点就是支持事务：    以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，    不能很好的节省存储空间。</code></pre><p>MEMORY存储引擎？<br>    使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，<br>    这两个特点使得 MEMORY 存储引擎非常快。</p><pre><code>MEMORY 存储引擎管理的表具有下列特征：    – 在数据库目录内，每个表均以.frm 格式的文件表示。    – 表数据及索引被存储在内存中。（目的就是快，查询快！）    – 表级锁机制。    – 不能包含 TEXT 或 BLOB 字段。MEMORY 存储引擎以前被称为HEAP 引擎。MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</code></pre><h2><span id="9-事务重点五颗星必须理解必须掌握">9、事务（重点：五颗星*****，必须理解，必须掌握）</span></h2><h3><span id="91-什么是事务">9.1、什么是事务？</span></h3><pre><code>一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。什么是一个完整的业务逻辑？    假设转账，从A账户向B账户中转账10000.    将A账户的钱减去10000（update语句）    将B账户的钱加上10000（update语句）    这就是一个完整的业务逻辑。    以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。    这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</code></pre><h3><span id="92-x3dx3d只有dml语句才会有事务这一说其它语句和事务无关x3dx3d">9.2、&#x3D;&#x3D;只有DML语句才会有事务这一说，其它语句和事务无关！！！&#x3D;&#x3D;</span></h3><pre><code>insertdeleteupdate只有以上的三个语句和事务有关系，其它都没有关系。</code></pre><p>因为 只有以上的三个语句是数据库表中数据进行增、删、改的。<br>只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</p><p>数据安全第一位！！！</p><h3><span id="93-假设所有的业务只要一条dml语句就能完成还有必要存在事务机制吗">9.3、假设所有的业务，只要一条DML语句就能完成，还有必要存在事务机制吗？</span></h3><pre><code>正是因为做某件事的时候，需要多条DML语句共同联合起来才能完成，所以需要事务的存在。如果任何一件复杂的事儿都能一条DML语句搞定，那么事务则没有存在的价值了。到底什么是事务呢？    说到底，说到本质上，一个事务其实就是多条DML语句同时成功，或者同时失败！事务：就是批量的DML语句同时成功，或者同时失败！</code></pre><h3><span id="94-事务是怎么做到多条dml语句同时成功和同时失败的呢">9.4、事务是怎么做到多条DML语句同时成功和同时失败的呢？</span></h3><pre><code>InnoDB存储引擎：提供一组用来记录事务性活动的日志文件事务开启了：insertinsertinsertdeleteupdateupdateupdate事务结束了！在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。在事务的执行过程中，我们可以提交事务，也可以回滚事务。提交事务？    清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。    提交事务标志着，事务的结束。并且是一种全部成功的结束。回滚事务？    将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件    回滚事务标志着，事务的结束。并且是一种全部失败的结束。</code></pre><h3><span id="95-怎么提交事务怎么回滚事务">9.5、怎么提交事务，怎么回滚事务？</span></h3><pre><code>提交事务：commit; 语句回滚事务：rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）事务对应的英语单词是：transaction测试一下，在mysql当中默认的事务行为是怎样的？    mysql默认情况下是支持自动提交事务的。（自动提交）    什么是自动提交？        每执行一条DML语句，则提交一次！    这种自动提交实际上是不符合我们的开发习惯，因为一个业务    通常是需要多条DML语句共同执行才能完成的，为了保证数据    的安全，必须要求同时成功之后再提交，所以不能执行一条    就提交一条。怎么将mysql的自动提交机制关闭掉呢？    先执行这个命令：start transaction;演示事务：    ---------------------------------回滚事务----------------------------------------    mysql&gt; use bjpowernode;    Database changed    mysql&gt; select * from dept_bak;    Empty set (0.00 sec)    mysql&gt; start transaction;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);    Query OK, 1 row affected (0.00 sec)    mysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);    Query OK, 1 row affected (0.00 sec)    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | tj   |    |     10 | abc   | tj   |    +--------+-------+------+    2 rows in set (0.00 sec)    mysql&gt; rollback;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; select * from dept_bak;    Empty set (0.00 sec)    ---------------------------------提交事务----------------------------------------    mysql&gt; use bjpowernode;    Database changed    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | bj   |    +--------+-------+------+    1 row in set (0.00 sec)    mysql&gt; start transaction;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; insert into dept_bak values(20,&#39;abc    Query OK, 1 row affected (0.00 sec)    mysql&gt; insert into dept_bak values(20,&#39;abc    Query OK, 1 row affected (0.00 sec)    mysql&gt; insert into dept_bak values(20,&#39;abc    Query OK, 1 row affected (0.00 sec)    mysql&gt; commit;    Query OK, 0 rows affected (0.01 sec)    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | bj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    +--------+-------+------+    4 rows in set (0.00 sec)    mysql&gt; rollback;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | bj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    +--------+-------+------+    4 rows in set (0.00 sec)</code></pre><h3><span id="96-事务包括4个特性">9.6、事务包括4个特性？</span></h3><pre><code>A：原子性    说明事务是最小的工作单元。不可再分。C：一致性    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，    以保证数据的一致性。I：隔离性    A事务和B事务之间具有一定的隔离。    教室A和教室B之间有一道墙，这道墙就是隔离性。    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？D：持久性    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据    保存到硬盘上！</code></pre><h3><span id="97-重点研究一下事务的隔离性">9.7、重点研究一下事务的隔离性！！！</span></h3><p>A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄。这就是事务的隔离级别。<br>这道墙越厚，表示隔离级别就越高。</p><p>事务和事务之间的隔离级别有哪些呢？4个级别</p><blockquote><p>读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》<br>        什么是读未提交？<br>            事务A可以读取到事务B未提交的数据。<br>        这种隔离级别存在的问题就是：<br>            脏读现象！(Dirty Read)<br>            我们称读到了脏数据。<br>        这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！</p></blockquote><blockquote><p>读已提交：read committed《提交之后才能读到》<br>        什么是读已提交？<br>            事务A只能读取到事务B提交之后的数据。<br>        这种隔离级别解决了什么问题？<br>            解决了脏读的现象。<br>        这种隔离级别存在什么问题？<br>            不可重复读取数据。<br>            什么是不可重复读取数据呢？<br>                在事务开启之后，第一次读到的数据是3条，当前事务还没有<br>                结束，可能第二次再读取的时候，读到的数据是4条，3不等于4<br>                称为不可重复读取。</p></blockquote><p>​这种隔离级别是比较真实的数据，&#x3D;&#x3D;每一次读到的数据是绝对的真实。&#x3D;&#x3D;<br>​oracle数据库默认的隔离级别是：read committed</p><blockquote><p>可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》<br>        什么是可重复读取？<br>            事务A开启之后，不管是多久，每一次在事务A中读取到的数据<br>            都是一致的。即使事务B将数据已经修改，并且提交了，事务A<br>            读取到的数据还是没有发生改变，这就是可重复读。<br>        可重复读解决了什么问题？<br>            解决了不可重复读取数据。<br>        可重复读存在的问题是什么？<br>            可以会出现幻影读。<br>            每一次读取到的数据都是幻象。不够真实！</p><pre><code>    早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！    读到的是假象。不够绝对的真实。</code></pre></blockquote><p>​&#x3D;&#x3D;mysql中默认的事务隔离级别就是这个！！！！！！！！！！！&#x3D;&#x3D;</p><blockquote><p>序列化&#x2F;串行化：serializable（最高的隔离级别）<br>        这是最高隔离级别，<u>效率最低。</u>解决了所有的问题。<br>        这种隔离级别表示事务排队，不能并发！<br>        synchronized，线程同步（事务同步）<br>        每一次读取到的数据都是最真实的，并且效率是最低的。</p></blockquote><h3><span id="98-验证各种隔离级别">9.8、验证各种隔离级别</span></h3><p>查看隔离级别：SELECT @@tx_isolation<br>+—————–+<br>| @@tx_isolation  |<br>+—————–+<br>| REPEATABLE-READ |<br>+—————–+<br>mysql默认的隔离级别</p><p>被测试的表t_user<br>验证：read uncommited<br>mysql&gt; set global transaction isolation level read uncommitted;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>select * from t_user;<br>                                                    start transaction;<br>                                                    insert into t_user values(‘zhangsan’);<br>select * from t_user;</p><p>验证：read commited<br>mysql&gt; set global transaction isolation level read committed;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>                                                    start transaction;<br>select * from t_user;<br>                                                    insert into t_user values(‘zhangsan’);<br>select * from t_user;<br>                                                    commit;<br>select * from t_user;</p><p>验证：repeatable read<br>mysql&gt; set global transaction isolation level repeatable read;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>                                                    start transaction;<br>select * from t_user;<br>                                                    insert into t_user values(‘lisi’);<br>                                                    insert into t_user values(‘wangwu’);<br>                                                    commit;<br>select * from t_user;</p><p>验证：serializable<br>mysql&gt; set global transaction isolation level serializable;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>                                                    start transaction;<br>select * from t_user;<br>insert into t_user values(‘abc’);<br>                                                    select * from t_user;</p><p>mysql day04课堂笔记</p><h1><span id="mysql-day04课堂笔记">mysql day04课堂笔记</span></h1><h2><span id="1-索引index">1、索引（index）</span></h2><h3><span id="11-什么是索引">1.1、什么是索引？</span></h3><pre><code>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。对于一本字典来说，查找某个汉字有两种方式：    第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。    效率比较低。    第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个    位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过    索引检索，效率较高。t_userid(idIndex)name(nameIndex)email(emailIndex)address  (emailAddressIndex)----------------------------------------------------------------------------------1zhangsan...2lisi3wangwu4zhaoliu5hanmeimei6jackselect * from t_user where name = &#39;jack&#39;;以上的这条SQL语句会去name字段上扫描，为什么？    因为查询条件是：name=&#39;jack&#39;如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，MySQL会进行全扫描，会将name字段上的每一个值都比对一遍。效率比较低。MySQL在查询方面主要就是两种方式：    第一种方式：全表扫描    第二种方式：根据索引检索。注意：    在实际中，汉语字典前面的目录是排序的，按照a b c d e f....排序，    为什么排序呢？因为只有排序了才会有区间查找这一说！（缩小扫描范围    其实就是扫描某个区间罢了！）    在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet    数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql    当中索引是一个B-Tree数据结构。    遵循左小又大原则存放。采用中序遍历方式遍历取数据。</code></pre><h3><span id="12-索引的实现原理">1.2、索引的实现原理？</span></h3><pre><code>假设有一张用户表：t_userid(PK)name每一行记录在硬盘上都有物理存储编号----------------------------------------------------------------------------------100zhangsan0x1111120lisi0x222299wangwu0x888888zhaoliu0x9999101jack0x666655lucy0x5555130tom0x7777提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）</code></pre><h3><span id="13-在mysql当中主键上以及unique字段上都会自动添加索引的">1.3、在mysql当中，主键上，以及unique字段上都会自动添加索引的！！！！</span></h3><p>什么条件下，我们会考虑给字段添加索引呢？<br>    条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）<br>    条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。<br>    条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</p><pre><code>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</code></pre><h3><span id="14-索引怎么创建怎么删除语法是什么">1.4、索引怎么创建？怎么删除？语法是什么？</span></h3><pre><code>创建索引：    mysql&gt; create index emp_ename_index on emp(ename);    给emp表的ename字段添加索引，起名：emp_ename_index删除索引：    mysql&gt; drop index emp_ename_index on emp;    将emp表上的emp_ename_index索引对象删除。</code></pre><h3><span id="15-在mysql当中怎么查看一个sql语句是否使用了索引进行检索">1.5、在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索？</span></h3><pre><code>mysql&gt; explain select * from emp where ename = &#39;KING&#39;;+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+扫描14条记录：说明没有使用索引。type=ALLmysql&gt; create index emp_ename_index on emp(ename);mysql&gt; explain select * from emp where ename = &#39;KING&#39;;+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys   | key             | key_len | ref   | rows | Extra       |+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index | 33      | const |    1 | Using where |+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+</code></pre><h3><span id="16-索引有失效的时候什么时候索引失效呢">1.6、索引有失效的时候，什么时候索引失效呢？</span></h3><p>​</p><pre><code>失效的第1种情况：    select * from emp where ename like &#39;%T&#39;;    ename上即使添加了索引，也不会走索引，为什么？        原因是因为模糊匹配当中以“%”开头了！        尽量避免模糊查询的时候以“%”开始。        这是一种优化的手段/策略。    mysql&gt; explain select * from emp where ename like &#39;%T&#39;;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第2种情况：    使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有    索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个    字段上的索引也会实现。所以这就是为什么不建议使用or的原因。    mysql&gt; explain select * from emp where ename = &#39;KING&#39; or job = &#39;MANAGER&#39;;    +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys   | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+失效的第3种情况：    使用复合索引的时候，没有使用左侧的列查找，索引失效    什么是复合索引？        两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。        create index emp_job_sal_index on emp(job,sal);        mysql&gt; explain select * from emp where job = &#39;MANAGER&#39;;    +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+    | id | select_type | table | type | possible_keys     | key               | key_len | ref   | rows | Extra       |    +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+    |  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | emp_job_sal_index | 30      | const |    3 | Using where |    +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+        mysql&gt; explain select * from emp where sal = 800;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第4种情况：    在where当中索引列参加了运算，索引失效。    mysql&gt; create index emp_sal_index on emp(sal);    explain select * from emp where sal = 800;    +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+    | id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |    +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+    |  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |    +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+    mysql&gt; explain select * from emp where sal+1 = 800;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第5种情况：    在where当中索引列使用了函数    explain select * from emp where lower(ename) = &#39;smith&#39;;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第6...失效的第7...</code></pre><h3><span id="17-索引是各种数据库进行优化的重要手段-优化的时候优先考虑的因素就是索引">1.7、索引是各种数据库进行优化的重要手段。优化的时候优先考虑的因素就是索引。</span></h3><p>索引在数据库当中分了很多类？<br>    单一索引：一个字段上添加索引。<br>    复合索引：两个字段或者更多的字段上添加索引。</p><pre><code>主键索引：主键上添加索引。唯一性索引：具有unique约束的字段上添加索引。.....注意：唯一性比较弱的字段上添加索引用处不大，越唯一效率越高</code></pre><h2><span id="2-视图view">2、视图(view)</span></h2><h3><span id="21-什么是视图">2.1、什么是视图？</span></h3><pre><code>view:站在不同的角度去看待同一份数据。</code></pre><h3><span id="22-怎么创建视图对象怎么删除视图对象">2.2、怎么创建视图对象？怎么删除视图对象？</span></h3><pre><code>表复制：mysql&gt; create table dept2 as select * from dept;dept2表中的数据：mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+创建视图对象：    create view dept2_view as select * from dept2;删除视图对象：    drop view dept2_view;注意：只有DQL语句才能以view的形式创建。    create view view_name as 这里的语句必须是DQL语句;</code></pre><h3><span id="23-用视图做什么">2.3、用视图做什么？</span></h3><pre><code>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）//面向视图查询select * from dept2_view; // 面向视图插入insert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);// 查询原表数据mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   ||     60 | SALES      | BEIJING  |+--------+------------+----------+// 面向视图删除mysql&gt; delete from dept2_view;// 查询原表数据mysql&gt; select * from dept2;Empty set (0.00 sec)// 创建视图对象create view     emp_dept_viewas    select         e.ename,e.sal,d.dname    from        emp e    join        dept d    on        e.deptno = d.deptno;// 查询视图对象mysql&gt; select * from emp_dept_view;+--------+---------+------------+| ename  | sal     | dname      |+--------+---------+------------+| CLARK  | 2450.00 | ACCOUNTING || KING   | 5000.00 | ACCOUNTING || MILLER | 1300.00 | ACCOUNTING || SMITH  |  800.00 | RESEARCH   || JONES  | 2975.00 | RESEARCH   || SCOTT  | 3000.00 | RESEARCH   || ADAMS  | 1100.00 | RESEARCH   || FORD   | 3000.00 | RESEARCH   || ALLEN  | 1600.00 | SALES      || WARD   | 1250.00 | SALES      || MARTIN | 1250.00 | SALES      || BLAKE  | 2850.00 | SALES      || TURNER | 1500.00 | SALES      || JAMES  |  950.00 | SALES      |+--------+---------+------------+// 面向视图更新update emp_dept_view set sal = 1000 where dname = &#39;ACCOUNTING&#39;;// 原表数据被更新mysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+</code></pre><h3><span id="24-视图对象在实际开发中到底有什么用方便简化开发利于维护">2.4、视图对象在实际开发中到底有什么用？《方便，简化开发，利于维护》</span></h3><pre><code>    create view         emp_dept_view    as        select             e.ename,e.sal,d.dname        from            emp e        join            dept d        on            e.deptno = d.deptno;</code></pre><p>​<br>​假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。<br>​每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？<br>​可以把这条复杂的SQL语句以视图对象的形式新建。<br>​在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。<br>​并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要<br>​修改视图对象所映射的SQL语句。<br>​<br>​我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。<br>​可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是<br>​存储在硬盘上的，不会消失。<br>​<br>​再提醒一下：<br>​视图对应的语句只能是DQL语句。<br>​但是视图对象创建完成之后，可以对视图进行增删改查等操作。<br>​<br>​小插曲：<br>​增删改查，又叫做：CRUD。<br>​CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。<br>​一般都说CRUD。<br>​<br>​C:Create（增）<br>​R:Retrive（查：检索）<br>​U:Update（改）<br>​D:Delete（删）</p><h2><span id="3-dba常用命令">3、DBA常用命令？</span></h2><pre><code>重点掌握：    数据的导入和导出（数据的备份）    其它命令了解一下即可。（这个培训日志文档留着，以后忘了，可以打开文档复制粘贴。）数据导出？    注意：在windows的dos命令窗口中：        mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123456        可以导出指定的表吗？        mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p123456数据导入？    注意：需要先登录到mysql数据库服务器上。    然后创建数据库：create database bjpowernode;    使用数据库：use bjpowernode    然后初始化数据库：source D:\bjpowernode.sql</code></pre><h2><span id="4-数据库设计三范式">4、数据库设计三范式</span></h2><h3><span id="41-什么是数据库设计范式">4.1、什么是数据库设计范式？</span></h3><pre><code>数据库表的设计依据。教你怎么进行数据库表的设计。</code></pre><h3><span id="42-数据库设计范式共有">4.2、数据库设计范式共有？</span></h3><blockquote><p>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</p></blockquote><blockquote><p>第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，<br>不要产生部分依赖。</p></blockquote><blockquote><p>第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，<br>不要产生传递依赖。</p></blockquote><p>声明：三范式是面试官经常问的，所以一定要熟记在心！</p><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><h3><span id="43-第一范式">4.3、第一范式</span></h3><pre><code>最核心，最重要的范式，所有表的设计都需要满足。必须有主键，并且每一个字段都是原子性不可再分。学生编号 学生姓名 联系方式------------------------------------------1001张三zs@gmail.com,13599999991002李四ls@gmail.com,136999999991001王五ww@163.net,13488888888以上是学生表，满足第一范式吗？    不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话学生编号(pk) 学生姓名邮箱地址联系电话----------------------------------------------------1001张三zs@gmail.com13599999991002李四ls@gmail.com136999999991003王五ww@163.net13488888888</code></pre><h3><span id="44-第二范式">4.4、第二范式：</span></h3><pre><code>建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。学生编号 学生姓名 教师编号 教师姓名----------------------------------------------------1001张三001王老师1002李四002赵老师1003王五001王老师1001张三002赵老师这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）这是非常典型的：多对多关系！分析以上的表是否满足第一范式？    不满足第一范式。怎么满足第一范式呢？修改学生编号+教师编号(pk)学生姓名  教师姓名----------------------------------------------------1001001张三王老师1002002李四赵老师1003001王五王老师1001002张三赵老师学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？    不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。    产生部分依赖有什么缺点？        数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。为了让以上的表满足第二范式，你需要这样设计：    使用三张表来表示多对多的关系！！！！    学生表    学生编号(pk)学生名字    ------------------------------------    1001张三    1002李四    1003王五        教师表    教师编号(pk)教师姓名    --------------------------------------    001王老师    002赵老师    学生教师关系表    id(pk)学生编号(fk)教师编号(fk)    ------------------------------------------------------    11001001    21002002    31003001    41001002背口诀：    多对多怎么设计？        多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</code></pre><h3><span id="45-第三范式">4.5、第三范式</span></h3><pre><code>第三范式建立在第二范式的基础之上要求所有非主键字典必须直接依赖主键，不要产生传递依赖。学生编号（PK） 学生姓名 班级编号  班级名称---------------------------------------------------------    1001张三01一年一班    1002李四02一年二班    1003王五03一年三班    1004赵六03一年三班以上表的设计是描述：班级和学生的关系。很显然是1对多关系！一个教室中有多个学生。分析以上表是否满足第一范式？    满足第一范式，有主键。分析以上表是否满足第二范式？    满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。分析以上表是否满足第三范式？    第三范式要求：不要产生传递依赖！    一年一班依赖01，01依赖1001，产生了传递依赖。    不符合第三范式的要求。产生了数据的冗余。那么应该怎么设计一对多呢？    班级表：一    班级编号(pk)班级名称    ----------------------------------------    01一年一班    02一年二班    03一年三班    学生表：多    学生编号（PK） 学生姓名 班级编号(fk)    -------------------------------------------    1001张三01    1002李四02    1003王五03    1004赵六03        背口诀：        一对多，两张表，多的表加外键！！！！！！！！！！！！</code></pre><h3><span id="46-总结表的设计">4.6、总结表的设计？</span></h3><pre><code>一对多：    一对多，两张表，多的表加外键！！！！！！！！！！！！多对多：    多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！一对一：    一对一放到一张表中不就行了吗？为啥还要拆分表？    在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。    一对一怎么设计？        没有拆分表之前：一张表            t_user            idlogin_namelogin_pwdreal_nameemailaddress........            ---------------------------------------------------------------------------            1zhangsan123张三zhangsan@xxx            2lisi123李四lisi@xxx            ...                这种庞大的表建议拆分为两张：            t_login 登录信息表            id(pk)login_namelogin_pwd            ---------------------------------            1zhangsan123            2lisi123            t_user 用户详细信息表            id(pk)real_nameemailaddress........login_id(fk+unique)            -----------------------------------------------------------------------------------------            100张三zhangsan@xxx1            200李四lisi@xxx2            口诀：一对一，外键唯一！！！！！！！！！！</code></pre><h3><span id="47-嘱咐一句话">4.7、嘱咐一句话：</span></h3><pre><code>数据库设计三范式是理论上的。实践和理论有的时候有偏差。最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。面试的时候把这句话说上：他就不会认为你是初级程序员了！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
