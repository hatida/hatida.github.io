<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql必知必会</title>
      <link href="/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2024/02/05/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="第4章-检索数据">第4章 检索数据</span></h1><h2><span id="45-检索不同的行">4.5 检索不同的行</span></h2><p>DISTINCT关键字：此关键字指示MySQL只返回不同的值。</p><blockquote><p>不能部分使用DISTINCT DISTINCT关键字应用于所有列而<br>不仅是前置它的列。如果给出SELECT DISTINCT vend_id,<br>prod_price，除非指定的两个列都不同，否则所有行都将被<br>检索出来。</p><p>相当于将distinct后面的列放在一起作为条件</p></blockquote><h2><span id="46-限制结果-limit关键字">4.6 限制结果-limit关键字</span></h2><h3><span id="461分页">4.6.1分页</span></h3><p>应用实例：</p><blockquote><p> 用户提交过来一个页码，以及每页显示的记录条数</p></blockquote><pre><code>int pageNo = 5; //第5页int pageSize = 10; //每页显示10条</code></pre><p>&#x3D;&#x3D;记公式：limit (pageNo-1)*pageSize , pageSize&#x3D;&#x3D;</p><pre><code>pageno = 1 limit 0,10pageno = 2limit 10,10pageno = 3 limit 20,10pageno = 4 limit 30,10...以此类推</code></pre><h2><span id="47-使用完全限定的表名">4.7 使用完全限定的表名</span></h2><pre><code>SELECT products.prod_nameFROM crashcourse.products;</code></pre><p>这段语句限定了表和数据库，在一些情景很有用。</p><h1><span id="第5章-排序检索数据">第5章 排序检索数据</span></h1><h2><span id="51-排列数据">5.1 排列数据</span></h2><blockquote><p>子句（clause） </p><p>SQL语句由子句构成，有些子句是必需的，而<br>有的是可选的。一个子句通常由一个关键字和所提供的数据组成</p></blockquote><p>为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。</p><h2><span id="52-按多个列排序">5.2 按多个列排序</span></h2><blockquote><p>order by子句后加多个列，如果前一个列中所有的值都是唯一的则不会按照第二个列来排序。</p></blockquote><h2><span id="53-指定排序方向">5.3 指定排序方向</span></h2><blockquote><p>ordery by子句默认是升序排列，可以使用DESC关键字来指定降序排列。</p></blockquote><pre><code class="sql">SELECT prod_id,prod_price,prod_nameFROM productsORDER BY prod_price DESC,prod_name;//【1】</code></pre><p>【1】：&#x3D;&#x3D;DESC关键字只应用到直接位于其前面的列名，上面的情况第一列按照指定的降序排列，第二列按照默认的升序排列&#x3D;&#x3D;</p><p><strong>在多个列上降序排序：</strong> </p><blockquote><p>如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。</p></blockquote><p>与DESC相反的关键字是ASC（ASCENDING），ASC没有多大用处，因为升序是默认的。</p><h1><span id="第6章-过滤数据">第6章 过滤数据</span></h1><h2><span id="x3dx3dwhere子句操作符x3dx3d">&#x3D;&#x3D;WHERE子句操作符&#x3D;&#x3D;</span></h2><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定的两个值之间</td></tr></tbody></table><h3><span id="范围值检查between">范围值检查between</span></h3><p>使用BETWEEN操作符。其语法与其他WHERE子句的操作符不同，需要指定2个值，范围的开始值和范围的结束值。</p><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10;</code></pre><p>等价于下面的子句：</p><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE prod_price &gt;= 5 AND prod_price&lt;=10;</code></pre><h3><span id="x3dx3d空值检查x3dx3d">&#x3D;&#x3D;空值检查&#x3D;&#x3D;</span></h3><h1><span id="第7章-数据过滤">第7章 数据过滤</span></h1><h2><span id="and操作符">and操作符</span></h2><pre><code class="sql">SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id 1003 AND prod_price &lt;10</code></pre><blockquote><p>and，两个条件都要满足。</p></blockquote><h2><span id="or操作符">OR操作符</span></h2><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id 1002 OR vend_id 1003;</code></pre><blockquote><p>or，两个条件满足其一即可</p></blockquote><h2><span id="x3dx3d计算次序x3dx3d">&#x3D;&#x3D;计算次序&#x3D;&#x3D;</span></h2><blockquote><p>WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂和高级的过滤。</p></blockquote><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id 1002 OR vend_id 1003 AND prod_price &gt;10;</code></pre><p>上面的sql语句本意在于列出价格为10美元（含）以上且由1002或1003制造的所有产品，但是语句并没有返回预期的结果。</p><blockquote><p>SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符</p></blockquote><p>此问题的解决方法是使用圆括号明确地分组相应的操作符</p><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE (vend_id 1002 OR vend_id 1003)AND prod_price &gt;=10:</code></pre><blockquote><p>在WHERE子句中使用圆括号 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序。</p></blockquote><h2><span id="in操作符">IN操作符</span></h2><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id IN (1002,1003)ORDER BY prod_name;</code></pre><blockquote><p>N操作符完成与OR相同的功能，等价于下面的sql语句</p></blockquote><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id=1002 OR vend id=1003ORDER BY prod_name;</code></pre><p><strong>使用IN操作符的好处</strong></p><ul><li>在使用长的合法选项清单时，IN操作符的语法更&#x3D;&#x3D;清楚且更直观。&#x3D;&#x3D;</li><li>在使用IN时，&#x3D;&#x3D;计算的次序更容易管理&#x3D;&#x3D;（因为使用的操作符更少）。</li><li>IN操作符一般&#x3D;&#x3D;比OR操作符清单执行更快。&#x3D;&#x3D;</li><li>IN的最大优点是&#x3D;&#x3D;可以包含其他SELECT语句&#x3D;&#x3D;，使得能够更动态地建<br>  立WHERE子句。第14章将对此进行详细介绍。</li></ul><h2><span id="not操作符">NOT操作符</span></h2><blockquote><p>WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。</p></blockquote><pre><code class="sql">SELECT prod_name,prod_priceFROM productsWHERE vend_id NOT IN (1002,1003)ORDER BY prod_name;</code></pre><p>&#x3D;&#x3D;MySQL中的NOT MySQL支持使用NOT 对IN 、BETWEEN 和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。&#x3D;&#x3D;</p><h1><span id="第8章-用通配符进行过滤">第8章 用通配符进行过滤</span></h1><h2><span id="like操作符">LIKE操作符</span></h2><blockquote><p><strong>通配符（wildcard）</strong>： 用来匹配值的一部分的特殊字符</p></blockquote><blockquote><p><strong>搜索模式（search pattern）</strong>： 由字面值、通配符或两者组合构成的搜索条件。</p></blockquote><h2><span id="百分号通配符">百分号（%）通配符</span></h2><blockquote><p>%代表搜索模式中给定位置的0个、1个或多个字符。</p></blockquote><ol><li><p>搜索模式<code>‘jet%’</code>找出所有以词jet起头的产品</p><pre><code class="sql">SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE &#39;jet%&#39;</code></pre></li></ol><p>&#x3D;&#x3D;区分大小写： 根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写，’jet%’与JetPack 1000将不匹配。&#x3D;&#x3D;</p><ol start="2"><li><p>搜索模式<code>&#39;%anvil%&#39;</code>表示匹配任何位置包含文本anvil的值，而不论它之前或之后出现什么字符。</p></li><li><p>搜索模式<code>‘s%e’</code>找出以s起头以e结尾的所有产品：</p></li></ol><p><strong>注意尾空格</strong> </p><blockquote><p>尾空格可能会干扰通配符匹配。例如，在保存词anvil 时， 如果它后面有一个或多个空格， 则子句WHERE prod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数（第11章将会介绍）去掉首尾空格。</p></blockquote><p><strong>注意NULL</strong> </p><blockquote><p>虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行。</p></blockquote><h2><span id="下划线_通配符">下划线（_）通配符</span></h2><blockquote><p><strong>下划线的用途与%一样，但下划线&#x3D;&#x3D;只匹配单个字符&#x3D;&#x3D;而不是多个字符。</strong></p></blockquote><h1><span id="第10章-创建计算字段">第10章 创建计算字段</span></h1><blockquote><p>字段（field）： 基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</p></blockquote><h2><span id="x3dx3d拼接字段x3dx3d">&#x3D;&#x3D;拼接字段&#x3D;&#x3D;</span></h2><p><strong>Concat()函数</strong></p><blockquote><p>拼接（concatenate）： 将值联结到一起构成单个值</p></blockquote><p>在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。</p><p><strong>MySQL的不同之处</strong> </p><blockquote><p>多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心</p></blockquote><pre><code class="sql">SELECT Concat(vend_name,&#39;(&#39;,vend_country,&#39;)&#39;)//[1]FROM vendorsORDER BY vend_name;</code></pre><blockquote><p><code>[1]</code>:Concat()拼接串，即把多个串连接起来形成一个较长的串。Concat()需要一个或多个指定的串，各个串之间用逗号分隔。</p><p>上面的SELECT语句连接以下4个元素：</p><ul><li>存储在vend_name列中的名字；</li><li>包含一个空格和一个左圆括号的串；</li><li>存储在vend_country列中的国家；</li><li>包含一个右圆括号的串</li></ul></blockquote><p><strong>去除空格Trim函数</strong></p><p>在第8章中曾提到通过删除数据右侧多余的空格来整理数据，这可以使用MySQL的RTrim()函数来完成，如下所示：<br>RTrim()函数去掉值右边的所有空格。通过使用RTrim()，各个列都进行了整理</p><pre><code>SELECT Concat(RTrim(vend_name),&#39;(&#39;,RTrim(vend_country),&#39;)&#39;)FROM vendorsORDER BY vend_name;</code></pre><blockquote><p>Trim函数: MySQL除了支持RTrim()（正如刚才所见，它去掉串右边的空格），还支持LTrim()（去掉串左边的空格）以及<br>Trim()（去掉串左右两边的空格）。</p></blockquote><p><strong>使用别名Alias</strong></p><blockquote><p>别名（alias）：是一个字段或值的替换名。别名用AS关键字赋予</p></blockquote><blockquote><p>别名的其他用途 ：别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在<br>原来的名字含混或容易误解时扩充它。</p></blockquote><blockquote><p>导出列： 别名有时也称为导出列（derived column），不管称为什么，它们所代表的都是相同的东西</p></blockquote><h2><span id="执行算数运算">执行算数运算</span></h2><pre><code class="sql">SELECT prod_id,quantity,item_price,quantity*item_price As expanded_price//[1]FROM orderitemsWHERE order_num 20005;</code></pre><p><code>[1]</code>:输出中显示的expanded_price列为一个计算字段，此计算为quantity*item_price。客户机应用现在可以使用这个新计算<br>列，就像使用其他列一样。</p><p><strong>&#x3D;&#x3D;如何测试计算&#x3D;&#x3D;</strong> </p><blockquote><p>SELECT提供了测试和试验函数与计算的一个很好的办法。虽然SELECT通常用来从表中检索数据，但可以省略FROM子句以便简单地访问和处理表达式。例如，SELECT3*2;将返回6，SELECT Trim(‘abc’);将返回abc，而SELECTNow()利用Now()函数返回当前日期和时间。通过这些例子，可以明白如何根据需要使用SELECT进行试验。</p></blockquote><h1><span id="第11章-使用数据处理函数">第11章 使用数据处理函数</span></h1><h2><span id="函数">函数</span></h2><p>去掉串尾空格的RTrim()就是一个函数的例子。</p><blockquote><p>函数没有SQL的可移植性强，如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p></blockquote><h2><span id="使用函数">使用函数</span></h2><p>大多数SQL实现支持以下类型的函数</p><ul><li>用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。</li><li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）<br>  的数值函数。</li><li>用于处理日期和时间值并从这些值中提取特定成分（例如，返回<br>  两个日期之差，检查日期有效性等）的日期和时间函数。</li><li>返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本<br>  细节）的系统函数</li></ul><h3><span id="文本处理函数">文本处理函数</span></h3><p>Trim()函数:</p><p>Upper()函数:</p><pre><code class="sql">SELECT vend_name,Upper (vend_name)AS vend_name_upcaseFROM vendorsORDER BY vend_name;</code></pre><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr></tbody></table><h3><span id="日期和时间处理函数">日期和时间处理函数</span></h3><p><img src="https://gitee.com/kilomi/pic-bed/raw/master/img/202402050101323.png" alt="image-20231202102542306"></p><blockquote><p>无论你什么时候指定一个日期，，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd</p></blockquote><pre><code class="sql">SELECT cust_id,order_numFROM ordersWHERE order_date =&#39;2005-09-01&#39;;</code></pre><p><em><strong>使用WHERE order_date &#x3D; ‘2005-09-01’可靠吗？</strong></em></p><blockquote><p>order_date的数据类型为datetime。这种类型存储日期及时间值。样例表中的值全都具有时间值00:00:00，但实际中很可能并不总是这样。如果用当前日期和时间存储订单日期（因此你不仅知道订单日期，还知道下订单当天的时间）， 怎么办？ 比如， 存储的order_date 值为2005-09-01 11:30:05，则WHEREorder_date &#x3D; ‘2005-09-01’失败。即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。</p></blockquote><blockquote><p>解决办法是指示MySQL仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较。为此，必须使用Date()函数。Date(order_date)指示MySQL仅提取列的日期部分，更可靠的SELECT语句为：</p></blockquote><pre><code class="sql">SELECT cust_id,order_numFROM ordersWHERE Date(order_date)=&#39;2005-09-01&#39;;</code></pre><p><strong>如果要的是日期，请使用Date()</strong> :</p><blockquote><p>如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。</p></blockquote><p><strong>还有一种日期比较需要说明。如果你想检索出2005年9月下的所有订单，怎么办？</strong></p><p>简单的相等测试不行，因为它也要匹配月份中的天数。</p><p>方法一：</p><pre><code class="sql">SELECT custid,order_numFROM ordersWHERE Date(order_date) BETWEEN &#39;2005-09-01&#39;AND &#39;2005-09-30&#39;;</code></pre><p>方法二（一种不需要记住每个月中有多少天或不需要操心闰年2月的办法）：</p><pre><code class="sql">SELECT cust_id,order_numFROM ordersWHERE Year(order_date)=2005 AND Month(order_date)=9;</code></pre><h3><span id="数值处理函数">数值处理函数</span></h3><blockquote><p>数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期—时间处理函数的使用那么频繁。<br>具有讽刺意味的是，在主要DBMS的函数中，数值函数是最一致最统一的函数。</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table><h1><span id="x3dx3d第12章-汇总数据x3dx3d">&#x3D;&#x3D;第12章 汇总数据&#x3D;&#x3D;</span></h1><h2><span id="聚集函数">聚集函数</span></h2><blockquote><p>我们经常需要汇总数据而不用把它们实际检索出来，MySQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有以下几种：</p></blockquote><ul><li>确定表中行数（或者满足某个条件或包含某个特定值的行数）。</li><li>获得表中行组的和。</li><li>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。</li></ul><p><strong>聚集函数</strong></p><blockquote><p>（aggregate function） 运行在行组上，计算和返回单个值的函数。</p></blockquote><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM</td><td>返回某列值之和</td></tr></tbody></table><h3><span id="avg函数">AVG函数</span></h3><blockquote><p>AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，<strong>也可以用来返回特定列或行的平均值。</strong></p></blockquote><p><strong>返回所有列的平均值</strong></p><pre><code class="sql">SELECT AVG(prod_price) AS avg_priceFROM products;</code></pre><p><strong>返回特定行的平均值</strong></p><pre><code class="sql">SELECT AVG(prod_price) AS avg_priceFROM productsWHERE vend_id = 1003;</code></pre><p><strong>&#x3D;&#x3D;只用于单个列&#x3D;&#x3D;</strong></p><blockquote><p>AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。</p></blockquote><p>**NULL值 **</p><blockquote><p><strong>AVG()函数忽略列值为NULL的行。</strong></p></blockquote><h3><span id="count函数">COUNT()函数</span></h3><p>COUNT()函数有两种使用方式。</p><ul><li>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li><li>使用COUNT(column)对特定列中具有值的行进行计数，&#x3D;&#x3D;忽略NULL值&#x3D;&#x3D;</li></ul><h3><span id="max函数">MAX()函数</span></h3><p><strong>对非数值数据使用MAX()</strong> </p><blockquote><p>虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。</p></blockquote><p><strong>NULL值</strong> </p><blockquote><p>MAX()函数忽略列值为NULL的行。</p></blockquote><h3><span id="min函数">MIN()函数</span></h3><p><strong>对非数值数据使用MIN()</strong> </p><blockquote><p>MIN()函数与MAX()函数类似，MySQL允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面的行</p></blockquote><p><strong>NULL值</strong></p><blockquote><p>MIN()函数忽略列值为NULL的行。</p></blockquote><h3><span id="x3dx3dsum函数x3dx3d">&#x3D;&#x3D;SUM()函数&#x3D;&#x3D;</span></h3><blockquote><p>SUM()用来返回指定列值的和(总计)</p></blockquote><p>orderitems表包含订单中实际的物品，每个物品<br>有相应的数量（quantity）。可如下检索所订购物品的总数（所有quantity值之和）：</p><pre><code class="sql">SELECT SUM(quantity) As items_orderedFROM orderitemsWHERE order_num = 20005;</code></pre><blockquote><p>SUM()也可以用来合计计算值。</p></blockquote><p>在下面的例子中，合计每项物品item_price*quantity，得出总的订单金额：</p><pre><code class="sql">SELECT SUM(item_price*quantity) AS total_priceFROM orderitemsWHERE order_num = 20005;</code></pre><p><strong>在多个列上进行计算</strong> </p><blockquote><p>如本例所示，&#x3D;&#x3D;利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。&#x3D;&#x3D;</p></blockquote><p><strong>NULL值</strong> </p><blockquote><p>SUM()函数忽略列值为NULL的行。</p></blockquote><h2><span id="聚合不同值">聚合不同值</span></h2><h3><span id="distinct聚集函数">Distinct聚集函数</span></h3><p>以上5个聚集函数都可以如下使用：</p><ul><li>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</li><li>只包含不同的值，指定DISTINCT参数</li></ul><pre><code class="sql">SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend id = 1003;</code></pre><p>在使用了DISTINCT后，此例子中的avg_price比较高，因为有多个物品具有相同的较低价格。排除它们提升了平均价格。</p><p><strong>注意</strong></p><blockquote><p>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p></blockquote><p><strong>将DISTINCT用于MIN()和MAX()</strong> </p><blockquote><p>虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的</p></blockquote><h2><span id="组合聚集函数">组合聚集函数</span></h2><p>目前为止的所有聚集函数例子都只涉及单个函数。但实际上SELECT语句可根据需要包含多个聚集函数。请看下面的例子：</p><pre><code class="sql">SELECT COUNT(*)AS num_items,MIN(prod_price)AS price_min,MAX(prod_price)AS price_max,AVG(prod_price)AS price_avgFROM products;</code></pre><p><strong>取别名</strong> </p><blockquote><p>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</p></blockquote><h1><span id="x3dx3d第13章-分组数据x3dx3d">&#x3D;&#x3D;第13章 分组数据&#x3D;&#x3D;</span></h1><h2><span id="数据分组">数据分组</span></h2><pre><code class="sql">SELECT COUNT(*)AS num_prodsFROM productsWHERE vend id = 1003;</code></pre><p>这个案例只能返回供应商1003提供的产品数目，如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？<br>这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。</p><h3><span id="创建分组">创建分组</span></h3><pre><code class="sql">SELECT vend_id,COUNT(*) AS num_prodsFROM productsGROUP BY vend_id;</code></pre><blockquote><p>GROUP BY子句指示MySQL&#x3D;&#x3D;<strong>按vend_id排序</strong>并分组数据&#x3D;&#x3D;。这导致对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。因为使用了GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。<u>GROUP BY子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。</u></p></blockquote><p><strong>&#x3D;&#x3D;一些重要的规定：&#x3D;&#x3D;</strong></p><ul><li><p>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制</p></li><li><p>如果在GROUP BY子句中<strong>嵌套了分组，数据将在最后规定的分组上进行汇总</strong>。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</p><pre><code>例如，假设有一个包含以下字段的表格：Country（国家）、City（城市）、Population（人口）。如果使用以下SQL查询语句：SELECT Country, City, SUM(Population)FROM table_nameGROUP BY Country, City;那么数据将首先按照Country字段进行分组，然后在每个Country分组内再按照City字段进行分组。最后，将在最后指定的Country和City分组上进行汇总，计算每个City的人口总数。</code></pre></li><li><p>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（&#x3D;&#x3D;但不能是聚集函数&#x3D;&#x3D;）。<strong>如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</strong></p></li><li><p>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</p></li><li><p>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p></li><li><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p></li></ul><p><strong>使用ROLLUP</strong> </p><blockquote><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值，如下所示：</p></blockquote><pre><code class="sql">SELECT vend_id,COUNT(*)AS num_prodsFROM productsGROUP BY vend_id WITH ROLLUP;</code></pre><h2><span id="过滤分组">过滤分组</span></h2><p>除了能用GROUP BY分组数据外，MySQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，可能想要列出至少有两个订单的所有顾客。为得出这种数据，必须基于完整的分组而不是个别的行进行过滤。<br>我们已经看到了WHERE子句的作用（第6章中引入）。但是，在这个例子中WHERE不能完成任务，因为WHERE过滤指定的是行而不是分组。事实上，WHERE没有分组的概念。那么，不使用WHERE使用什么呢？MySQL为此目的提供了另外的子句，那就是HAVING子句。<u>HAVING非常类似于WHERE。事实上，目前为止所</u><br><u>学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是&#x3D;&#x3D;WHERE过滤行，而HAVING过滤分组。&#x3D;&#x3D;</u></p><pre><code class="sql">SELECT cust_id,COUNT(*)AS ordersFROM ordersGROUP BY cust idHAVING COUNT(*)&gt;=2;</code></pre><blockquote><p>这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(*) &gt;&#x3D;2（两个以上的订单）的那些分组。</p></blockquote><p><strong>HAVING和WHERE的差别</strong> </p><blockquote><p>这里有另一种理解方法&#x3D;&#x3D;，WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。&#x3D;&#x3D;这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组</p></blockquote><p><strong>有没有在一条语句中同时使用WHERE和HAVING子句的需要呢？</strong><br>事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个<br>以上订单的分组。为更好地理解，请看下面的例子，它列出具有2个（含）以上、价格为10（含）以上的产品的供应商：</p><pre><code class="sql">SELECT vend_id,COUNT(*) AS num_prodsFROM productsWHERE prod_price &gt;=10GROUP BY vend idHAVING COUNT(*)&gt;=2;</code></pre><p>WHERE子句过滤所有prod_price至少为10的行。然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。如果没有WHERE子句，将会多检索出两行（供应商1002，销售的所有产品价格都在10以下；</p><h2><span id="分组和排序">分组和排序</span></h2><blockquote><p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p></blockquote><h2><span id="select子句顺序">SELECT子句顺序</span></h2><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table><h1><span id="第14章-使用子查询">第14章 使用子查询</span></h1><blockquote><p>查询（query）： 任何SQL语句都是查询。但此术语一般指SELECT语句。</p></blockquote><blockquote><p>子查询（subquery）：即<strong>嵌套在其他查询中的查询。</strong></p></blockquote><h2><span id="利用子查询进行过滤">利用子查询进行过滤</span></h2><p>本书所有章中使用的数据库表都是关系表（关于每个表及关系的描述，请参阅附录B）。订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的<br>orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。<br>现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索？下面列出具体的步骤。</p><p>(1) 检索包含物品TNT2的所有订单的编号。<br>(2) 检索具有前一步骤列出的订单编号的所有客户的ID。<br>(3) 检索前一步骤返回的所有客户ID的客户信息。</p><p>上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。也可以使用子查询来把3个查询组合成一条语句。第一条SELECT语句的含义很明确，对于prod_id为TNT2的所有订单物品，它检索其order_num列。输出列出两个包含此物品的订单：</p><pre><code class="sql">SELECT order_numFROM orderitemsWHERE prod_id &#39;TNT2&#39;;结果：+--------+order_num----------2000520007+--------+</code></pre><p>下一步，查询具有订单20005和20007的客户ID。</p><pre><code class="sql">SELECT cust idFROM ordersWHERE order_num IN (20005,20007); +--------+|cust_id  ||10001    ||10004    | +--------+</code></pre><p>现在，把第一个查询（返回订单号的那一个）变为子查询组合两个查询。请看下面的SELECT语句：</p><pre><code class="sql">SELECT cust idFROM ordersWHERE order_num IN (SELECT order_num                    FROM orderitems                WHERE prod_id &#39;TNT2&#39;);结果： +--------+|cust_id  ||10001    ||10004    | +--------+</code></pre><p>&#x3D;&#x3D;在SELECT语句中，子查询总是从内向外处理。&#x3D;&#x3D;在处理上面的SELECT语句时，MySQL实际上执行了两个操作。</p><p>首先，它执行下面的查询：</p><pre><code class="sql">SELECT order num FROM orderitems WHERE prod_id=&#39;TNT2</code></pre><p>此查询返回两个订单号：20005和20007。然后，这两个值以IN操作符要求的逗号分隔的格式传递给外部查询的WHERE子句。</p><p>外部查询变成：</p><pre><code class="sql">SELECT cust_id FROM orders WHERE order_num IN (20005,20007)</code></pre><p>可以看到，输出是正确的并且与前面硬编码WHERE子句所返回的值相同。</p><p><strong>&#x3D;&#x3D;格式化SQL&#x3D;&#x3D;</strong></p><blockquote><p>包含子查询的SELECT语句难以阅读和调试，特别是它们较为复杂时更是如此。如上所示把子查询分解为多行并且适当地进行缩进，能极大地简化子查询的使用。</p></blockquote><p>最后一步：</p><pre><code class="sql">SELECT cust_name,cust_contactFROM customersWHERE custid IN (SELECT cust_id                    FROM orders                    WHERE order_num IN (SELECT order_num                                        FROM orderitems                                        WHERE prod_id =&#39;TNT2&#39;));</code></pre><blockquote><p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。<u>对于能嵌套的子查询的数目没有限制</u>，不过在实际使用时由于性能的限制，不能嵌套太多的子查询</p></blockquote><p><strong>列必须匹配</strong></p><blockquote><p>在WHERE子句中使用子查询（如这里所示），&#x3D;&#x3D;应该保证SELECT语句具有与WHERE子句中相同数目的列&#x3D;&#x3D;。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</p></blockquote><p>虽然子查询一般与IN操作符结合使用，但也可以用于测试等于（&#x3D;）、不等于（&lt;&gt;）等。</p><h2><span id="作为计算字段使用子查询">作为计算字段使用子查询</span></h2><blockquote><p><strong>相关子查询（correlated subquery）:</strong> 涉及外部查询的子查询。</p></blockquote><p>假如需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。<br>为了执行这个操作，遵循下面的步骤。<br>(1) 从customers表中检索客户列表。<br>(2) 对于检索出的每个客户，统计其在orders表中的订单数目。</p><pre><code class="sql">SELECT cust_name,cust state,(SELECT COUNT(*FROM ordersWHERE orders.cust_id =  customers.cust_id) As ordersFROM customersORDER BY cust_name;</code></pre><h1><span id="第15章-联结表">第15章 联结表</span></h1><blockquote><p>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p></blockquote><blockquote><p><strong>外键（foreign key）：</strong> 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系</p></blockquote><blockquote><p><strong>可伸缩性（scale）：</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。</p></blockquote><h2><span id="创建联结">创建联结</span></h2><pre><code class="sql">SELECT vend_name,prod_name,prod_priceFROM vendors,productsWHERE vendors.vend_id products.vend_idORDER BY vend_name,prod_name;</code></pre><p>表名.列名这种方式是完全限定列名，如果不这样做，而向下面的方式来匹配会造成笛卡儿积的情况</p><pre><code class="sql">SELECT vend_name,prod_name,prod_priceFROM vendors,productsWHERE vend_id = vend_idORDER BY vend_name,prod_name;</code></pre><p><strong>笛卡儿积（cartesian product）</strong> </p><blockquote><p>由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数</p></blockquote><h3><span id="不要忘了where子句"><strong>不要忘了WHERE子句</strong></span></h3><blockquote><p>&#x3D;&#x3D;应该保证所有联结都有WHERE子句，&#x3D;&#x3D;否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。</p></blockquote><blockquote><p>叉联结 ：有时我们会听到返回称为叉联结（cross join）的笛卡儿积的联结类型。</p></blockquote><h3><span id="内部联结">内部联结</span></h3><blockquote><p>上述的联结都是<strong>等值联结（equijoin）</strong>，它基于两个表之间的相等测试，这种联结也称为<strong>内部联结</strong></p></blockquote><p>还有另外一种语法：</p><pre><code class="sql">SELECT vend_name,prod_name,prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id;</code></pre><blockquote><p>此语句中的SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE<br>子句给出。传递给ON的实际条件与传递给WHERE的相同。</p></blockquote><p>一般建议使用这种语法.</p><h3><span id="联结多个表">联结多个表</span></h3><blockquote><p>SQL对一条SELECT语句中可以联结的表的数目没有限制</p></blockquote><p>具体的内容参照<code>15.2.3联结多个表</code></p><h1><span id="第16章-创建高级联结">第16章 创建高级联结</span></h1><h2><span id="使用表别名">使用表别名</span></h2><blockquote><p>表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、ORDER BY子句以及语句的其他部分。</p></blockquote><blockquote><p>应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p></blockquote><h2><span id="使用不同类型的联结">使用不同类型的联结</span></h2><p>迄今为止，我们使用的只是称为<strong>内部联结或等值联结（equijoin）的简单联结</strong>。还有3种其他联结，它们分别是<strong>自联结、自然联结和外部联结。</strong></p><h3><span id="自联结">自联结</span></h3><p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。<br>方法一：子查询</p><pre><code class="sql">SELECT prod_id,prod_nameFROM productsWHERE vend_id (SELECT vend idFROM productsWHERE prod_id =&#39;DTNTR&#39;);</code></pre><p>方法二：自联结</p><pre><code class="sql">SELECT p1.prod_id,p1.prod_nameFROM products As p1,products As p2WHERE p1.vend_id p2.vend_idAND p2.prod_id = &#39;DTNTR&#39;;</code></pre><p><strong>用自联结而不用子查询</strong></p><blockquote><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p></blockquote><h3><span id="自然联结">自然联结</span></h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。&#x3D;&#x3D;自然联结排除多次出现，使每个列只返回一次。&#x3D;&#x3D;</p><p><em><strong>怎样完成这项工作呢？</strong></em></p><p>答案是，系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。下面举一个例子：</p><pre><code class="sql">SELECT C.*o.order_num,o.order_date,oi.prod_id,oi.quantity,OI.item_priceFROM customers AS c,orders As o,orderitems AS oiWHERE C.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id &#39;FB&#39;;</code></pre><p>在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p><blockquote><p>迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结</p></blockquote><h3><span id="x3dx3d外部联结x3dx3d">&#x3D;&#x3D;外部联结&#x3D;&#x3D;</span></h3><blockquote><p>&#x3D;&#x3D;联结包含了那些在相关表中没有关联行的行。&#x3D;&#x3D;这种类型的联结称为外部联结。</p></blockquote><p><strong>相较于内连接(INNER JOIN)的区别：</strong></p><p>内连接：（A和B连接，AB两张表没有主次关系。平等的。）</p><p>外连接：通过LEFT和RIGHT指定哪个表的地位高，如果是LEFT，按照LEFT中的字段和右边表进行匹配，即使没有关联的行也会匹配。</p><p>例如：</p><pre><code>+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+</code></pre><p><strong>思考：外连接的查询结果条数一定是 &gt;&#x3D; 内连接的查询结果条数？</strong><br><strong>正确。</strong></p><p>案例：查询每个员工的上级领导，要求显示所有员工的名字和领导名？</p><pre><code class="sql">select a.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;from emp aleft join emp bon a.mgr = b.empno; 结果：+--------+--------+| 员工名      | 领导名     |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || KING   | NULL   |//[1]| TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+</code></pre><p><code>[1]:</code>可以看到即使KING没有领导，也会被匹配到,这种情况是以员工表a作为主表进行参照的，它的地位大于领导表b。</p><h2><span id="使用带聚集函数的联结">使用带聚集函数的联结</span></h2><p>如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT()函数的代码可完成此工作：</p><pre><code class="sql">SELECT customers.cust name,customers.cust_id,COUNT(orders.order_num) AS num_ordFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id;</code></pre><p>此SELECT语句使用INNER JOIN将customers和orders表互相关联。GROUP BY 子句按客户分组数据， 因此， 函数调用COUNT(orders.order_num)对每个客户的订单计数，将它作为num_ord返回</p><pre><code class="sql">SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num)AS num_ordFROM customers LEFT OUTER JOIN ordersON customers.cust_id=orders.cust_idGROUP BY customers.cust_id;</code></pre><p>这个例子使用左外部联结来包含所有客户，甚至包含那些没有任何下订单的客户。结果显示也包含了客户Mouse House，它有0个订单。</p><h2><span id="使用联结和联结条件">使用联结和联结条件</span></h2><p>在总结关于联结的这两章前，有必要汇总一下关于联结及其使用的<br>某些要点。</p><ul><li>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</li><li>保证使用正确的联结条件，否则将返回不正确的数据。</li><li>应该总是提供联结条件，否则会得出笛卡儿积。</li><li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li></ul><h1><span id="第17章-组合查询">第17章 组合查询</span></h1><h2><span id="组合查询">组合查询</span></h2><blockquote><p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）</p></blockquote><p>有两种基本情况，其中需要使用组合查询：</p><ul><li>在单个查询中从不同的表返回类似结构的数据；</li><li>对单个表执行多个查询，按单个查询返回数据。</li></ul><p><strong>组合查询和多个WHERE条件</strong></p><blockquote><p>多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，&#x3D;&#x3D;任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出&#x3D;&#x3D;，在以下段落中可以看到这一点。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好组合查询和多个WHERE条件 多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出，在以下段落中可以看到这一点。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好</p></blockquote><h2><span id="创建组合查询">创建组合查询</span></h2><h3><span id="使用union">使用UNION</span></h3><p>UNION的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。</p><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;5;</code></pre><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN (1001,1002);</code></pre><p>第一条SELECT检索价格不高于5的所有物品。第二条SELECT使用IN找出供应商1001和1002生产的所有物品。</p><p>组合后的语句：</p><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;=5UNIONSELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN (1001,1002);</code></pre><p>等价于：</p><pre><code class="sql">SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;=5OR vend_id IN(1001,1002); //注意这里是OR</code></pre><h3><span id="union规则">UNION规则</span></h3><ul><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个<br>  UNION关键字）。</li><li>UNION中的每个查询&#x3D;&#x3D;必须包含相同的列、表达式或聚集函数&#x3D;&#x3D;（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。<br>  如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。</li></ul><h3><span id="包含或取消重复的行">包含或取消重复的行</span></h3><p>前面的案例中第一条SELECT语句的查询结果有一条和第二个SELECT语句重复了但在UNION两条语句后过滤掉了，这种场合下如果想返回所有匹配行(重复出现的行)，可使用UNION ALL而不是UNION</p><p><strong>UNION与WHERE</strong> </p><blockquote><p>本章开始时说过，UNION几乎总是完成与多个WHERE条件相同的工作。UNION ALL为UNION的一种形式，它完成WHERE子句完成不了的工作。<strong>如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用UNION ALL而不是WHERE。</strong></p></blockquote><h3><span id="对组合查询结果排序">对组合查询结果排序</span></h3><blockquote><p>SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，<strong>它必须出现在最后一条SELECT语句之后</strong>。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此<strong>不允许使用多条ORDER BY子句。</strong></p></blockquote><p><strong>组合不同的表</strong></p><blockquote><p>为使表述比较简单，本章例子中的组合查询使用的均是相同的表。但是其中使用UNION的组合查询可以应用不同的表，但请检查UNION的第二条规则，只有在两个表包含一样的列才可以这样做。</p></blockquote><h1><span id="第19章-插入数据">第19章 插入数据</span></h1><p>INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：</p><ul><li>插入完整的行；</li><li>插入行的一部分；</li><li>插入多行；</li><li>插入某些查询的结果</li></ul><h2><span id="插入完整的行">插入完整的行</span></h2><pre><code class="sql">INSERT INTO CustomersVALUES (NULL,&#39;Pep E.LaPew&#39;,&#39;100 Main Street&#39;,&#39;Los Angeles&#39;,&#39;CA,&#39;90046&#39;,&#39;USA&#39;,NULL,NULL);</code></pre><blockquote><p><strong>没有输出：</strong> INSERT语句一般不会产生输出。</p></blockquote><ul><li><p>对每个列必须提供一个值。如果某个列没有值（如上面的cust_contact和cust_email列），应该使用NULL值（假定表允许对该列指定空值）。</p></li><li><p>各个列必须以它们在表定义中出现的次序填充。</p></li><li><p>第一列cust_id也为NULL。这是因为每次插入一个新行时，该列由MySQL自动增量。你不想给出一个值（这是MySQL的工作），又不能省略此列（如前所述，必须给出每个列），所以指定一个NULL值（它被MySQL忽略，MySQL在这里插入下一个可用的cust_id值）。</p></li></ul><blockquote><p><strong>这种语法很简单，但并不安全，应该尽量避免使用</strong></p></blockquote><p><strong>总是使用列的列表</strong></p><blockquote><p>一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化</p></blockquote><p><strong>仔细地给出值</strong> </p><blockquote><p>不管使用哪种INSERT语法，都必须给出VALUES的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功</p></blockquote><p>使用这种语法，还可以省略列。这表示可以只给某些列提供值，给其他列不提供值</p><p>省略的列必须满足以下某个条件。</p><ul><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值</li></ul><p>如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级</p><pre><code class="sql">INSERT LOW_PRIORITY INTO</code></pre><p>这也适用于下一章介绍的UPDATE和DELETE语句</p><h2><span id="插入多个行">插入多个行</span></h2><pre><code class="sql">INSERT INTO customers (cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&#39;Pep E.LaPew&#39;,&#39;100 Main Street&#39;,&#39;Los Angeles&#39;,&#39;CA&#39;,190046,&#39;USA&#39;);INSERT INTO customers (cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&#39;M.Martian&#39;,&#39;42 Galaxy Way&#39;,&#39;New York&#39;,&#39;NY&#39;,11213&#39;,&#39;USA);</code></pre><p>只要每条INSERT语句中的列名（和次序）相同，可以如下组合各语句：</p><pre><code class="sql">INSERT INTO customers (cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&#39;Pep E.LaPew&#39;,&#39;100 Main Street&#39;,&#39;Los Angeles&#39;,&#39;CA&#39;,90046&#39;,USA),(&#39;M.Martian&#39;,42 Galaxy Way&#39;,New York&#39;,&#39;NY&#39;11213&#39;,&#39;USA);</code></pre><p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔</p><p><strong>提高INSERT的性能</strong></p><blockquote><p>此技术可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。</p></blockquote><h2><span id="插入检索出的数据">插入检索出的数据</span></h2><blockquote><p>INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中</p></blockquote><p>&#x3D;&#x3D;注意，被插入的表结构必须和被检索的表的表结构一致，同时在填充这个新表时不能使用被检索表中的主键值，这样主键值会重复导致后续的插入会失败。&#x3D;&#x3D;可以在检索的列中仅省略这列值（从INSERT和SELECT中,两个都省略））让MySQL在导入数据的过程中产生新值。</p><pre><code class="sql">INSERT INTO customers(cust_id,    cust contact,    cust_email,    cust_name,    cust address,    cust_city,    cust_state,    cust_zip,    cust_country)SELECT cust_id,    cust_contact,    cust_email,    cust name,    cust_address,    cust_city,    cust_state,    cust_zip,    cust countryFROM custnew;</code></pre><h1><span id="第20章-更新和删除数据">第20章 更新和删除数据</span></h1><h2><span id="更新数据">更新数据</span></h2><p>为了更新（修改）表中的数据，可使用UPDATE语句。可采用两种方式使用UPDATE：</p><ul><li>更新表中特定行；</li><li>更新表中所有行。</li></ul><p><strong>不要省略WHERE子句</strong> </p><blockquote><p>在使用UPDATE时一定要注意细心。因为稍不注意，就会更新表中所有行</p></blockquote><p>UPDATE语句由3部分组成</p><ul><li><p>要更新的表；</p></li><li><p>列名和它们的新值</p></li><li><p>确定要更新行的过滤条件。</p></li></ul><p>更新单个列</p><pre><code class="sql">UPDATE customersSET cust_name &#39;The Fudds&#39;WHERE custid 10005;</code></pre><p>更新多个列，使用<code>,</code>分隔：</p><pre><code class="sql">UPDATE customersSET cust_name &#39;The Fudds&#39;,cust_email &#39;elmer@fudd.com&#39;WHERE custid 10005;</code></pre><p><strong>在UPDATE语句中使用子查询</strong> </p><blockquote><p>UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</p></blockquote><p><strong>IGNORE关键字</strong></p><blockquote><p>**&#x3D;&#x3D;如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消&#x3D;&#x3D;**（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：UPDATE IGNORE customers…</p></blockquote><p>&#x3D;&#x3D;为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）&#x3D;&#x3D;。如下进行：</p><pre><code class="sql">UPDATE customersSET cust_email=NULLWHERE cust_id = 10005;</code></pre><h2><span id="删除数据">删除数据</span></h2><p>为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方式使用DELETE：</p><ul><li>从表中删除特定的行；</li><li>从表中删除所有行</li></ul><p><strong>不要省略WHERE子句</strong> </p><blockquote><p>在使用DELETE时一定要注意细心。因为稍不注意，就会错误地删除表中所有行,这一点和UPDATE语句一样</p></blockquote><p>删除一行数据：</p><pre><code class="sql">DELETE FROM customersWHERE cust_id = 10006;</code></pre><p>删除所有数据：</p><pre><code class="sql">DELETE FROM customers;</code></pre><blockquote><p>DELETE不需要列名或通配符。DELETE删除整行而不是删除列。&#x3D;&#x3D;为了删除指定的列，请使用UPDATE语句。&#x3D;&#x3D;</p></blockquote><p><strong>删除表的内容而不是表</strong> </p><blockquote><p>DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身,删除表的语句为drop table 表名；</p></blockquote><p><strong>更快的删除</strong> </p><blockquote><p>如果想从表中删除所有行，不要使用DELETE。可使用<code>TRUNCATE TABLE</code>语句，它完成相同的工作，但速度更快（<strong>TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据</strong>）**,但delete删除可以回滚数据，Truncate则不行。**</p></blockquote><h2><span id="更新和删除的指导原则">更新和删除的指导原则</span></h2><p>MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。</p><h1><span id="第21章-创建和操纵表">第21章 创建和操纵表</span></h1><h2><span id="创建表">创建表</span></h2><pre><code class="sql">CREATE TABLE customers(cust_id  int NOT NULL AUTO INCREMENT,cust_name char(50) NOT NULL,cust_address char(50) NULL,cust_city  char(50) NULL,cust_state   char(5) NULL,cust_zip     char(10) NULL,cust_country char(50) NULL,cust_contact char(50) NULL,cust_email   char(255) NULL,PRIMARY KEY (cust id))ENGINE=InnoDB;</code></pre><p><strong>处理现有的表</strong> </p><blockquote><p>在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。如果你仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS。这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。&#x3D;&#x3D;如果表存在就<code>drop table if exists 表名;</code>&#x3D;&#x3D;</p></blockquote><h3><span id="使用null值">使用NULL值</span></h3><ul><li><p>允许NULL值的列也允许在插入行时不给出该列的值。</p></li><li><p>不允许NULL值的列不接受该列没有值的行，换句话说，<strong>在插入或更新行时，该列必须有值，如果该列没有值将返回错误，且插入失败</strong></p></li><li><p>如果创建表不指定NOT NULL，则认为指定的是NULL。</p></li></ul><p><strong>理解NULL</strong> </p><blockquote><p>不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定</p></blockquote><h3><span id="主键再介绍复合主键">主键再介绍(复合主键)</span></h3><ul><li><p>主键值必须唯一。即表中的每个行必须具有唯一的主键值。</p></li><li><p>如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一，叫做<strong>复合主键</strong></p></li></ul><p>复合主键的添加：为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名</p><pre><code class="sql">CREATE TABLE orderitems(order_num int NOT NULL,order_item int NOT NULLprod_id char(10) NOT NULLquantity int NOT NULLitem_price decimal(8,2) NOT NULL,PRIMARY KEY (order_num,order_item))ENGINE=InnoDB;</code></pre><p>orderitems表包含orders表中每个订单的细节。每个订单有多项物品，但每个订单任何时候都只有1个第一项物品，1个第二项物品，如此等等。因此，订单号（order_num列）和订单物品（order_item列）的组合是唯一的，从而适合作为主键，其定义为：</p><p><code>PRIMARY KEY (order_num,order_item)</code></p><blockquote><p>主键可以在创建表时定义（如这里所示），或者在创建表之后定义</p></blockquote><p><strong>主键和NULL值</strong> </p><blockquote><p>第1章介绍过，主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识</p></blockquote><h3><span id="使用auto_increment">使用AUTO_INCREMENT</span></h3><pre><code class="sql">cust_id int NOT NULL AUTO INCREMENT,</code></pre><p>AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTO_INCREMENT），&#x3D;&#x3D;每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。&#x3D;&#x3D;</p><p><strong>覆盖AUTO_INCREMENT</strong></p><blockquote><p>如果一个列被指定为AUTO_INCREMENT，则它需要使用特殊的值吗？你可以简单地在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将开始使用该手工插入的值，从插入的值开始增。</p></blockquote><p><strong>确定AUTO_INCREMENT值</strong> </p><blockquote><p>让MySQL生成（通过自动增量）主键的一个缺点是你不知道这些值都是谁。</p></blockquote><p>案例：考虑这个场景：你正在增加一个新订单。这要求在orders表中创建一行，然后在orderitms表中对订购的每项物品创建一<br>行。order_num在orderitems表中与订单细节一起存储。这就是为什么orders表和orderitems表为相互关联的表的原因。这显然要求你在插入orders行之后，插入orderitems行之前知道生成的order_num（就是在orders表中最后行插入的主键值）。</p><p>可使用last_insert_id()函数获得这个值，如下所示：</p><p><code>SELECT last_insert_id()</code>,此语句返回最后一个AUTO_INCREMENT值（<strong>针对最近插入的那个表</strong>），然后可以将它用于后续的MySQL语句</p><h3><span id="指定默认值">指定默认值</span></h3><p>默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定</p><pre><code class="sql">CREATE TABLE orderitemsorder_num int NOT NULL,order_item int NOT NULLprod_id char(10) NOT NULL,quantity int NOT NULL DEFAULT 1,item_price decimal(8,2)  NOT NULLPRIMARY KEY (order_num,order_item)ENGINE=InnoDB:</code></pre><p><strong>不允许函数</strong> </p><blockquote><p>与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量</p></blockquote><p><strong>使用默认值而不是NULL值</strong> </p><blockquote><p>许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。</p></blockquote><h2><span id="x3dx3d更新表x3dx3d">&#x3D;&#x3D;更新表&#x3D;&#x3D;</span></h2><blockquote><p>为更新表定义，可使用ALTER TABLE语句。但是，理想状态下，&#x3D;&#x3D;当表中存储数据以后，该表就不应该再被更新&#x3D;&#x3D;</p></blockquote><p>下面的例子给表添加一个列:</p><pre><code class="sql">ALTER TABLE vendorsADD vend_phone CHAR(20);</code></pre><p>这条语句给vendors表增加一个名为vend_phone的列，&#x3D;&#x3D;必须明确其数据类型。&#x3D;&#x3D;</p><p>删除刚刚添加的列：</p><pre><code class="sql">ALTER TABLE VendorsDROP COLUMN vend_phone;</code></pre><p>ALTER TABLE的一种常见用途是定义外键。下面是用来表所用的外键的代码：</p><pre><code class="sql">ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num)REFERENCES orders (order_num);ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);ALTER TABLE ordersADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);ALTER TABLE productsADD CONSTRAINT fk_products_vendorsFOREIGN KEY (vend_id)REFERENCES vendors (vend_id);</code></pre><p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p><ul><li><p>用新的列布局创建一个新表；</p></li><li><p>使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅第19章）从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；</p></li><li><p>检验包含所需数据的新表；</p></li><li><p>重命名旧表（如果确定，可以删除它）；</p></li><li><p>用旧表原来的名字重命名新表；</p></li><li><p>根据需要，重新创建触发器、存储过程、索引和外键。</p></li></ul><p><strong>小心使用ALTER TABLE</strong> </p><blockquote><p>使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。&#x3D;&#x3D;数据库表的更改不能撤销&#x3D;&#x3D;，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p></blockquote><h2><span id="删除表">删除表</span></h2><p>删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语句即可：</p><pre><code class="sql">DROP TABLE customers2;</code></pre><p>这条语句删除customers 2表（假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。</p><h2><span id="重命名表">重命名表</span></h2><p>使用RENAME TABLE语句可以重命名一个表：</p><pre><code class="sql">RENAME TABLE customers2 TO customers;</code></pre><p>对多个表重命名：</p><pre><code class="sql">RENAME TABLE backup_customers TO customers            backup_vendors TO vendors,            backup_products TO products;</code></pre><h1><span id="第22章-使用视图">第22章 使用视图</span></h1><blockquote><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p></blockquote><h2><span id="为什么使用视图">为什么使用视图?</span></h2><ul><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><blockquote><p>视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。<br>在添加或更改这些表中的数据时，视图将返回改变过的数据。</p></blockquote><p><strong>性能问题</strong></p><blockquote><p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p></blockquote><h3><span id="视图的规则和限制">视图的规则和限制</span></h3><ul><li>与表一样，视图必须&#x3D;&#x3D;唯一命名&#x3D;&#x3D;（&#x3D;&#x3D;不能给视图取与别的视图或表相同的名字&#x3D;&#x3D;）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该<u>视图中ORDER BY将被覆盖。</u></li><li>&#x3D;&#x3D;视图不能索引，也不能有关联的触发器或默认值&#x3D;&#x3D;</li><li>&#x3D;&#x3D;视图可以和表一起使用&#x3D;&#x3D;。例如，编写一条联结表和视图的SELECT语句。</li></ul><h2><span id="使用视图">使用视图</span></h2><ul><li><p>视图用CREATE VIEW语句来创建。</p></li><li><p>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</p></li><li><p>用DROP删除视图，其语法为DROP VIEW viewname;。</p></li><li><p>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</p></li></ul><pre><code class="sql">CREATE VIEW productcustomers ASSELECT cust_name,cust_contact,prod_idFROM customers,orders,orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_num;</code></pre><p>使用这个视图：</p><pre><code class="sql">SELECT cust_name,cust_contactFROM productcustomersWHERE prod_id &#39;TNT2&#39;;</code></pre><p><strong>WHERE子句与WHERE子句</strong> </p><blockquote><p>如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p></blockquote><h2><span id="x3dx3d更新视图x3dx3d">&#x3D;&#x3D;更新视图&#x3D;&#x3D;</span></h2><p>视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。<strong>如果你对视图增加或删除行，实际上是对其基表增加或删除行。</strong></p><p>&#x3D;&#x3D;如果视图定义中有以下操作，则不能进行视图的更新：&#x3D;&#x3D;</p><ol><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；(查询结果当作where子句条件)</li><li>并；(union,union all)</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ol><p><strong>将视图用于检索</strong> </p><blockquote><p>一般，应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。</p></blockquote><pre><code class="sql">DROP VIEW if EXISTS emp_view;CREATE VIEW emp_view  as SELECT emp.*,dept.DNAME,dept.LOCFROM empJOIN depton emp.DEPTNO=dept.DEPTNO;#案例1：INSERT INTO emp_view(EMPNO,ENAME,JOB)VALUES(1000,&#39;王五&#39;,&#39;SALESMAN&#39;);UPDATE emp_view set DEPTNO=20,MGR=7499 WHERE ENAME=&#39;王五&#39; //不报错，但不起作用DELETE FROM emp_view WHERE ENAME=&#39;王五&#39;;//执行失败#案例2：INSERT INTO emp_view(EMPNO,ENAME,DEPTNO)VALUES(2000,&#39;张三&#39;,20);UPDATE emp_view set Job=&#39;SALESMAN&#39; WHERE ENAME=&#39;张三&#39;;//不报错，起作用DELETE FROM emp_view WHERE ENAME=&#39;王五&#39;;//执行失败,因为涉及多个表，delete失败。</code></pre><p>这里实测了一下，插入成功，但是只在emp表中看到了这个数据，在视图中没有，并且执行update无变化，delete会报错，是因为在插入的时候没有指定它的deptno，因此在不满足视图中的语句，所以无法更新和删除。张三这条数据就正常更新了，但还是不能删除，&#x3D;&#x3D;因为对依赖于多个基本表的视图，不能使用DELETE语句。&#x3D;&#x3D;</p><h1><span id="x3dx3d第23章-使用存储过程函数x3dx3d">&#x3D;&#x3D;第23章 使用存储过程(函数)&#x3D;&#x3D;</span></h1><blockquote><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p></blockquote><ul><li>通过把处理封装在容易使用的单元中，简化复杂的操作（正如前<br>  面例子所述）。</li><li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过<br>  程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li><li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要<br>  知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</li><li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li><li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可<br>  以看到。）</li></ul><blockquote><p>简而言之：使用存储过程有3个主要的好处，即&#x3D;&#x3D;简单、安全、高性能。&#x3D;&#x3D;</p></blockquote><h2><span id="使用存储过程">使用存储过程</span></h2><pre><code class="sql">CALL productpricing(apricelow,                    @pricehigh,                    @priceaverage);</code></pre><blockquote><p>执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格</p></blockquote><blockquote><p>存储过程可以显示结果，也可以不显示结果</p></blockquote><ul><li>创建存储过程：</li></ul><pre><code class="sql">CREATE PROCEDURE productpricing(BEGINSELECT Avg(prod_price) AS priceaverageFROM products;END;</code></pre><p>此存储过程名为productpricing，如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。BEGIN和END语句用来限定存储过程体，<strong>过程体</strong>本身仅是一个简单的SELECT语句。</p><p><strong>&#x3D;&#x3D;mysql命令行客户机的分隔符(就是在CMD窗口运行的mysql)&#x3D;&#x3D;</strong> </p><blockquote><p>默认的MySQL语句分隔符为;（mysql命令行实用程序也使用;作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。解决办法是临时更改命令行实用程序的语句分隔符，如下所示：其中，DELIMITER &#x2F;&#x2F;告诉命令行实用程序使用&#x2F;&#x2F;作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为END&#x2F;&#x2F;而不是END;。这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符可使用DELIMITER ;。除\符号外，任何字符都可以用作语句分隔符。如果你使用的是mysql命令行实用程序，在阅读本章时请记住这里的内容。</p></blockquote><ul><li>使用存储过程：</li></ul><pre><code class="sql">CALL productpricing();</code></pre><p>因为存储过程实际上是一种函数，所以存储过程名后需要有()符号（即使不传递参数也需要）。</p><h3><span id="删除存储过程">删除存储过程</span></h3><pre><code class="sql">DROP PROCEDURE productpricing;//注意后面没有括号</code></pre><p><strong>仅当存在时删除</strong> </p><blockquote><p>如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。</p></blockquote><pre><code class="sql">DROP procedure if EXISTS f1;//如果存在f1函数就删除它类似用法：DROP table if EXISTS t1;DROP view if EXISTS v1;</code></pre><h3><span id="使用参数">使用参数</span></h3><p>存储过程并不显示结果，而是把结果返回给你指定的变量。</p><blockquote><p><strong>变量（variable）</strong>:内存中一个特定的位置，用来临时存储数据</p></blockquote><ul><li>使用OUT参数：</li></ul><pre><code class="sql">CREATE PROCEDURE productpricing(    OUT p1 DECIMAL(8,2),    OUT ph DECIMAL(8,2),    OUT pa DECIMAL(8,2))BEGINSELECT Min(prod_price)//注意INTO的位置INTO plFROM products;SELECT Max(prod_price)INTO phFROM products;SELECT Avg(prod_price)INTO paFROM products;END;</code></pre><p>此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。</p><p><strong>参数的数据类型</strong> </p><blockquote><p>存储过程的参数允许的数据类型与表中使用的数据类型相同。附录D列出了这些类型。&#x3D;&#x3D;注意，记录集不是允许的类型，因此，不能通过一个参数返回多个行和列&#x3D;&#x3D;。这就是前面的例子为什么要使用3个参数（和3条SELECT语句）的原因。</p></blockquote><pre><code class="sql">CALL productpricing (apricelow,                    @pricehigh,                    @priceaverage);</code></pre><p>这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。</p><blockquote><p><strong>变量名 ：</strong>所有MySQL变量都必须以@开始。</p></blockquote><ul><li>根据变量检索：</li></ul><pre><code class="sql">SELECT @priceaverage;</code></pre><pre><code class="sql">SELECT @pricehigh,@pricelow,@priceaverage;</code></pre><ul><li>同时使用OUT和IN参数：</li></ul><pre><code class="sql">CREATE PROCEDURE ordertotal(IN onumber INT,OUT ototal DECIMAL(8,2))BEGINSELECT Sum(item_price*quantity)FROM orderitemsWHERE order num = onumberINTO ototal;END;</code></pre><p>onumber定义为IN，因为订单号被传入存储过程。ototal定义为OUT，因为要从存储过程返回合计。SELECT语句使用这两个参数，WHERE子句使用onumber选择正确的行，INTO使用ototal存储计算出来的合计</p><pre><code class="sql">CALL ordertotal(20005,@total);//第一个是传入的值，第二个是接收返回的值</code></pre><p>第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。</p><p>为了得到另一个订单的合计显示，需要再次调用存储过程，然后重新显示变量，&#x3D;&#x3D;这样会覆盖原来total的值。&#x3D;&#x3D;</p><pre><code class="sql">CALL ordertotal(20009,@total);SELECT @total;//它的值改变为20009订单号对应的</code></pre><h3><span id="建立智能存储过程">建立智能存储过程</span></h3><blockquote><p>参照原书</p></blockquote><h3><span id="检查存储过程">检查存储过程</span></h3><blockquote><p>为显示用来创建一个存储过程的CREATE语句，使用<code>SHOW CREATE PROCEDURE</code>语句：</p></blockquote><pre><code class="sql">SHOW CREATE PROCEDURE ordertotal;</code></pre><blockquote><p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE  STATUS。</code></p></blockquote><p><strong>限制过程状态结果</strong> </p><blockquote><p>SHOW PROCEDURE STATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，例如：</p></blockquote><pre><code class="sql">SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;;</code></pre><h1><span id="拓展">拓展</span></h1><h2><span id="mysql数据类型">Mysql数据类型</span></h2><h3><span id="int类型">int类型</span></h3><p>int(10)表示的是无符号的整型数，而int(11)代表有符号的整型(前面一位用来表示符号)，这一点和其他的类型有区别。</p><p>相当于加了unsigned关键字设置为无符号。</p><h3><span id="char类型">char类型</span></h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2024/02/04/java/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E5%9F%BA%E7%A1%80)/"/>
      <url>/2024/02/04/java/6%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="6-面向对象编程基础">6 面向对象编程（基础）</span></h1><blockquote><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写</p></blockquote><h2><span id="61-类与对象">6.1 类与对象</span></h2><blockquote><p>从 类 到 对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者 把对象实例化</p><ol><li>类 是抽象的、概念的，代表一类事物</li><li>对象 是具体的、实际的，代表一个个具体事物</li><li>类 是 对象 的模板，对象 是 类 的一个个体，对应一个实例</li></ol></blockquote><h3><span id="611-属性x2f成员变量">6.1.1 属性&#x2F;成员变量</span></h3><blockquote><p>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; field（字段）</p></blockquote><pre><code class="java">class Cat&#123;    String name;    int age;&#125;</code></pre><h3><span id="612-创建对象">6.1.2 创建对象</span></h3><p>注意事项：</p><ol><li><p>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。</p><p> 对象的引用，也被称为对象的句柄。</p></li><li><p>使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用</p></li></ol><h3><span id="x3dx3d613-类与对象的内存访问机制x3dx3d">&#x3D;&#x3D;6.1.3 类与对象的内存访问机制&#x3D;&#x3D;</span></h3><blockquote><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如<code>Cat cat1 = new Cat()</code>，是在这里开辟的空间），所有的java对象都存储在堆中。</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><ol><li>创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈 中的对象名被赋予指向那个空间的地址。</li><li>之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在 堆 中；是 字符串 的记录一个地址，该地址指向 方法区，那里的常量池有该字符串。</li></ol><h2><span id="62-成员方法">6.2 成员方法</span></h2><blockquote><p>使用 成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</p></blockquote><h3><span id="x3dx3d621-方法的调用机制x3dx3d">&#x3D;&#x3D;6.2.1 方法的调用机制&#x3D;&#x3D;</span></h3><p>以前文代码为例：</p><pre><code class="java">...        int r = cat1.speak2(15, 135);...public int speak2(int n1, int n2)&#123;   int res = n1 + n2;   return res;&#125;...</code></pre><ol><li>当程序执行到方法时，在 栈 中开辟一个新的 栈空间。该空间里储存 <code>n1 = 15</code> <code>n2 = 135</code>，之后计算并储存结果 <code>res = 150</code></li><li>当方法执行完毕，或执行到 <code>return</code> 语句时，就会返回</li><li>把 新栈空间 中的 <code>res = 150</code> 返回 main栈 中调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li></ol><h3><span id="622-使用细节">6.2.2 使用细节</span></h3><ol><li>调用细节：<ul><li>同一个类中的方法调用，可以直接调用。</li><li>跨类的方法调用，需要创建新对象，然后再调用方法。</li></ul></li></ol><h3><span id="x3dx3d623-成员方法传参机制x3dx3d">&#x3D;&#x3D;6.2.3 成员方法传参机制&#x3D;&#x3D;</span></h3><p>&#x3D;&#x3D;Java 语言对对象采用的是 <strong>值传递</strong>，方法得到的总是那个传入对象的副本。&#x3D;&#x3D;</p><p>方法参数共有两种类型：</p><ol><li>基本数据类型（数字、布尔值)</li><li>对象引用。</li></ol><ul><li><p>&#x3D;&#x3D;方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参&#x3D;&#x3D;。</p></li><li><p>&#x3D;&#x3D;方法可以改变对象参数的状态。&#x3D;&#x3D;</p><p>  引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>  但改变那个形参地址指向的场合，实参的指向不会改变</p></li></ul><blockquote><p>java核心技术卷一：</p><p>4.5 方法参数</p><p>&#x3D;&#x3D;按值调用&#x3D;&#x3D;表示方法接收的是调用者提供的值。而按引用调用表示方法接受的是调用者提供的变量地址，一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</p><p>java程序设计语言总是采用按值调用，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p><pre><code class="java">double percent = 10;harry.raiseSalary(percent):不必理睬这个方法的具体实现， 在方法调用之后， percent 的值还是10。</code></pre><p>但作将对象应用作为参数就不一样了。<br>拷贝的是对象的引用变量而不是整个对象，拷贝的和原来的引用指向同一个对象，可以理解为拷贝的对象引用是它的别名，实质指的是一个东西。可以通过这个别名引用来改变原对象。</p><p>总结一下Java 中方法参数的使用情况：</p><p>&#x3D;&#x3D;一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。&#x3D;&#x3D;<br>&#x3D;&#x3D;一个方法可以改变一个对象参数的状态。&#x3D;&#x3D;<br>&#x3D;&#x3D;一个方法不能让对象参数引用一个新的对象。&#x3D;&#x3D;</p></blockquote><h2><span id="63-x3dx3d方法递归调用x3dx3d">6.3 &#x3D;&#x3D;方法递归调用&#x3D;&#x3D;</span></h2><blockquote><p>递归：即方法自己调用自己，每次调用时传入不同变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p></blockquote><blockquote><p>下面，示范一个斐波那契数列方法</p><pre><code class="java">&gt;class T&#123;   public int fib(int n)&#123;       if(n == 1 || n == 2)&#123;           return 1;       &#125;else&#123;           return (fib(n - 1)) + (feb(n - 2));       &#125;   &#125;&gt;&#125;</code></pre></blockquote><h3><span id="631-使用细节">6.3.1 使用细节</span></h3><ol><li>执行一个方法时，就创建一个新的受保护的独立 栈空间。</li><li>方法的局部变量是独立的，不会相互影响。</li><li>如果方法中使用的是引用变量，就会共享数据。（因为 [[6.2.3 成员方法传参机制]](<a href="https://i-melody.github.io/2021/11/29/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/6">https://i-melody.github.io/2021/11/29/Java/入门阶段/6</a> 面向对象编程（基础）&#x2F;#6-2-3-成员方法传参机制)）</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示 <code>StackOverflowError</code> “死龟”</li><li>当一个方法执行完毕，或遇到 <code>return</code> 就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕</li></ol><h2><span id="64-方法重载">6.4 方法重载</span></h2><p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求 形参列表 不一致。</p><h2><span id="x3dx3d65-可变参数x3dx3d">&#x3D;&#x3D;6.5 可变参数&#x3D;&#x3D;</span></h2><blockquote><p>Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p><pre><code class="java">public void m(int... n)&#123;    //此时，n 相当于一个 数组。    int length = n.length;    int num1 = n[0];&#125;</code></pre><h3><span id="651-使用细节">6.5.1 使用细节</span></h3><ol><li><p>可变参数 的实参可以是 0 个，也可以是 任意多 个。</p></li><li><p>可变参数 的实参可以是数组</p></li><li><p>可变参数 本质就是数组</p><p> 因此，出现：</p><pre><code class="java">public void met(int... n)&#123;//这个方法与下面的方法不能构成重载&#125;</code></pre><p> 的场合，不能有方法：</p><pre><code class="java">public void met(int[] n)&#123;//这个方法与上面的方法不能构成重载&#125;</code></pre></li><li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数 在最后</p><pre><code class="java">public void m(double dou, int... n) &#123;&#125;</code></pre></li><li><p>一个形参列表<u>最多出现 一个 可变参数。</u></p></li></ol><h2><span id="66-作用域">6.6 作用域</span></h2><ol><li>在 Java 编程中，主要的变量就是 <strong>属性（成员变量</strong>）和 <strong>局部变量。</strong></li><li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是 属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。&#x3D;&#x3D;局部变量必须赋值使用&#x3D;&#x3D;</li></ol><h3><span id="661-使用细节">6.6.1 使用细节</span></h3><ol><li><p>属性 和 局部变量 &#x3D;&#x3D;可以重名&#x3D;&#x3D;，访问时遵循&#x3D;&#x3D;就近原则&#x3D;&#x3D;</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>&#x3D;&#x3D;属性 的生命周期较长。其伴随对象的创建而创建，伴随<strong>对象</strong>的销毁而销毁。&#x3D;&#x3D;</p><p> &#x3D;&#x3D;局部变量 生命周期较短。其伴随代码块的执行而创建，伴随<strong>代码块</strong>的结束而销毁。&#x3D;&#x3D;</p></li><li><p>全局变量&#x2F;属性 可以被本类使用，&#x3D;&#x3D;也可以被其他类（通过对象）使用。&#x3D;&#x3D;</p><p> 局部变量 只能被本类的对应方法中调用</p></li><li><p>全局变量&#x2F;属性 <strong>可以加</strong> 修饰符</p><p> &#x3D;&#x3D;局部变量 <strong>不能加</strong> 修饰符&#x3D;&#x3D;</p></li></ol><h2><span id="67-构造方法-构造器">6.7 构造方法、构造器</span></h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化</p></blockquote><ol><li>构造器的修饰符可以是默认。也可以是别的</li><li>参数列表 规则同 成员方法</li></ol><h3><span id="671-使用细节">6.7.1 使用细节</span></h3><ol><li>构造器本质也是方法(并不会继承)。所以，可以 构造器重载。</li><li>构造器名 和 类名 相同</li><li>构造器无返回值</li><li>&#x3D;&#x3D;构造器是完成对象的初始化，而不是创建&#x3D;&#x3D;</li><li>&#x3D;&#x3D;创建对象时，系统<u>自动调用构造器</u>&#x3D;&#x3D;</li><li>如果提供了构造器，则不会提供默认构造器了。</li><li>&#x3D;&#x3D;一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器&#x3D;&#x3D;</li></ol><h3><span id="x3dx3d672-流程分析x3dx3d">&#x3D;&#x3D;6.7.2 流程分析&#x3D;&#x3D;</span></h3><pre><code class="java">Person p1 = new Person(&quot;Amy&quot;, 10);...    class Person&#123;    String name;    int age = 20;    public Person(String pName, int pAge)&#123;        name = pName;        age = pAge;    &#125;&#125;</code></pre><ol><li><p>加载 类信息（<strong>方法区</strong>）</p></li><li><p>在 <strong>堆</strong> 中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化。<code>age = 0; name = null</code></p></li><li><p>之后显式初始化。<code>age = 20; name = null</code>&#x2F;&#x2F;定义时的赋值</p><p>  其中，&#x3D;&#x3D;显式初始化和代码块初始化按编写的先后顺序依次进行&#x3D;&#x3D;。</p></li><li><p>之后构造器的初始化。<code>age = 10; name = &quot;Amy&quot;</code></p></li></ul></li><li><p>把对象在 堆 中的 地址，返回给 <code>p1</code></p></li></ol><h2><span id="x3dx3d68-this关键字x3dx3d">&#x3D;&#x3D;6.8 this关键字&#x3D;&#x3D;</span></h2><blockquote><p>JVM 会给每个对象分配 this 代表当前对象。</p><p>相当于在 堆 中，this 指向自己（对象）</p><p>在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。</p><p>遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p></blockquote><pre><code class="java">class Example&#123;    int n = 0;    public void act(int n) &#123;&#125;&#125;</code></pre><p>上面这个类的 <code>act()</code> 方法实际有 2 个参数。对其调用：</p><pre><code class="java">Example e = new Exmaple();e.act(100);</code></pre><p>可见，出现在方法名前的参数 <code>e</code>，以及出现在方法名后的括号中的参数 <code>100</code></p><p>&#x3D;&#x3D;出现在方法名前的参数被称为 <strong>隐式参数</strong>（也称为 方法调用的 目标 或 接收者）&#x3D;&#x3D;</p><p>&#x3D;&#x3D;出现在方法名后的参数被称为 <strong>显式参数</strong>，就是所谓的实参&#x3D;&#x3D;</p><p>在每一个方法中，用 <strong>this 指代隐式参数</strong>。</p><pre><code class="java">public void act(int n) &#123;    this.n = n;&#125;</code></pre><p>此时，再以相同方式调用方法：</p><pre><code class="java">e.act(100);// &lt;———— 相当于 e.n = 100;</code></pre><h3><span id="super-与-this-关键字"><code>super 与 this 关键字</code></span></h3><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p><p>this关键字：指向自己的引用。</p><blockquote><p>《java核心技术卷1》：5.1.3 子类构造器</p><ol><li><p>this 有两个用途： 一是引用隐式参数(&#x3D;&#x3D;所构造的对象&#x3D;&#x3D;)， 二是<u>调用该类其他的构造器</u></p></li><li><p>super 也有两个用途：一是调用超类的方法，二是调用超类的构造器。</p></li></ol><p>在调用构造器的时候， 这两个关键字的使用方式很相似。&#x3D;&#x3D;调用构造器的语句只能作为另一个构造器的第一条语句出现。&#x3D;&#x3D;&#x3D;&#x3D;构造参数既可以传递给本类(this ) 的其他构造器， 也可以传递给超类(super ) 的构造器。&#x3D;&#x3D;</p></blockquote><h3><span id="681-使用方法">6.8.1 使用方法</span></h3><ol><li><p><code>this</code> 关键字可以用来访问本类的属性、方法、构造器</p></li><li><p><code>this</code> 用于区分当前类的 属性 和 局部变量</p></li><li><p>访问本类中成员方法的语法：<code>this.方法名</code></p></li><li><p>访问构造器的语法：<code>this(参数列表);</code></p><p> 注意：&#x3D;&#x3D;只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中 使用&#x3D;&#x3D;</p></li></ol><h2><span id="附录">附录</span></h2><h3><span id="迷宫游戏代码">迷宫游戏代码</span></h3><pre><code class="java">/***@author Melody*@version v1.2.6**///迷宫import java.util.Scanner;public class MazeOut&#123;    public static void main(String[] args)&#123;        //tools 方便后面调用方法。 inP 可以接收用户输入        T tools = new T();        Scanner inP = new Scanner(System.in);                //提示并接收用户输入信息        System.out.println(&quot;\n输入迷宫宽度（至少为6）：&quot;);        int x = inP.nextInt();        System.out.println(&quot;\n输入迷宫长度（至少为6）：&quot;);        int y = inP.nextInt();          //若用户输入的长或宽超出范围，则将其重置为正常值        if(x &lt; 6)&#123;            x = 6;        &#125; else if(x &gt; 110)&#123;            x = 110;        &#125;        if(y &lt; 6)&#123;            y = 6;        &#125; else if(y &gt; 60)&#123;            y = 60;        &#125;        System.out.println(&quot;\n输入迷宫的困难度（请输入1 - 6的数字，数字越高越不容易获胜）：&quot;);        int hard = inP.nextInt();        if(hard == 7)&#123;            System.out.println(&quot;\n\n您选择了找点麻烦&quot;);        &#125; else if (hard == 8 || hard == 9)&#123;            System.out.println(&quot;\n\n您选择了给自己添堵&quot;);        &#125;        System.out.println(&quot;\n\t迷宫生产完毕\n&quot;);                //设置一个 count 值，记录步数。设为数组，以便数据通用。第一位记录当前值，第二位为最大值。        int[] count = &#123;0, 0&#125;;        //调用方法，生成迷宫        char[][] maze =new char[y][x];        tools.newMaze(maze.length, maze[0].length, maze, hard);        //调用方法，展示迷宫        tools.showMaze(maze);                //提示用户开始游戏        System.out.println(&quot;\n召唤一个探索者，来探索迷宫吧（随便输点什么吧）&quot;);        //输入 r 或 c 则采用递归方法，其余采用爬墙方法        char inC = inP.next().charAt(0);        if(inC == &#39;c&#39;)&#123;            System.out.println(&quot;\n您触发了迷宫之神的眷顾。&quot;);            if(hard &gt; 5)&#123;                System.out.println(&quot;\n迷宫之神眉头一皱，发现事情并不简单。&quot;);            &#125;            if(x &gt; 12 || y &gt; 12)&#123;                System.out.println(&quot;看到地图这么大，迷宫之神悻悻而归。他只喜欢12格以下的地图。&quot;);                return;             &#125;        &#125; else if(inC == &#39;r&#39;)&#123;            System.out.println(&quot;\n您引来了一群无畏小黄鸡。他们视死如归，一心想着寻找出口&quot;);        &#125; else &#123;            System.out.println(&quot;\n我们找来了一只小蜘蛛。试试看吧。&quot;);        &#125;        System.out.println(&quot;\n&quot;);        //调用方法，解密        if(inC == &#39;r&#39; || inC == &#39;c&#39;)&#123;            tools.outMazeRec(maze, inC, count);        &#125; else &#123;            tools.outMaze(maze, count);        &#125;    &#125;&#125;class T&#123;       //=======================================================================================            //方法 newMaze：让 n3 生成随机的 长 * 宽 = n1 * n2 的迷宫，其困难度为 n4    public void newMaze(int n1, int n2, char[][] n3, int n4)&#123;        //构建迷宫墙壁，以&#39;#&#39;表示。并随机向其中填充石块，以&#39;O&#39;表示        ////墙壁是迷宫的 开头和结尾行 以及 每行的开头和结尾        for(int i = 0; i &lt; n1; i++)&#123;            for(int j = 0; j &lt; n2; j++)&#123;                if(i == 0 || i == n1 - 1 ||j == 0 || j == n2 - 1)&#123;                    n3[i][j] = &#39;#&#39;;                &#125;else&#123;                    //ran 是一个随机值，此处是概率生成挡路的石块&#39;O&#39;。其概率与 n4 值的大小正相关                    //此外，若 n4（即用户输入的难度值 hard）超过范围，则按照 难度6 计算                    int ran;                    if(n4 &lt;= 9 &amp;&amp; n4 &gt;= 0)&#123;                        ran = (int)(Math.random() * (9 - n4) + 1);                    &#125;else&#123;                        ran = (int)(Math.random() * 3 + 1);                    &#125;                    n3[i][j] = (ran == 1) ? &#39;O&#39; : &#39; &#39;;                &#125;            &#125;        &#125;        //生成起点、终点，优化地形        n3[1][1] = &#39;B&#39;;        n3[2][1] = &#39; &#39;;        n3[1][2] = &#39; &#39;;        n3[n1 - 2][n2 - 2] = &#39;F&#39;;        n3[n1 - 3][n2 - 2] = &#39; &#39;;        n3[n1 - 2][n2 - 3] = &#39; &#39;;    &#125;                    //方法 showMaze：展示一个迷宫    public void showMaze(char[][] n1)&#123;        for(int i = 0; i &lt; n1.length; i++)&#123;            for(int j = 0; j &lt; n1[i].length; j++)&#123;                System.out.print(&quot; &quot; + n1[i][j]);            &#125;            System.out.println();        &#125;    &#125;    //=======================================================================================       //=======================================================================================    //方法 outMazeRec：递归方法迷宫游戏入口。可以接入普通递归方法，或最短路径方法。    public void outMazeRec(char[][] n1, char n2, int[] count)&#123;        //out：是否走出迷宫        boolean out = false;        //将迷宫的起止位置记为通路        n1[1][1] = &#39; &#39;;        n1[n1.length - 2][n1[0].length -2] = &#39; &#39;;        //如果输入的是&#39;c&#39;，则采用最短路径法。反之采用普通递归方法        if(n2 == &#39;c&#39;)&#123;            out = outCountMaze(1, 1, n1, count);        &#125;else&#123;            out = outMazeRecursion(1, 1, n1, count);                   &#125;        //把迷宫起始位置重新标注出来        n1[1][1] = &#39;B&#39;;        //判断是否解谜成功。如果成功，迷宫终点显示&#39;V&#39;，并展示步数，否则显示&#39;F&#39;        if(out)&#123;            n1[n1.length - 2][n1[0].length -2] = &#39;V&#39;;            showMaze(n1);            System.out.println(&quot;\t YOU WIN！！！&quot;);            System.out.println(&quot;通过路径为 &quot; + count[1] + &quot; 格&quot;);            &#125; else &#123;            n1[n1.length - 2][n1[0].length -2] = &#39;F&#39;;            showMaze(n1);            System.out.println(&quot;\t YOU LOSE&quot;);        &#125;            &#125;    //=======================================================================================    //=======================================================================================    //方法 outMazeRecursion：迷宫游戏，普通递归方法    public boolean outMazeRecursion(int y, int x, char[][] n3, int[] count)&#123;        count[1]++;        if(n3[n3.length - 2][n3[0].length - 2] == &#39;.&#39;)&#123;            return true;        &#125; else if(n3[y][x] == &#39; &#39;)&#123;            n3[y][x] = &#39;.&#39;;            if(outMazeRecursion(y, x + 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecursion(y + 1, x, n3, count))&#123;                return true;            &#125; else if(outMazeRecursion(y, x - 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecursion(y - 1, x, n3, count))&#123;                return true;            &#125; else&#123;                count[1]--;                n3[y][x] = &#39;+&#39;;             &#125;        &#125; else &#123;            count[1]--;            return false;        &#125;        count[1]--;        return false;    &#125;    //=======================================================================================        //=======================================================================================    //方法 outCountMaze：迷宫游戏，最短路径法的入口。这个入口由普通递归法接入。    public boolean outCountMaze(int y, int x, char[][] n, int[] count)&#123;        //首先，创建一个里数组。该数组用于 part1，原数组用于 part2。        //似乎没必要作此设计。但我还是予以保留。        char[][] inMaze = new char[n.length][n[0].length];        for(int i = 0; i &lt; n.length; i++)&#123;            for(int j = 0; j &lt; n[0].length; j++)&#123;                inMaze[i][j] = n[i][j];            &#125;        &#125;        //首先进行 part1，然后必定进行 part2。因为 part1 总会返回一个 false        if(countMazeRec(y, x, inMaze, count) || true)&#123;            count[0] = 0;            return outMazeRecC(y, x, n, count);        &#125;        return false;    &#125;    //方法 countMazeRec：迷宫游戏，最短路径法，part1    //该方法是先统计最短路径。最终总会返回 false    public boolean countMazeRec(int y, int x, char[][] n3, int[] count)&#123;        count[0]++;        if(y == n3.length - 2 &amp;&amp; x == n3[0].length - 2)&#123;            if(count[0] &lt; count[1] || count[1] == 0)&#123;                count[1] = count[0];            &#125;        &#125; else if(n3[y][x] == &#39; &#39;)&#123;            n3[y][x] = &#39;.&#39;;                       if(countMazeRec(y, x + 1, n3, count))&#123;                return true;            &#125; else if(countMazeRec(y + 1, x, n3, count))&#123;                return true;            &#125; else if(countMazeRec(y, x - 1, n3, count))&#123;                return true;            &#125; else if(countMazeRec(y - 1, x, n3, count))&#123;                return true;            &#125; else&#123;                n3[y][x] = &#39; &#39;;                count[0]--;                return false;            &#125;        &#125; else &#123;            count[0]--;            return false;        &#125;        count[0]--;        return false;    &#125;    //方法 outMazeRecC：迷宫游戏，最短路径法，part2    //该方法是在 part1 统计完最短路径后，按最短路径走出迷宫，并绘制路径    public boolean outMazeRecC(int y, int x, char[][] n3, int[] count)&#123;        count[0]++;        if(y == n3.length - 2 &amp;&amp; x == n3[0].length - 2)&#123;            if(count[0] &lt;= count[1])&#123;                return true;            &#125; else &#123;                n3[n3.length - 2][n3[0].length - 2] = &#39; &#39;;                count[0]--;                return false;            &#125;        &#125; else if(n3[y][x] == &#39; &#39;)&#123;            n3[y][x] = &#39;.&#39;;            if(outMazeRecC(y, x + 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecC(y + 1, x, n3, count))&#123;                return true;            &#125; else if(outMazeRecC(y, x - 1, n3, count))&#123;                return true;            &#125; else if(outMazeRecC(y - 1, x, n3, count))&#123;                return true;            &#125; else&#123;                n3[y][x] = &#39; &#39;;                count[0]--;                return false;            &#125;        &#125; else &#123;            count[0]--;            return false;        &#125;    &#125;    //=======================================================================================        //=======================================================================================    //方法 outMaze：爬墙方法迷宫游戏入口    public void outMaze(char[][] n1, int[] count)&#123;        //boolean out：记录是否走出迷宫        boolean out = false;        //角色光标 m        n1[1][1] = &#39;m&#39;;                //创建一系列变量，后面解释用法        //创建 角色坐标        int x = 1;        int y = 1;        //创建 辅助坐标 及 方向字符。初始方向为右。        int xi = 1;        int yi = 0;        char dir = &#39;r&#39;;          //创建 里迷宫，标记起止点。        char[][] inMaze = new char[n1.length][n1[0].length];        inMaze[1][1] = &#39;B&#39;;        inMaze[n1.length - 2][n1[0].length - 2] = &#39;F&#39;;                //开始走迷宫。        //如果一个迷宫有出路，则沿着一侧的墙壁走就一定能走到出路。以下方法就是基于这个原理。        //角色坐标 y,x 是角色所在的位置坐标。辅助坐标 yi，xi 是角色靠近的墙壁坐标。        //dir 代表角色此时的朝向。只要角色按照墙壁延申的方向向前，就一定不会迷路。        //里迷宫的大小和真迷宫相同，坐标也一一对应。目的是为了记录数据，这些数据不会被用户看到。        //里迷宫记载了 起始点 和 终点 的位置。如角色回到起点，则必定失败。到达终点则成功。        for(;;)&#123;            //判断 是否走出迷宫。如若是，则展示迷宫，记录脱出为真，并退出寻路            if(inMaze[y][x] == &#39;F&#39;)&#123;                n1[y][x] = &#39;V&#39;;                n1[1][1] = &#39;B&#39;;                showMaze(n1);                out = true;                break;            &#125;            //通过爬墙方式试图走出迷宫            //这是方向朝右时的情况            if(dir == &#39;r&#39;)&#123;                //如果角色面对墙壁，意味着走到了墙角，则角色坐标不变，调整墙壁坐标，并转向                if(n1[y][x + 1] == &#39;#&#39; || n1[y][x + 1] == &#39;O&#39;)&#123;                    dir = yi &gt; y ? &#39;u&#39; : &#39;d&#39;;                    yi = y;                    xi = x + 1;                //如果面前有路，且墙壁延伸，则前进                &#125; else if (n1[yi][xi + 1] == &#39;#&#39; || n1[yi][xi + 1] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    x++;                    xi++;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                //如果面前有路，但墙壁不延伸，则是遇到了转角。角色移动，转向，但墙壁坐标不变                &#125; else &#123;                    dir = yi &gt; y ? &#39;d&#39; : &#39;u&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y][x + 1] = &#39;.&#39;;                    y = yi;                    x = xi + 1;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            //这是方向朝左的情况            &#125; else if(dir == &#39;l&#39;)&#123;                if(n1[y][x - 1] == &#39;#&#39; || n1[y][x - 1] == &#39;O&#39;)&#123;                    dir = yi &gt; y ? &#39;u&#39; : &#39;d&#39;;                    yi = y;                    xi = x - 1;                &#125; else if(n1[yi][xi - 1] == &#39;#&#39; || n1[yi][xi - 1] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    x--;                    xi--;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                &#125; else &#123;                    dir = yi &gt; y ? &#39;d&#39; : &#39;u&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y][x - 1] = &#39;.&#39;;                    y = yi;                    x = xi - 1;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            //这是方向朝下的情况            &#125; else if(dir == &#39;d&#39;)&#123;                if(n1[y + 1][x] == &#39;#&#39; || n1[y + 1][x] == &#39;O&#39;)&#123;                    dir = xi &lt; x ? &#39;r&#39; : &#39;l&#39;;                    yi = y + 1;                    xi = x;                &#125; else if(n1[yi + 1][xi] == &#39;#&#39; || n1[yi + 1][xi] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    y++;                    yi++;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                &#125; else &#123;                    dir = xi &lt; x ? &#39;l&#39; : &#39;r&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y + 1][x] = &#39;.&#39;;                    y = yi + 1;                    x = xi;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            //这是方向朝上的情况            &#125; else if(dir == &#39;u&#39;)&#123;                if(n1[y - 1][x] == &#39;#&#39; || n1[y - 1][x] == &#39;O&#39;)&#123;                    dir = xi &lt; x ? &#39;r&#39; : &#39;l&#39;;                    yi = y - 1;                    xi = x;                &#125; else if(n1[yi - 1][xi] == &#39;#&#39; || n1[yi - 1][xi] == &#39;O&#39;)&#123;                    n1[y][x] = &#39;.&#39;;                    y--;                    yi--;                    n1[y][x] = &#39;m&#39;;                    count[1]++;                &#125; else &#123;                    dir = xi &lt; x ? &#39;l&#39; : &#39;r&#39;;                    n1[y][x] = &#39;.&#39;;                    n1[y - 1][x] = &#39;.&#39;;                    y = yi - 1;                    x = xi;                    n1[y][x] = &#39;m&#39;;                    count[1] += 2;                &#125;            &#125;            //判断 是否回到起点。如若是，则一定是迷宫无解。展示迷宫并退出寻路            if(inMaze[y][x] == &#39;B&#39;)&#123;                showMaze(n1);                break;            &#125;        &#125;        //输出结果        if(out)&#123;            System.out.println(&quot;\t YOU WIN！！！\n\t您的步数为：&quot; + count[1]);        &#125; else &#123;            System.out.println(&quot;\t YOU LOSE&quot;);        &#125;    &#125;&#125;</code></pre><h3><span id="八皇后代码">八皇后代码</span></h3><pre><code class="java">import java.util.Scanner;public class EightQueen&#123;    public static void main(String[] args)&#123;        T tools = new T();        char[][] chess = new char[8][8];        //调用方法，建立棋盘        tools.buildChess(chess);        //调用方法，开始游戏        tools.eightQueen(chess);    &#125;&#125;class T&#123;    //buildChess：建立一个新棋盘。该棋盘白色格子用&#39; &#39;表示，黑色格子用&#39;#&#39;表示    public void buildChess(char[][] chess)&#123;        for(int i = 0; i &lt; chess.length; i++)&#123;            for(int j = 0; j &lt; chess[0].length; j++)&#123;                chess[i][j] = ((i + j) % 2 == 0) ? &#39; &#39; : &#39;#&#39;;            &#125;        &#125;    &#125;    //eightQueen：八皇后游戏的接入口    public void eightQueen(char[][] chess)&#123;        //建立 里棋盘 inward 及 计数数组 count。里棋盘用于计算问题，原棋盘输出给用户看。        //计数 count 使用数组，这样其数据在所有方法都能通用        char[][] inward = new char[chess.length][chess[0].length];        int[] count = &#123;0&#125; ;        //进行游戏。因为穷举所有方法，最后返回的一定是 false。反正我们不在意。        boolean isFinished = gameEQS(0, 0, chess, inward, count);    &#125;    //gameEQS：八皇后游戏的基本方法    //八皇后游戏方法。y 代表当前位置的纵坐标，x 是横坐标。chess 是棋盘，inward 是里棋盘，count 是计数数组    public boolean gameEQS(int y, int x, char[][] chess, char[][] inward, int[] count)&#123;        //当 y 超出棋盘 时，显然已经完成八皇后。        //由于要进行穷举，此时我们计数并输出棋盘，然后返回 false 使其继续计算        if(y == inward.length)&#123;            count[0]++;            System.out.println();            gameEQS2(chess, inward, count);            return false;        //当 x 超出棋盘 时，显然棋盘该列已经无合法放置位置。我们返回 false        &#125; else if(x == inward[0].length)&#123;            return false;        //gameEQS1，这个方法是查看该格子是否是合法放置位置。如若是，返回 true，而且在该位置放置棋子&#39;Q&#39;        //当这个位置合法，我们进入下一行，从头开始判断。        //如果后面的判断为 false，我们就拿掉这枚棋子。如果后面判断为 true 说明我们找到了一个方法。        //特别地，由于代码目前是穷举模式，我想我们永远不会在此输出 true        &#125; else if(gameEQS1(y, x, inward))&#123;            if(gameEQS(y + 1, 0, chess, inward, count))&#123;                return true;            &#125; else &#123;                inward[y][x] = &#39; &#39;;            &#125;        &#125;        //如果代码进行到这个位置，证明我们所在的格子不适合放置棋子。我们只好去看看下一格如何。        return gameEQS(y, x + 1, chess, inward, count);    &#125;    //gameEQS1：该方法是输入一个坐标，并输入里棋盘地址，在里棋盘上查看该位置是否合法    //什么是合法的位置：就是该坐标的 同列、同行、同斜线 没有别的棋子    //如果是合法位置，我们放置一个棋子，并返回 true    public boolean gameEQS1(int y, int x, char[][] inward)&#123;        for(int i = 0; i &lt; inward.length; i++)&#123;            for(int j = 0; j &lt; inward[0].length; j++)&#123;                if(j == x || i == y || i - j == y - x || i + j == y + x)&#123;                    if(inward[i][j] == &#39;Q&#39;)&#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        inward[y][x] = &#39;Q&#39;;        return true;    &#125;    //gameEQS2：这个方法是把当前 里棋盘 的棋子放置到棋盘上，输出棋盘 并 输出计数。    //在输出完成后，会清空棋盘。    public void gameEQS2(char[][] chess, char[][] inward,int[] count)&#123;        for(int i = 0; i &lt; chess.length; i++)&#123;            for(int j = 0; j &lt; chess[0].length; j++)&#123;                if(inward[i][j] == &#39;Q&#39;)&#123;                    chess[i][j] = &#39;Q&#39;;                &#125;                System.out.print(&quot; &quot; + chess[i][j]);            &#125;            System.out.println();        &#125;        System.out.print(&quot;\n&quot; + count[0] + &quot;\n&quot;);        buildChess(chess);    &#125;    //gameEQSDebug    //输出里棋盘。测试用。    public void gameEQSDebug(char[][] inward)&#123;        for(int i = 0; i &lt; inward.length; i++)&#123;            for(int j = 0; j &lt; inward[0].length; j++)&#123;                System.out.print(&quot; &quot; + inward[i][j]);            &#125;            System.out.println();        &#125;        System.out.println();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2024/02/04/mysql/mysql/"/>
      <url>/2024/02/04/mysql/mysql/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code class="article_number"></code> <code class="site_word_count"></code></p><p><code class="site_uv"></code> <code class="site_pv"></code></p><h1><span id="单表查询">单表查询</span></h1><h2><span id="1数据库-数据库管理系统-sql">1.数据库、数据库管理系统、SQL</span></h2><p><em><strong>什么是数据库？什么是数据库管理系统？什么是SQL？他们之间的关系是什么？</strong></em></p><blockquote><p>数据库：英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</p></blockquote><blockquote><p>数据库管理系统：DataBaseManagement，简称DBMS。数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</p></blockquote><blockquote><p>常见的数据库管理系统：MySQL、Oracle、MS SqlServer、DB2、sybase等….</p></blockquote><blockquote><p>SQL：结构化查询语言程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。</p><p>SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。</p></blockquote><blockquote><p>三者之间的关系？<br>DBMS–执行–&gt; SQL –操作–&gt; DB</p></blockquote><p>学习的整个过程：</p><blockquote><p>先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS<br>对SQL语句进行执行，最终来完成数据库的数据管理。</p></blockquote><h2><span id="2-安装mysql数据库管理系统">2、安装MySQL数据库管理系统</span></h2><ol><li>先安装，选择“经典版”</li><li>需要进行MySQL数据库实例配置。</li></ol><p><strong>注意：一路下一步就行了！！！！！</strong></p><p>需要注意的事项？</p><p><strong>端口号</strong>：</p><blockquote><p>端口号port是任何一个软件&#x2F;应用都会有的，端口号是应用的唯一代表。端口号通常和IP地址在一块，IP地址用来定位计算机的，端口号port是用来定位计算机上某个服务的&#x2F;某个应用的！在同一台计算机上，端口号不能重复。具有唯一性。mysql数据库启动的时候，这个服务占有的&#x3D;&#x3D;默认端口号是3306&#x3D;&#x3D;。</p></blockquote><p><strong>字符编码方式</strong>：</p><blockquote><p>设置mysql数据库的字符编码方式为 UTF8，一定要注意：先选中第3个单选按钮，然后再选择utf8字符集。</p></blockquote><p><strong>服务名称</strong></p><blockquote><p>默认是：MySQL<br>不用改。</p></blockquote><p><strong>选择配置环境变量path</strong></p><p>如果没有选择怎么办？</p><p>可以手动配置<br>path&#x3D;其它路径;C:\Program Files (x86)\MySQL\MySQL Server 5.5\bin</p><ul><li><p>mysql超级管理员用户名不能改，一定是：root<br>  你需要设置mysql数据库超级管理员的密码。</p></li><li><p>设置密码的同时，可以激活root账户远程访问。<br>  激活：表示root账号可以在外地登录。<br>  不激活：表示root账号只能在本机上使用。</p></li></ul><h2><span id="3-mysql数据库的完美卸载">3、MySQL数据库的完美卸载！</span></h2><p>第一步：双击安装包进行卸载删除。<br>第二步：删除目录：<br>把C:\ProgramData下面的MySQL目录干掉。<br>把C:\Program Files (x86)下面的MySQL目录干掉。</p><p>这样就卸载结束了！</p><h2><span id="5-在windows中使用命令来启动和关闭mysql服务">5、在windows中使用命令来启动和关闭mysql服务</span></h2><p>语法：net stop 服务名称;net start 服务名称,其它服务的启停都可以采用以上的命令。</p><h2><span id="6-登录mysql">6、登录Mysql</span></h2><pre><code>使用bin目录下的mysql.exe命令来连接mysql数据库服务器本地登录（显示编写密码的形式）：    C:\Users\Administrator&gt;mysql -uroot -p123456    Welcome to the MySQL monitor.  Commands end with ; or \g.    Your MySQL connection id is 1    Server version: 5.5.36 MySQL Community Server (GPL)    Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.    Oracle is a registered trademark of Oracle Corporation and/or its    affiliates. Other names may be trademarks of their respective    owners.    Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.    mysql&gt;本地登录（隐藏密码的形式）：    C:\Users\Administrator&gt;mysql -uroot -p    Enter password: ******    Welcome to the MySQL monitor.  Commands end with ; or \g.    Your MySQL connection id is 2    Server version: 5.5.36 MySQL Community Server (GPL)    Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.    Oracle is a registered trademark of Oracle Corporation and/or its    affiliates. Other names may be trademarks of their respective    owners.    Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.    mysql&gt;</code></pre><h2><span id="7-mysql常用命令">7、mysql常用命令：</span></h2><h3><span id="71-退出mysql-exit">7.1 退出mysql ：exit</span></h3><pre><code class="mysql">mysql&gt; show databases;使用某个数据库use test;创建数据库create database bjpowernode;show tables;</code></pre><h3><span id="72-查看版本号">7.2 查看版本号</span></h3><p>select version();</p><h3><span id="73-查看当前数据库">7.3 查看当前数据库</span></h3><p>select database();</p><p>mysql是不见“;”不执行，“;”表示结束！</p><h3><span id="74-c用来终止一条命令的输入">7.4 \c用来终止一条命令的输入。</span></h3><h2><span id="8-数据库当中最基本的单元是表table">8、数据库当中最基本的单元是表：table</span></h2><p>什么是表table？为什么用表来存储数据呢？</p><table><thead><tr><th>姓名</th><th>性别</th><th>年龄(列：字段)</th><th></th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>20</td><td>——-&gt;行（记录）</td></tr><tr><td>李四</td><td>女</td><td>20</td><td>——-&gt;行（记录）</td></tr><tr><td>王五</td><td>男</td><td>22</td><td>——-&gt;行（记录）</td></tr></tbody></table><p>数据库当中是以表格的形式表示数据的。因为表比较直观。</p><p>任何一张表都有行和列：</p><blockquote><p>行（row）：被称为数据&#x2F;记录。</p></blockquote><blockquote><p>列（column）：被称为字段。</p></blockquote><p>每一个字段都有：字段名、数据类型、约束等属性。</p><blockquote><p>字段名可以理解，是一个普通的名字，见名知意就行。<br>数据类型：字符串，数字，日期等<br>约束：约束也有很多，其中一个叫做唯一性约束，这种约束添加之后，该字段中的数据不能重复。</p></blockquote><h2><span id="9-关于sql语句的分类">9、关于SQL语句的分类？</span></h2><p>SQL语句有很多，最好进行分门别类，这样更容易记忆。<br>    分为：</p><ul><li><p><strong>DQL：数据查询语言</strong>（凡是带有select关键字的都是查询语句）</p><pre><code class="sql">select...</code></pre></li><li><p><strong>DML：数据操作语言</strong>（凡是对表当中的数据进行增删改的都是DML）</p><pre><code class="sql">insert delete updateinsert 增delete 删update 改</code></pre><p>  这个主要是操作表中的数据data。</p></li><li><p><strong>DDL数据定义语言</strong>(凡是带有create、drop、alter的都是DDL)</p><blockquote><p>DDL主要操作的是表的结构。不是表中的数据。</p></blockquote><pre><code class="sql">create：新建，等同于增drop：删除alter：修改</code></pre><p>  这个增删改和DML不同，这个主要是对表结构进行操作。</p></li><li><p><strong>TCL事务控制语言</strong><br>  不是王牌电视。是包括：</p><pre><code class="sql">commit;事务提交：rollback;事务回滚：</code></pre></li><li><p><strong>DCL数据控制语言</strong></p><pre><code>授权grant、撤销权限revoke....</code></pre></li></ul><h2><span id="10-通过cmd导入sql文件数据">10、通过cmd导入sql文件数据：</span></h2><p>bjpowernode.sql 这个文件中是我提前为大家练习准备的数据库表。<br>怎么将sql文件中的数据导入呢？<br><code>mysql&gt; source D:\course\03-MySQL\document\bjpowernode.sql</code></p><p>&#x3D;&#x3D;注意：路径中不要有中文！！！！&#x3D;&#x3D;</p><h2><span id="12-看表的结构">12、看表的结构</span></h2><p>desc 表名;</p><h2><span id="13-简单查询">13、简单查询</span></h2><h3><span id="131-查询一个字段">13.1、查询一个字段？</span></h3><p>select 字段名 from 表名;<br>其中要注意：</p><blockquote><p>select和from都是<strong>关键字</strong>。<br>字段名和表名都是<strong>标识符。</strong></p></blockquote><h3><span id="132-查询所有字段">13.2 查询所有字段</span></h3><p>第一种方式：可以把每个字段都写上<br>        select a,b,c,d,e,f… from tablename;</p><p>第二种方式：可以使用*<br>select * from dept;</p><p>这种方式的缺点：</p><p>1、效率低<br>2、可读性差。<br>在实际开发中不建议。<br>你可以在DOS命令窗口中想快速的看一看全表数据可以采用这种方式。</p><h3><span id="133-x3dx3d给查询的列起别名x3dx3d">13.3、&#x3D;&#x3D;给查询的列起别名&#x3D;&#x3D;？</span></h3><p><code>mysql&gt; select deptno,dname as deptname from dept;</code></p><p><strong>假设起别名的时候，别名里面有空格，怎么办？</strong><br>mysql&gt; select deptno,dname dept name from dept;<br>&#x3D;&#x3D;DBMS看到这样的语句，进行SQL语句的编译，不符合语法，编译报错。&#x3D;&#x3D;<br>怎么解决？<br><code>select deptno,dname &#39;dept name&#39; from dept; </code>&#x2F;&#x2F;<strong>加单引号</strong><br><code>select deptno,dname &quot;dept name&quot; from dept; </code>&#x2F;&#x2F;<strong>加双引号</strong></p><p><strong>注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准，双引号在oracle数据库中用不了。但是在mysql中可以使用。</strong></p><h2><span id="14-条件查询">14、条件查询</span></h2><h3><span id="141-什么是条件查询">14.1、什么是条件查询？</span></h3><pre><code class="sql">语法格式：select    字段1,字段2,字段3....from     表名where    条件;</code></pre><h3><span id="142-都有哪些条件">14.2、都有哪些条件？</span></h3><h4><span id="等于"><strong><code>= 等于</code></strong></span></h4><p>查询薪资等于800的员工姓名和编号？<br>    select empno,ename from emp where sal &#x3D; 800;<br>查询SMITH的编号和薪资？<br>    select empno,sal from emp where ename &#x3D; ‘SMITH’; &#x2F;&#x2F;字符串使用单引号</p><h4><span id="ltgt或x3d-不等于">&lt;&gt;或!&#x3D; 不等于</span></h4><p>查询薪资不等于800的员工姓名和编号？<br><code>select empno,ename from emp where sal != 800;</code><br><code>select empno,ename from emp where sal &lt;&gt; 800; </code>&#x2F;&#x2F; 小于号和大于号组成的不等号</p><h4><span id="lt-小于">&lt; 小于</span></h4><p>查询薪资小于2000的员工姓名和编号？<br><code>select empno,ename,sal from emp where sal &lt; 2000;</code></p><h4><span id="ltx3d-小于等于">&lt;&#x3D; 小于等于</span></h4><p>查询薪资小于等于3000的员工姓名和编号？<br><code>select empno,ename,sal from emp where sal &lt;= 3000;</code></p><h4><span id="大于">大于</span></h4><p>查询薪资大于3000的员工姓名和编号？<br>select empno,ename,sal from emp where sal &gt; 3000;</p><h4><span id="大于等于">大于等于</span></h4><p>查询薪资大于等于3000的员工姓名和编号？<br>select empno,ename,sal from emp where sal &gt;&#x3D; 3000;</p><pre><code class="sql">select     empno,ename,sal from     emp where     sal between 2450 and 3000;</code></pre><p><strong>注意：&#x3D;&#x3D;使用between and的时候，必须遵循左小右大。&#x3D;&#x3D;between and是闭区间，包括两端的值。</strong></p><p>is null 为 null（is not null 不为空）<br>查询哪些员工的津贴&#x2F;补助为null？<br>mysql&gt; select empno,ename,sal,comm from emp where comm &#x3D; null;</p><pre><code>mysql&gt; select empno,ename,sal,comm from emp where comm is null;</code></pre><p><strong>注意：在数据库当中null不能使用等号进行衡量。需要使用is null因为数据库中的null代表什么也没有，它不是一个值，所以不能使用等号衡量。</strong></p><p>查询哪些员工的津贴&#x2F;补助不为null？<br>    select empno,ename,sal,comm from emp where comm is not null;</p><h4><span id="and-并且">and 并且</span></h4><p>查询工作岗位是MANAGER并且工资大于2500的员工信息？</p><pre><code class="sql">select     empno,ename,job,sal from     emp where     job = &#39;MANAGER&#39; and sal &gt; 2500;</code></pre><h4><span id="or-或者">or 或者</span></h4><p>查询工作岗位是MANAGER和SALESMAN的员工？<br>select empno,ename,job from emp where job &#x3D; ‘MANAGER’;<br>select empno,ename,job from emp where job &#x3D; ‘SALESMAN’;</p><pre><code class="sql">select     empno,ename,jobfrom    empwhere     job = &#39;MANAGER&#39; or job = &#39;SALESMAN&#39;;</code></pre><h4><span id="and和or同时出现的话有优先级问题吗">and和or同时出现的话，有优先级问题吗？</span></h4><p>查询工资大于2500，并且部门编号为10或20部门的员工？</p><pre><code class="sql">select     *from    empwhere    sal &gt; 2500 and deptno = 10 or deptno = 20;</code></pre><p>分析以上语句的问题？</p><blockquote><p>&#x3D;&#x3D;and优先级比or高。&#x3D;&#x3D;<br>以上语句会先执行and，然后执行or。</p></blockquote><p>以上这个语句表示什么含义？</p><blockquote><p>找出工资大于2500并且部门编号为10的员工，或者20部门所有员工找出来。</p></blockquote><pre><code class="sql">select     *from    empwhere    sal &gt; 2500 and (deptno = 10 or deptno = 20);</code></pre><p>and和or同时出现，and优先级较高。如果想让or先执行，&#x3D;&#x3D;需要加“小括号”&#x3D;&#x3D;<br>以后在开发中，<strong>如果不确定优先级，就加小括号就行了。</strong></p><p>&#x3D;&#x3D;in 包含，相当于多个 or （not in 不在这个范围中）&#x3D;&#x3D;</p><p>查询工作岗位是MANAGER和SALESMAN的员工？<br>select empno,ename,job from emp where job &#x3D; ‘MANAGER’ or job &#x3D; ‘SALESMAN’;<br>select empno,ename,job from emp where job in(‘MANAGER’, ‘SALESMAN’);<br><strong>注意：in不是一个区间。in后面跟的是具体的值。</strong></p><p><strong>not in 表示不在这几个值当中的数据。</strong><br><code>select ename,sal from emp where sal not in(800, 5000, 3000);</code></p><p>not 可以取非，主要用在 is 或 in 中</p><pre><code class="sql">is nullis not nullinnot in</code></pre><h4><span id="模糊查询like">模糊查询like</span></h4><blockquote><p>支持%或下划线匹配</p></blockquote><blockquote><p>%匹配任意多个字符<br>下划线：任意一个字符。<br>%是一个特殊的符号，_ 也是一个特殊符号）</p></blockquote><pre><code class="sql">找出名字中含有O的？select ename from emp where ename like &#39;%O%&#39;;找出名字以T结尾的？select ename from emp where ename like &#39;%T&#39;;找出名字以K开始的？select ename from emp where ename like &#39;K%&#39;;找出第二个字每是A的？select ename from emp where ename like &#39;_A%&#39;;找出第三个字母是R的？select ename from emp where ename like &#39;__R%&#39;;找出名字中有“_”的？select name from t_student where name like &#39;%_%&#39;; //这样不行。select name from t_student where name like &#39;%\_%&#39;; // \转义字符。</code></pre><h2><span id="15-排序">15、排序</span></h2><h3><span id="151-查询所有员工薪资排序">15.1、查询所有员工薪资，排序？</span></h3><pre><code class="sql">select     ename,salfrom    emporder by    sal;</code></pre><p> &#x3D;&#x3D;默认是升序！！！&#x3D;&#x3D;</p><h3><span id="152-怎么降序">15.2、怎么降序？</span></h3><pre><code class="sql">指定降序：select ename,salfromemporder bysal desc;</code></pre><pre><code class="sql">指定升序？select ename,salfromemporder bysal asc;</code></pre><h3><span id="153-多个字段排序">15.3、多个字段排序</span></h3><p>查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。<br><code>select ename,salfromemporder bysal asc, ename asc;</code></p><p> sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。</p><h3><span id="154-了解根据字段的位置也可以排序">15.4、了解：根据字段的位置也可以排序</span></h3><pre><code class="sql">select ename,sal from emp order by 2; // 2表示第二列。第二列是sal按照查询结果的第2列sal排序。了解一下，不建议在开发中这样写，因为不健壮。因为列的顺序很容易发生改变，列顺序修改之后，2就废了。</code></pre><h2><span id="x3dx3d16-语句执行顺序x3dx3d">&#x3D;&#x3D;16、语句执行顺序&#x3D;&#x3D;</span></h2><p>关键字顺序不能变：</p><pre><code class="sql">select    ...from    ...where    ...order by    ...</code></pre><p>&#x3D;&#x3D;以上语句的执行顺序必须掌握：&#x3D;&#x3D;<br>    第一步：from<br>    第二步：where<br>    第三步：select<br>    第四步：order by（<strong>排序总是在最后执行！</strong>）</p><h2><span id="17-数据处理函数">17、数据处理函数</span></h2><h3><span id="171-数据处理函数又被称为单行处理函数">17.1、数据处理函数又被称为单行处理函数</span></h3><blockquote><p>单行处理函数的特点：一个输入对应一个输出。<br>和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）</p></blockquote><h3><span id="172-单行处理函数常见的有哪些">17.2、单行处理函数常见的有哪些？</span></h3><h4><span id="lower-转换小写">lower 转换小写</span></h4><p>select lower(ename) as ename from emp;</p><h4><span id="upper-转换大写">upper 转换大写</span></h4><p>select upper(name) as name from t_student;</p><h4><span id="substr-取子串">substr 取子串</span></h4><p>语法：substr( 被截取的字符串, 起始下标,截取的长度）</p><p>select substr(ename, 1, 1) as ename from emp;<br>&#x3D;&#x3D;注意：起始下标从1开始，没有0.&#x3D;&#x3D;<br>找出员工名字第一个字母是A的员工信息？</p><pre><code>第一种方式：模糊查询select ename from emp where ename like &#39;A%&#39;;第二种方式：substr函数elect     ename from     emp where     substr(ename,1,1) = &#39;A&#39;;</code></pre><h4><span id="首字母大写">首字母大写</span></h4><pre><code class="sql">select name from t_student;select upper(substr(name,1,1)) from t_student;select substr(name,2,length(name) - 1) from t_student;select concat(upper(substr(name,1,1)),substr(name,2,length(name) - 1)) as result from t_student;+----------+| result   |+----------+| Zhangsan || Lisi     || Wangwu   || Jack_son |+----------+</code></pre><h4><span id="concat函数进行字符串的拼接">concat函数进行字符串的拼接</span></h4><p>select concat(empno,ename) from emp;</p><h4><span id="length-取长度">length 取长度</span></h4><p>select length(ename) enamelength from emp;</p><h4><span id="trim-去前后空格">trim 去前后空格</span></h4><p>select * from emp where ename &#x3D; trim(‘   KING’);</p><h4><span id="str_to_date-将字符串转换成日期">str_to_date 将字符串转换成日期</span></h4><h4><span id="date_format-格式化日期">date_format 格式化日期</span></h4><h4><span id="format-设置千分位">format 设置千分位</span></h4><h4><span id="x3dx3dcasewhenthenwhenthenelseendx3dx3d">&#x3D;&#x3D;case..when..then..when..then..else..end&#x3D;&#x3D;</span></h4><p>当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%,其它正常。<br>（注意：不修改数据库，只是将查询结果显示为工资上调）</p><pre><code class="sql">select     ename,    job,     sal as oldsal,(case job when &#39;MANAGER&#39; then `sal*1.1 `when &#39;SALESMAN&#39; then sal*1.5 else sal end) as newsal from     emp;</code></pre><h4><span id="x3dx3dround-四舍五入x3dx3d">&#x3D;&#x3D;round 四舍五入&#x3D;&#x3D;</span></h4><pre><code>    select 字段 from 表名;    select ename from emp;    select &#39;abc&#39; from emp; // select后面直接跟“字面量/字面值”</code></pre><h5><span id="x3dx3d根据字面量查询x3dx3d">&#x3D;&#x3D;根据字面量查询&#x3D;&#x3D;</span></h5><p>select ‘abc’ as bieming from emp;</p><pre><code class="sql">    +---------+    | bieming |    +---------+    | abc     |    | abc     |select abc from emp;    ERROR 1054 (42S22): Unknown column &#39;abc&#39; in &#39;field list&#39;    这样肯定报错，因为会把abc当做一个字段的名字，去emp表中找abc字段去了。</code></pre><p>select 1000 as num from emp; &#x2F;&#x2F; 1000 也是被当做一个字面量&#x2F;字面值。</p><pre><code>    +------+    | num  |    +------+    | 1000 |    | 1000 |    | 1000 |    | 1000 |</code></pre><p>​&#x3D;&#x3D;结论：select后面可以跟某个表的字段名（可以等同看做变量名），也可以跟字面量&#x2F;字面值（数据）。&#x3D;&#x3D;</p><pre><code>    select 21000 as num from dept;    +-------+    | num   |    +-------+    | 21000 |    | 21000 |    | 21000 |    | 21000 |    +-------+    mysql&gt; select round(1236.567, 0) as result from emp; //保留整数位。    +--------+    | result |    +--------+    |   1237 |    |   1237 |    |   1237 |    |   1237 |    |   1237 |    |   1237 |</code></pre><p>select round(1236.567, 1) as result from emp; &#x2F;&#x2F;保留1个小数<br>select round(1236.567, 2) as result from emp; &#x2F;&#x2F;保留2个小数<br>select round(1236.567, -1) as result from emp; &#x2F;&#x2F; 保留到十位。<br>    +——–+<br>    | result |<br>    +——–+<br>    |   1240 |<br>    |   1240 |</p><p>select round(1236.567, -2) as result from emp;<br>    +——–+<br>    | result |<br>    +——–+<br>    |   1200 |<br>    |   1200 |</p><h5><span id="rand-生成随机数">rand() 生成随机数</span></h5><p>​mysql&gt; select round(rand()*100,0) from emp; &#x2F;&#x2F; 100以内的随机数<br>​+———————+<br>​| round(rand()*100,0) |<br>​+———————+<br>​|                  76 |<br>​|                  29 |<br>​|                  15 |<br>​|                  88 |<br>​|                  95 |<br>​|                   9 |<br>​</p><h4><span id="x3dx3difnull-可以将-null-转换成一个具体值x3dx3d">&#x3D;&#x3D;ifnull 可以将 null 转换成一个具体值&#x3D;&#x3D;</span></h4><p>ifnull是空处理函数。专门处理空的。<br>&#x3D;&#x3D;在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。&#x3D;&#x3D;</p><p>案例：</p><pre><code>计算每个员工的年薪？年薪 = (月薪 + 月补助) * 12select ename, (sal + comm) * 12 as yearsal from emp;+--------+----------+| ename  | yearsal  |+--------+----------+| SMITH  |     NULL || ALLEN  | 22800.00 || WARD   | 21000.00 || JONES  |     NULL || MARTIN | 31800.00 || BLAKE  |     NULL || CLARK  |     NULL || SCOTT  |     NULL || KING   |     NULL || TURNER | 18000.00 || ADAMS  |     NULL || JAMES  |     NULL || FORD   |     NULL || MILLER |     NULL |+--------+----------+</code></pre><p>&#x3D;&#x3D;注意：NULL只要参与运算，最终结果一定是NULL。为了避免这个现象，需要使用ifnull函数。&#x3D;&#x3D;<br>ifnull函数用法：ifnull(数据, 被当做哪个值)<br>如果“数据”为NULL的时候，把这个数据结构当做哪个值。</p><p>补助为NULL的时候，将补助当做0</p><pre><code class="sql">select ename, (sal + ifnull(comm, 0)) * 12 as yearsal from emp;+--------+----------+| ename  | yearsal  |+--------+----------+| SMITH  |  9600.00 || ALLEN  | 22800.00 || WARD   | 21000.00 || JONES  | 35700.00 || MARTIN | 31800.00 || BLAKE  | 34200.00 || CLARK  | 29400.00 || SCOTT  | 36000.00 || KING   | 60000.00 || TURNER | 18000.00 || ADAMS  | 13200.00 || JAMES  | 11400.00 || FORD   | 36000.00 || MILLER | 15600.00 |+--------+----------+</code></pre><h2><span id="18-分组函数多行处理函数">18、分组函数（多行处理函数）</span></h2><blockquote><p>多行处理函数的特点：输入多行，最终输出一行。</p></blockquote><ul><li><code>count</code>计数</li><li><code>sum</code>求和</li><li><code>avg</code>平均值</li><li><code>max</code>最大值</li><li><code>min</code>最小值</li></ul><blockquote><p><strong>注意：分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。</strong></p></blockquote><pre><code>计算工资和：    mysql&gt; select sum(sal) from emp;    +----------+    | sum(sal) |    +----------+    | 29025.00 |    +----------+计算平均工资：    mysql&gt; select avg(sal) from emp;    +-------------+    | avg(sal)    |    +-------------+    | 2073.214286 |    +-------------+    14个工资全部加起来，然后除以14。计算员工数量？    mysql&gt; select count(ename) from emp;    +--------------+    | count(ename) |    +--------------+    |           14 |    +--------------+</code></pre><p>​</p><p>&#x3D;&#x3D;分组函数在使用的时候需要注意哪些？&#x3D;&#x3D;</p><ol><li>分组函数&#x3D;&#x3D;自动忽略NULL&#x3D;&#x3D;，你不需要提前对NULL进行处理。</li><li>分组函数中count(*)和count(具体字段)有什么区别？</li></ol><pre><code>mysql&gt; select count(*) from emp;+----------+| count(*) |+----------+|       14 |+----------+mysql&gt; select count(comm) from emp;+-------------+| count(comm) |+-------------+|           4 |+-------------+</code></pre><p><strong>count(具体字段)：表示统计该字段下所有不为NULL的元素的总数</strong>。<br><strong>count(*)：统计表当中的总行数。</strong>（只要有一行数据count则++）<br><strong>因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。</strong></p><ol start="3"><li><p>&#x3D;&#x3D;分组函数不能够直接使用在where子句中。&#x3D;&#x3D;</p></li><li><p>所有的分组函数可以组合起来一起用。</p></li></ol><pre><code class="sql">select sum(sal),min(sal),max(sal),avg(sal),count(*) from emp;+----------+----------+----------+-------------+----------+| sum(sal) | min(sal) | max(sal) | avg(sal)    | count(*) |+----------+----------+----------+-------------+----------+| 29025.00 |   800.00 |  5000.00 | 2073.214286 |       14 |+----------+----------+----------+-------------+----------+</code></pre><h2><span id="x3dx3d19-分组查询非常重要五颗星x3dx3d">&#x3D;&#x3D;19、分组查询（非常重要：五颗星）&#x3D;&#x3D;</span></h2><p>19.2、将之前的关键字全部组合在一起，来看一下他们的执行顺序？</p><pre><code>select    ...from    ...where    ...group by    ...order by    ...</code></pre><p>以上关键字的顺序不能颠倒，需要记忆。<br>执行顺序是什么？<br>    1. from<br>    2. where<br>    3. group by<br>    4. select<br>    5. order by</p><p><strong>为什么分组函数不能直接使用在where后面？</strong></p><p>select ename,sal from emp where sal &gt; min(sal);&#x2F;&#x2F;报错。<br>因为分组函数在使用的时候必须先分组之后才能使用。<br>where执行的时候，还没有分组。所以where后面不能出现分组函数。</p><p>select sum(sal) from emp;<br>这个没有分组，为啥sum()函数可以用呢？<br>因为select在group by之后执行。</p><pre><code>select ename,job,sum(sal) from emp group by job;+-------+-----------+----------+| ename | job       | sum(sal) |+-------+-----------+----------+| SCOTT | ANALYST   |  6000.00 || SMITH | CLERK     |  4150.00 || JONES | MANAGER   |  8275.00 || KING  | PRESIDENT |  5000.00 || ALLEN | SALESMAN  |  5600.00 |+-------+-----------+----------+</code></pre><blockquote><p>以上语句在mysql中可以执行，但是毫无意义。<br>以上语句在oracle中执行报错。<br>oracle的语法比mysql的语法严格。（mysql的语法相对来说松散一些！）</p><p>&#x3D;&#x3D;重点结论：在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。&#x3D;&#x3D;</p></blockquote><p>找出“每个部门，不同工作岗位”的最高薪资？</p><pre><code>+--------+-----------+---------+--------+| ename  | job       | sal     | deptno |+--------+-----------+---------+--------+| MILLER | CLERK     | 1300.00 |     10 || KING   | PRESIDENT | 5000.00 |     10 || CLARK  | MANAGER   | 2450.00 |     10 || FORD   | ANALYST   | 3000.00 |     20 || ADAMS  | CLERK     | 1100.00 |     20 || SCOTT  | ANALYST   | 3000.00 |     20 || JONES  | MANAGER   | 2975.00 |     20 || SMITH  | CLERK     |  800.00 |     20 || BLAKE  | MANAGER   | 2850.00 |     30 || MARTIN | SALESMAN  | 1250.00 |     30 || ALLEN  | SALESMAN  | 1600.00 |     30 || TURNER | SALESMAN  | 1500.00 |     30 || WARD   | SALESMAN  | 1250.00 |     30 || JAMES  | CLERK     |  950.00 |     30 |+--------+-----------+---------+--------+技巧：两个字段联合成1个字段看。（两个字段联合分组）select     deptno, job, max(sal)from    empgroup by    deptno, job;+--------+-----------+----------+| deptno | job       | max(sal) |+--------+-----------+----------+|     10 | CLERK     |  1300.00 ||     10 | MANAGER   |  2450.00 ||     10 | PRESIDENT |  5000.00 ||     20 | ANALYST   |  3000.00 ||     20 | CLERK     |  1100.00 ||     20 | MANAGER   |  2975.00 ||     30 | CLERK     |   950.00 ||     30 | MANAGER   |  2850.00 ||     30 | SALESMAN  |  1600.00 |+--------+-----------+----------+</code></pre><p>​</p><h3><span id="having">having</span></h3><ul><li>having可以对分完组之后的数据进一步过滤。</li><li>having不能单独使用，having不能代替where，&#x3D;&#x3D;having必须和group by联合使用。&#x3D;&#x3D;</li></ul><p>找出每个部门最高薪资，要求显示最高薪资大于3000的？</p><pre><code class="sql">select     deptno,max(sal) from     emp group by     deptnohaving    max(sal) &gt; 3000;+--------+----------+| deptno | max(sal) |+--------+----------+|     10 |  5000.00 |+--------+----------+</code></pre><p>思考一个问题：以上的sql语句执行效率是不是低？</p><blockquote><p>比较低，实际上可以这样考虑：先将大于3000的都找出来，然后再分组。</p></blockquote><pre><code>select     deptno,max(sal)from    empwhere    sal &gt; 3000group by    deptno;+--------+----------+| deptno | max(sal) |+--------+----------+|     10 |  5000.00 |+--------+----------+</code></pre><p>&#x3D;&#x3D;优化策略：where和having，优先选择where，where实在完成不了了，再选择having。&#x3D;&#x3D;</p><p><em><strong>where没办法的？？？？</strong></em></p><blockquote><p>找出每个部门平均薪资，要求显示平均薪资高于2500的。</p></blockquote><p>第一步：找出每个部门平均薪资</p><pre><code class="sql">select deptno,avg(sal) from emp group by deptno;+--------+-------------+| deptno | avg(sal)    |+--------+-------------+|     10 | 2916.666667 ||     20 | 2175.000000 ||     30 | 1566.666667 |+--------+-------------+</code></pre><p>第二步：要求显示平均薪资高于2500的</p><pre><code class="sql">select     deptno,avg(sal) from     emp group by     deptnohaving    avg(sal) &gt; 2500;+--------+-------------+| deptno | avg(sal)    |+--------+-------------+|     10 | 2916.666667 |+--------+-------------+</code></pre><h2><span id="x3dx3d20-大总结单表的查询学完了x3dx3d">&#x3D;&#x3D;20、大总结（单表的查询学完了）&#x3D;&#x3D;</span></h2><pre><code>select     ...from    ...where    ...group by    ...having    ...order by    ...</code></pre><p>&#x3D;&#x3D;以上关键字只能按照这个顺序来，不能颠倒。&#x3D;&#x3D;</p><p><em><strong>执行顺序？</strong></em></p><ol><li>from</li><li>where</li><li>group by</li><li>having</li><li>select</li><li>order by</li></ol><blockquote><p>从某张表中查询数据，<br>先经过where条件筛选出有价值的数据。<br>对这些有价值的数据进行分组。<br>分组之后可以使用having继续筛选。<br>select查询出来。<br>最后排序输出！</p></blockquote><p>找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，<br>要求按照平均薪资降序排。</p><pre><code class="sql">select     job, avg(sal) as avgsalfrom    empwhere    job &lt;&gt; &#39;MANAGER&#39;group by    jobhaving    avg(sal) &gt; 1500order by    avgsal desc;+-----------+-------------+| job       | avgsal      |+-----------+-------------+| PRESIDENT | 5000.000000 || ANALYST   | 3000.000000 |+-----------+-------------+</code></pre><h1><span id="多表查询">多表查询</span></h1><h2><span id="1-把查询结果去除重复记录distinct">1、把查询结果去除重复记录【distinct】</span></h2><pre><code>注意：原表数据不会被修改，只是查询结果去重。去重需要使用一个关键字：distinctmysql&gt; select distinct job from emp;+-----------+| job       |+-----------+| CLERK     || SALESMAN  || MANAGER   || ANALYST   || PRESIDENT |+-----------+// 这样编写是错误的，语法错误。// distinct只能出现在所有字段的最前方。mysql&gt; select ename,distinct job from emp;// distinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。mysql&gt; select distinct job,deptno from emp;+-----------+--------+| job       | deptno |+-----------+--------+| CLERK     |     20 || SALESMAN  |     30 || MANAGER   |     20 || MANAGER   |     30 || MANAGER   |     10 || ANALYST   |     20 || PRESIDENT |     10 || CLERK     |     30 || CLERK     |     10 |+-----------+--------+统计一下工作岗位的数量？    select count(distinct job) from emp;    +---------------------+    | count(distinct job) |    +---------------------+    |                   5 |    +---------------------+</code></pre><h2><span id="2-连接查询">2、连接查询</span></h2><h3><span id="21-什么是连接查询">2.1、什么是连接查询？</span></h3><pre><code>从一张表中单独查询，称为单表查询。emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，被称为连接查询。</code></pre><h3><span id="22-连接查询的分类">2.2、连接查询的分类？</span></h3><pre><code>根据语法的年代分类：    SQL92：1992年的时候出现的语法    SQL99：1999年的时候出现的语法    我们这里重点学习SQL99.(这个过程中简单演示一个SQL92的例子)根据表连接的方式分类：    内连接：        等值连接        非等值连接        自连接    外连接：        左外连接（左连接）        右外连接（右连接）    全连接（不讲）</code></pre><h3><span id="23-当两张表进行连接查询时没有任何条件的限制会发生什么现象">2.3、当两张表进行连接查询时，没有任何条件的限制会发生什么现象？</span></h3><pre><code>案例：查询每个员工所在部门名称？    mysql&gt; select ename,deptno from emp;    +--------+--------+    | ename  | deptno |    +--------+--------+    | SMITH  |     20 |    | ALLEN  |     30 |    | WARD   |     30 |    | JONES  |     20 |    | MARTIN |     30 |    | BLAKE  |     30 |    | CLARK  |     10 |    | SCOTT  |     20 |    | KING   |     10 |    | TURNER |     30 |    | ADAMS  |     20 |    | JAMES  |     30 |    | FORD   |     20 |    | MILLER |     10 |    +--------+--------+    mysql&gt; select * from dept;    +--------+------------+----------+    | DEPTNO | DNAME      | LOC      |    +--------+------------+----------+    |     10 | ACCOUNTING | NEW YORK |    |     20 | RESEARCH   | DALLAS   |    |     30 | SALES      | CHICAGO  |    |     40 | OPERATIONS | BOSTON   |    +--------+------------+----------+    两张表连接没有任何条件限制：    select ename,dname from emp, dept;    +--------+------------+    | ename  | dname      |    +--------+------------+    | SMITH  | ACCOUNTING |    | SMITH  | RESEARCH   |    | SMITH  | SALES      |    | SMITH  | OPERATIONS |    | ALLEN  | ACCOUNTING |    | ALLEN  | RESEARCH   |    | ALLEN  | SALES      |    | ALLEN  | OPERATIONS |    ...    56 rows in set (0.00 sec)    14 * 4 = 56    当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是    两张表条数的乘积，这种现象被称为：笛卡尔积现象。（笛卡尔发现的，这是    一个数学现象。）</code></pre><h3><span id="24-怎么避免笛卡尔积现象">2.4、怎么避免笛卡尔积现象？</span></h3><pre><code>连接时加条件，满足这个条件的记录被筛选出来！select     ename,dname from     emp, deptwhere    emp.deptno = dept.deptno;select     emp.ename,dept.dname from     emp, deptwhere    emp.deptno = dept.deptno;// 表起别名。很重要。效率问题。select     e.ename,d.dname from     emp e, dept dwhere    e.deptno = d.deptno; //SQL92语法。+--------+------------+| ename  | dname      |+--------+------------+| CLARK  | ACCOUNTING || KING   | ACCOUNTING || MILLER | ACCOUNTING || SMITH  | RESEARCH   || JONES  | RESEARCH   || SCOTT  | RESEARCH   || ADAMS  | RESEARCH   || FORD   | RESEARCH   || ALLEN  | SALES      || WARD   | SALES      || MARTIN | SALES      || BLAKE  | SALES      || TURNER | SALES      || JAMES  | SALES      |+--------+------------+思考：最终查询的结果条数是14条，但是匹配的过程中，匹配的次数减少了吗？    还是56次，只不过进行了四选一。次数没有减少。注意：通过笛卡尔积现象得出，表的连接次数越多效率越低，尽量避免表的连接次数。</code></pre><h3><span id="25-内连接之等值连接">2.5、内连接之等值连接。</span></h3><p>案例：查询每个员工所在部门名称，显示员工名和部门名？<br>emp e和dept d表进行连接。条件是：e.deptno &#x3D; d.deptno</p><p>SQL92语法：<br>    select<br>        e.ename,d.dname<br>    from<br>        emp e, dept d<br>    where<br>        e.deptno &#x3D; d.deptno;</p><pre><code>sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。</code></pre><p>SQL99语法：<br>    select<br>        e.ename,d.dname<br>    from<br>        emp e<br>    join<br>        dept d<br>    on<br>        e.deptno &#x3D; d.deptno;</p><pre><code>//inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）select     e.ename,d.dnamefrom    emp einner join    dept don    e.deptno = d.deptno; // 条件是等量关系，所以被称为等值连接。</code></pre><p>​sql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where<br>​<br>​SQL99语法：<br>​select<br>​…<br>​from<br>​a<br>​join<br>​b<br>​on<br>​a和b的连接条件<br>​where<br>​筛选条件</p><h3><span id="26-内连接之非等值连接">2.6、内连接之非等值连接</span></h3><p>案例：找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？<br>mysql&gt; select * from emp; e<br>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>….</p><p>mysql&gt; select * from salgrade; s<br>+——-+——-+——-+<br>| GRADE | LOSAL | HISAL |<br>+——-+——-+——-+<br>|     1 |   700 |  1200 |<br>|     2 |  1201 |  1400 |<br>|     3 |  1401 |  2000 |<br>|     4 |  2001 |  3000 |<br>|     5 |  3001 |  9999 |<br>+——-+——-+——-+</p><p>select<br>    e.ename, e.sal, s.grade<br>from<br>    emp e<br>join<br>    salgrade s<br>on<br>    e.sal between s.losal and s.hisal; &#x2F;&#x2F; 条件不是一个等量关系，称为非等值连接。</p><p>select<br>    e.ename, e.sal, s.grade<br>from<br>    emp e<br>inner join<br>    salgrade s<br>on<br>    e.sal between s.losal and s.hisal;</p><p>+——–+———+——-+<br>| ename  | sal     | grade |<br>+——–+———+——-+<br>| SMITH  |  800.00 |     1 |<br>| ALLEN  | 1600.00 |     3 |<br>| WARD   | 1250.00 |     2 |<br>| JONES  | 2975.00 |     4 |<br>| MARTIN | 1250.00 |     2 |<br>| BLAKE  | 2850.00 |     4 |<br>| CLARK  | 2450.00 |     4 |<br>| SCOTT  | 3000.00 |     4 |<br>| KING   | 5000.00 |     5 |<br>| TURNER | 1500.00 |     3 |<br>| ADAMS  | 1100.00 |     1 |<br>| JAMES  |  950.00 |     1 |<br>| FORD   | 3000.00 |     4 |<br>| MILLER | 1300.00 |     2 |<br>+——–+———+——-+</p><h3><span id="27-内连接之自连接">2.7、内连接之自连接</span></h3><p>案例：查询员工的上级领导，要求显示员工名和对应的领导名？</p><p>mysql&gt; select empno,ename,mgr from emp;<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+</p><p>技巧：一张表看成两张表。<br>emp a 员工表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+</p><p>emp b 领导表<br>+——-+——–+——+<br>| empno | ename  | mgr  |<br>+——-+——–+——+<br>|  7369 | SMITH  | 7902 |<br>|  7499 | ALLEN  | 7698 |<br>|  7521 | WARD   | 7698 |<br>|  7566 | JONES  | 7839 |<br>|  7654 | MARTIN | 7698 |<br>|  7698 | BLAKE  | 7839 |<br>|  7782 | CLARK  | 7839 |<br>|  7788 | SCOTT  | 7566 |<br>|  7839 | KING   | NULL |<br>|  7844 | TURNER | 7698 |<br>|  7876 | ADAMS  | 7788 |<br>|  7900 | JAMES  | 7698 |<br>|  7902 | FORD   | 7566 |<br>|  7934 | MILLER | 7782 |<br>+——-+——–+——+</p><p>select<br>    a.ename as ‘员工名’, b.ename as ‘领导名’<br>from<br>    emp a<br>join<br>    emp b<br>on<br>    a.mgr &#x3D; b.empno; &#x2F;&#x2F;员工的领导编号 &#x3D; 领导的员工编号</p><p>+——–+——–+<br>| 员工名 | 领导名|<br>+——–+——–+<br>| SMITH  | FORD   |<br>| ALLEN  | BLAKE  |<br>| WARD   | BLAKE  |<br>| JONES  | KING   |<br>| MARTIN | BLAKE  |<br>| BLAKE  | KING   |<br>| CLARK  | KING   |<br>| SCOTT  | JONES  |<br>| TURNER | BLAKE  |<br>| ADAMS  | SCOTT  |<br>| JAMES  | BLAKE  |<br>| FORD   | JONES  |<br>| MILLER | CLARK  |<br>+——–+——–+<br>13条记录，没有KING。《内连接》</p><p>以上就是内连接中的：自连接，技巧：一张表看做两张表。</p><h3><span id="28-外连接">2.8、外连接</span></h3><p>mysql&gt; select * from emp; e<br>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+</p><p>mysql&gt; select * from dept; d<br>+——–+————+———-+<br>| DEPTNO | DNAME      | LOC      |<br>+——–+————+———-+<br>|     10 | ACCOUNTING | NEW YORK |<br>|     20 | RESEARCH   | DALLAS   |<br>|     30 | SALES      | CHICAGO  |<br>|     40 | OPERATIONS | BOSTON   |<br>+——–+————+———-+</p><p>内连接：（A和B连接，AB两张表没有主次关系。平等的。）<br>select<br>    e.ename,d.dname<br>from<br>    emp e<br>join<br>    dept d<br>on<br>    e.deptno &#x3D; d.deptno; &#x2F;&#x2F;内连接的特点：完成能够匹配上这个条件的数据查询出来。</p><p>+——–+————+<br>| ename  | dname      |<br>+——–+————+<br>| CLARK  | ACCOUNTING |<br>| KING   | ACCOUNTING |<br>| MILLER | ACCOUNTING |<br>| SMITH  | RESEARCH   |<br>| JONES  | RESEARCH   |<br>| SCOTT  | RESEARCH   |<br>| ADAMS  | RESEARCH   |<br>| FORD   | RESEARCH   |<br>| ALLEN  | SALES      |<br>| WARD   | SALES      |<br>| MARTIN | SALES      |<br>| BLAKE  | SALES      |<br>| TURNER | SALES      |<br>| JAMES  | SALES      |<br>+——–+————+</p><p>外连接（右外连接）：<br>select<br>    e.ename,d.dname<br>from<br>    emp e<br>right join<br>    dept d<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>&#x2F;&#x2F; outer是可以省略的，带着可读性强。<br>select<br>    e.ename,d.dname<br>from<br>    emp e<br>right outer join<br>    dept d<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>right代表什么：表示将join关键字右边的这张表看成主表，主要是为了将<br>这张表的数据全部查询出来，捎带着关联查询左边的表。<br>在外连接当中，两张表连接，产生了主次关系。</p><p>外连接（左外连接）：<br>select<br>    e.ename,d.dname<br>from<br>    dept d<br>left join<br>    emp e<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>&#x2F;&#x2F; outer是可以省略的，带着可读性强。<br>select<br>    e.ename,d.dname<br>from<br>    dept d<br>left outer join<br>    emp e<br>on<br>    e.deptno &#x3D; d.deptno;</p><p>带有right的是右外连接，又叫做右连接。<br>带有left的是左外连接，又叫做左连接。<br>任何一个右连接都有左连接的写法。<br>任何一个左连接都有右连接的写法。</p><p>+——–+————+<br>| ename  | dname      |<br>+——–+————+<br>| CLARK  | ACCOUNTING |<br>| KING   | ACCOUNTING |<br>| MILLER | ACCOUNTING |<br>| SMITH  | RESEARCH   |<br>| JONES  | RESEARCH   |<br>| SCOTT  | RESEARCH   |<br>| ADAMS  | RESEARCH   |<br>| FORD   | RESEARCH   |<br>| ALLEN  | SALES      |<br>| WARD   | SALES      |<br>| MARTIN | SALES      |<br>| BLAKE  | SALES      |<br>| TURNER | SALES      |<br>| JAMES  | SALES      |<br>| NULL   | OPERATIONS |<br>+——–+————+</p><p>思考：外连接的查询结果条数一定是 &gt;&#x3D; 内连接的查询结果条数？<br>    正确。</p><p>案例：查询每个员工的上级领导，要求显示所有员工的名字和领导名？<br>    select<br>        a.ename as ‘员工名’, b.ename as ‘领导名’<br>    from<br>        emp a<br>    left join<br>        emp b<br>    on<br>        a.mgr &#x3D; b.empno; </p><pre><code>+--------+--------+| 员工名      | 领导名     |+--------+--------+| SMITH  | FORD   || ALLEN  | BLAKE  || WARD   | BLAKE  || JONES  | KING   || MARTIN | BLAKE  || BLAKE  | KING   || CLARK  | KING   || SCOTT  | JONES  || KING   | NULL   || TURNER | BLAKE  || ADAMS  | SCOTT  || JAMES  | BLAKE  || FORD   | JONES  || MILLER | CLARK  |+--------+--------+</code></pre><h3><span id="29-三张表四张表怎么连接">2.9、三张表，四张表怎么连接？</span></h3><pre><code>语法：    select         ...    from        a    join        b    on        a和b的连接条件    join        c    on        a和c的连接条件    right join        d    on        a和d的连接条件    一条SQL中内连接和外连接可以混合。都可以出现！案例：找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？select     e.ename,e.sal,d.dname,s.gradefrom    emp ejoin    dept don     e.deptno = d.deptnojoin    salgrade son    e.sal between s.losal and s.hisal;+--------+---------+------------+-------+| ename  | sal     | dname      | grade |+--------+---------+------------+-------+| SMITH  |  800.00 | RESEARCH   |     1 || ALLEN  | 1600.00 | SALES      |     3 || WARD   | 1250.00 | SALES      |     2 || JONES  | 2975.00 | RESEARCH   |     4 || MARTIN | 1250.00 | SALES      |     2 || BLAKE  | 2850.00 | SALES      |     4 || CLARK  | 2450.00 | ACCOUNTING |     4 || SCOTT  | 3000.00 | RESEARCH   |     4 || KING   | 5000.00 | ACCOUNTING |     5 || TURNER | 1500.00 | SALES      |     3 || ADAMS  | 1100.00 | RESEARCH   |     1 || JAMES  |  950.00 | SALES      |     1 || FORD   | 3000.00 | RESEARCH   |     4 || MILLER | 1300.00 | ACCOUNTING |     2 |+--------+---------+------------+-------+案例：找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？select     e.ename,e.sal,d.dname,s.grade,l.enamefrom    emp ejoin    dept don     e.deptno = d.deptnojoin    salgrade son    e.sal between s.losal and s.hisalleft join    emp lon    e.mgr = l.empno;+--------+---------+------------+-------+-------+| ename  | sal     | dname      | grade | ename |+--------+---------+------------+-------+-------+| SMITH  |  800.00 | RESEARCH   |     1 | FORD  || ALLEN  | 1600.00 | SALES      |     3 | BLAKE || WARD   | 1250.00 | SALES      |     2 | BLAKE || JONES  | 2975.00 | RESEARCH   |     4 | KING  || MARTIN | 1250.00 | SALES      |     2 | BLAKE || BLAKE  | 2850.00 | SALES      |     4 | KING  || CLARK  | 2450.00 | ACCOUNTING |     4 | KING  || SCOTT  | 3000.00 | RESEARCH   |     4 | JONES || KING   | 5000.00 | ACCOUNTING |     5 | NULL  || TURNER | 1500.00 | SALES      |     3 | BLAKE || ADAMS  | 1100.00 | RESEARCH   |     1 | SCOTT || JAMES  |  950.00 | SALES      |     1 | BLAKE || FORD   | 3000.00 | RESEARCH   |     4 | JONES || MILLER | 1300.00 | ACCOUNTING |     2 | CLARK |+--------+---------+------------+-------+-------+</code></pre><h2><span id="3-子查询">3、子查询？</span></h2><h3><span id="31-什么是子查询">3.1、什么是子查询？</span></h3><pre><code>select语句中嵌套select语句，被嵌套的select语句称为子查询。</code></pre><h3><span id="32-子查询都可以出现在哪里呢">3.2、子查询都可以出现在哪里呢？</span></h3><pre><code>select    ..(select).from    ..(select).where    ..(select).</code></pre><h3><span id="33-where子句中的子查询">3.3、where子句中的子查询</span></h3><pre><code>案例：找出比最低工资高的员工姓名和工资？    select         ename,sal    from        emp     where        sal &gt; min(sal);    ERROR 1111 (HY000): Invalid use of group function    where子句中不能直接使用分组函数。实现思路：    第一步：查询最低工资是多少        select min(sal) from emp;        +----------+        | min(sal) |        +----------+        |   800.00 |        +----------+    第二步：找出&gt;800的        select ename,sal from emp where sal &gt; 800;        第三步：合并        select ename,sal from emp where sal &gt; (select min(sal) from emp);        +--------+---------+        | ename  | sal     |        +--------+---------+        | ALLEN  | 1600.00 |        | WARD   | 1250.00 |        | JONES  | 2975.00 |        | MARTIN | 1250.00 |        | BLAKE  | 2850.00 |        | CLARK  | 2450.00 |        | SCOTT  | 3000.00 |        | KING   | 5000.00 |        | TURNER | 1500.00 |        | ADAMS  | 1100.00 |        | JAMES  |  950.00 |        | FORD   | 3000.00 |        | MILLER | 1300.00 |        +--------+---------+</code></pre><h3><span id="34-from子句中的子查询">3.4、from子句中的子查询</span></h3><pre><code>注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）案例：找出每个岗位的平均工资的薪资等级。第一步：找出每个岗位的平均工资（按照岗位分组求平均值）    select job,avg(sal) from emp group by job;    +-----------+-------------+    | job       | avgsal      |    +-----------+-------------+    | ANALYST   | 3000.000000 |    | CLERK     | 1037.500000 |    | MANAGER   | 2758.333333 |    | PRESIDENT | 5000.000000 |    | SALESMAN  | 1400.000000 |    +-----------+-------------+t表第二步：克服心理障碍，把以上的查询结果就当做一张真实存在的表t。mysql&gt; select * from salgrade; s表+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+|     1 |   700 |  1200 ||     2 |  1201 |  1400 ||     3 |  1401 |  2000 ||     4 |  2001 |  3000 ||     5 |  3001 |  9999 |+-------+-------+-------+t表和s表进行表连接，条件：t表avg(sal) between s.losal and s.hisal;        select         t.*, s.grade    from        (select job,avg(sal) as avgsal from emp group by job) t    join        salgrade s    on        t.avgsal between s.losal and s.hisal;        +-----------+-------------+-------+    | job       | avgsal      | grade |    +-----------+-------------+-------+    | CLERK     | 1037.500000 |     1 |    | SALESMAN  | 1400.000000 |     2 |    | ANALYST   | 3000.000000 |     4 |    | MANAGER   | 2758.333333 |     4 |    | PRESIDENT | 5000.000000 |     5 |    +-----------+-------------+-------+</code></pre><h3><span id="35-select后面出现的子查询这个内容不需要掌握了解即可">3.5、select后面出现的子查询（这个内容不需要掌握，了解即可！！！）</span></h3><p>案例：找出每个员工的部门名称，要求显示员工名，部门名？<br>    select<br>        e.ename,e.deptno,(select d.dname from dept d where e.deptno &#x3D; d.deptno) as dname<br>    from<br>        emp e;</p><pre><code>+--------+--------+------------+| ename  | deptno | dname      |+--------+--------+------------+| SMITH  |     20 | RESEARCH   || ALLEN  |     30 | SALES      || WARD   |     30 | SALES      || JONES  |     20 | RESEARCH   || MARTIN |     30 | SALES      || BLAKE  |     30 | SALES      || CLARK  |     10 | ACCOUNTING || SCOTT  |     20 | RESEARCH   || KING   |     10 | ACCOUNTING || TURNER |     30 | SALES      || ADAMS  |     20 | RESEARCH   || JAMES  |     30 | SALES      || FORD   |     20 | RESEARCH   || MILLER |     10 | ACCOUNTING |+--------+--------+------------+//错误：ERROR 1242 (21000): Subquery returns more than 1 rowselect     e.ename,e.deptno,(select dname from dept) as dnamefrom    emp e;注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果，多于1条，就报错了。！</code></pre><h2><span id="4-union合并查询结果集">4、union合并查询结果集</span></h2><pre><code>案例：查询工作岗位是MANAGER和SALESMAN的员工？    select ename,job from emp where job = &#39;MANAGER&#39; or job = &#39;SALESMAN&#39;;    select ename,job from emp where job in(&#39;MANAGER&#39;,&#39;SALESMAN&#39;);    +--------+----------+    | ename  | job      |    +--------+----------+    | ALLEN  | SALESMAN |    | WARD   | SALESMAN |    | JONES  | MANAGER  |    | MARTIN | SALESMAN |    | BLAKE  | MANAGER  |    | CLARK  | MANAGER  |    | TURNER | SALESMAN |    +--------+----------+</code></pre><pre><code>select ename,job from emp where job = &#39;MANAGER&#39;unionselect ename,job from emp where job = &#39;SALESMAN&#39;;+--------+----------+| ename  | job      |+--------+----------+| JONES  | MANAGER  || BLAKE  | MANAGER  || CLARK  | MANAGER  || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+union的效率要高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。。。但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。a 连接 b 连接 ca 10条记录b 10条记录c 10条记录匹配次数是：1000a 连接 b一个结果：10 * 10 --&gt; 100次a 连接 c一个结果：10 * 10 --&gt; 100次使用union的话是：100次 + 100次 = 200次。（union把乘法变成了加法运算）</code></pre><p>union在使用的时候有注意事项吗？</p><pre><code>//错误的：union在进行结果集合并的时候，要求两个结果集的列数相同。select ename,job from emp where job = &#39;MANAGER&#39;unionselect ename from emp where job = &#39;SALESMAN&#39;;// MYSQL可以，oracle语法严格 ，不可以，报错。要求：结果集合并时列和列的数据类型也要一致。select ename,job from emp where job = &#39;MANAGER&#39;unionselect ename,sal from emp where job = &#39;SALESMAN&#39;;+--------+---------+| ename  | job     |+--------+---------+| JONES  | MANAGER || BLAKE  | MANAGER || CLARK  | MANAGER || ALLEN  | 1600    || WARD   | 1250    || MARTIN | 1250    || TURNER | 1500    |+--------+---------+</code></pre><h2><span id="5-limit非常重要">5、limit（非常重要）</span></h2><h3><span id="51-limit作用将查询结果集的一部分取出来-通常使用在分页查询当中">5.1、limit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。</span></h3><p>百度默认：一页显示10条记录。<br>分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。<br>可以一页一页翻页看。</p><h3><span id="52-limit怎么用呢">5.2、limit怎么用呢？</span></h3><pre><code>完整用法：limit startIndex, length    startIndex是起始下标，length是长度。    起始下标从0开始。缺省用法：limit 5; 这是取前5.按照薪资降序，取出排名在前5名的员工？select     ename,salfrom    emporder by     sal desclimit 5; //取前5select     ename,salfrom    emporder by     sal desclimit 0,5;+-------+---------+| ename | sal     |+-------+---------+| KING  | 5000.00 || SCOTT | 3000.00 || FORD  | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+</code></pre><h3><span id="53-注意mysql当中limit在order-by之后执行">5.3、注意：mysql当中limit在order by之后执行！！！！！！</span></h3><h3><span id="54-取出工资排名在3-5名的员工">5.4、取出工资排名在[3-5]名的员工？</span></h3><pre><code>select     ename,salfrom    emporder by    sal desclimit    2, 3;2表示起始位置从下标2开始，就是第三条记录。3表示长度。+-------+---------+| ename | sal     |+-------+---------+| FORD  | 3000.00 || JONES | 2975.00 || BLAKE | 2850.00 |+-------+---------+</code></pre><h3><span id="55-取出工资排名在5-9名的员工">5.5、取出工资排名在[5-9]名的员工？</span></h3><pre><code>select     ename,salfrom    emporder by     sal desclimit    4, 5;+--------+---------+| ename  | sal     |+--------+---------+| BLAKE  | 2850.00 || CLARK  | 2450.00 || ALLEN  | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 |+--------+---------+</code></pre><h3><span id="56-分页">5.6、分页</span></h3><p>每页显示3条记录<br>    第1页：limit 0,3[0 1 2]<br>    第2页：limit 3,3[3 4 5]<br>    第3页：limit 6,3[6 7 8]<br>    第4页：limit 9,3[9 10 11]</p><p>每页显示pageSize条记录<br>    &#x3D;&#x3D;第pageNo页：limit (pageNo - 1) * pageSize  , pageSize&#x3D;&#x3D;</p><pre><code>public static void main(String[] args)&#123;    // 用户提交过来一个页码，以及每页显示的记录条数    int pageNo = 5; //第5页    int pageSize = 10; //每页显示10条    int startIndex = (pageNo - 1) * pageSize;    String sql = &quot;select ...limit &quot; + startIndex + &quot;, &quot; + pageSize;&#125;</code></pre><p>记公式：<br>    limit (pageNo-1)*pageSize , pageSize</p><h2><span id="6-关于dql语句的大总结">6、关于DQL语句的大总结：</span></h2><pre><code>select     ...from    ...where    ...group by    ...having    ...order by    ...limit    ...执行顺序？    1.from    2.where    3.group by    4.having    5.select    6.order by    7.limit..</code></pre><h2><span id="7-表的创建建表">7、表的创建（建表）</span></h2><h3><span id="71-建表的语法格式建表属于ddl语句ddl包括create-drop-alter">7.1、建表的语法格式：(建表属于DDL语句，DDL包括：create drop alter)</span></h3><pre><code>create table 表名(字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型);create table 表名(    字段名1 数据类型,     字段名2 数据类型,     字段名3 数据类型);表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。字段名：见名知意。表名和字段名都属于标识符。</code></pre><h3><span id="72-关于mysql中的数据类型">7.2、关于mysql中的数据类型？</span></h3><pre><code>很多数据类型，我们只需要掌握一些常见的数据类型即可。    varchar(最长255)        可变长度的字符串        比较智能，节省空间。        会根据实际的数据长度动态分配空间。        优点：节省空间        缺点：需要动态分配空间，速度慢。    char(最长255)        定长字符串        不管实际的数据长度是多少。        分配固定长度的空间去存储数据。        使用不恰当的时候，可能会导致空间的浪费。        优点：不需要动态分配空间，速度快。        缺点：使用不当可能会导致空间的浪费。        varchar和char我们应该怎么选择？            性别字段你选什么？因为性别是固定长度的字符串，所以选择char。            姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。    int(最长11)        数字中的整数型。等同于java的int。    bigint        数字中的长整型。等同于java中的long。    float        单精度浮点型数据    double        双精度浮点型数据    date        短日期类型    datetime        长日期类型    clob        字符大对象        最多可以存储4G的字符串。        比如：存储一篇文章，存储一个说明。        超过255个字符的都要采用CLOB字符大对象来存储。        Character Large OBject:CLOB    blob        二进制大对象        Binary Large OBject        专门用来存储图片、声音、视频等流媒体数据。        往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，        你需要使用IO流才行。t_movie 电影表（专门存储电影信息的）编号名字故事情节上映日期时长海报类型no(bigint)name(varchar)history(clob)playtime(date)time(double)image(blob)type(char)------------------------------------------------------------------------------------------------------------------10000哪吒...........2019-10-112.5....&#39;1&#39;10001林正英之娘娘   ...........2019-11-111.5....&#39;2&#39;....</code></pre><h3><span id="73-创建一个学生表">7.3、创建一个学生表？</span></h3><pre><code>学号、姓名、年龄、性别、邮箱地址create table t_student(    no int,    name varchar(32),    sex char(1),    age int(3),    email varchar(255));删除表：    drop table t_student; // 当这张表不存在的时候会报错！    // 如果这张表存在的话，删除    drop table if exists t_student;</code></pre><h3><span id="74-插入数据insert-dml">7.4、插入数据insert （DML）</span></h3><p>​</p><pre><code>语法格式：    insert into 表名(字段名1,字段名2,字段名3...) values(值1,值2,值3);    注意：字段名和值要一一对应。什么是一一对应？        数量要对应。数据类型要对应。insert into t_student(no,name,sex,age,email) values(1,&#39;zhangsan&#39;,&#39;m&#39;,20,&#39;zhangsan@123.com&#39;);insert into t_student(email,name,sex,age,no) values(&#39;lisi@123.com&#39;,&#39;lisi&#39;,&#39;f&#39;,20,2);insert into t_student(no) values(3);+------+----------+------+------+------------------+| no   | name     | sex  | age  | email            |+------+----------+------+------+------------------+|    1 | zhangsan | m    |   20 | zhangsan@123.com ||    2 | lisi     | f    |   20 | lisi@123.com     ||    3 | NULL     | NULL | NULL | NULL             |+------+----------+------+------+------------------+insert into t_student(name) values(&#39;wangwu&#39;);+------+----------+------+------+------------------+| no   | name     | sex  | age  | email            |+------+----------+------+------+------------------+|    1 | zhangsan | m    |   20 | zhangsan@123.com ||    2 | lisi     | f    |   20 | lisi@123.com     ||    3 | NULL     | NULL | NULL | NULL             || NULL | wangwu   | NULL | NULL | NULL             |+------+----------+------+------+------------------+注意：insert语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。drop table if exists t_student;create table t_student(    no int,    name varchar(32),    sex char(1) default &#39;m&#39;,    age int(3),    email varchar(255));+-------+--------------+------+-----+---------+-------+| Field | Type         | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| no    | int(11)      | YES  |     | NULL    |       || name  | varchar(32)  | YES  |     | NULL    |       || sex   | char(1)      | YES  |     | m       |       || age   | int(3)       | YES  |     | NULL    |       || email | varchar(255) | YES  |     | NULL    |       |+-------+--------------+------+-----+---------+-------+insert into t_student(no) values(1);mysql&gt; select * from t_student;+------+------+------+------+-------+| no   | name | sex  | age  | email |+------+------+------+------+-------+|    1 | NULL | m    | NULL | NULL  |+------+------+------+------+-------+insert语句中的“字段名”可以省略吗？可以    insert into t_student values(2); //错误的    // 注意：前面的字段名省略的话，等于都写上了！所以值也要都写上！    insert into t_student values(2, &#39;lisi&#39;, &#39;f&#39;, 20, &#39;lisi@123.com&#39;);    +------+------+------+------+--------------+    | no   | name | sex  | age  | email        |    +------+------+------+------+--------------+    |    1 | NULL | m    | NULL | NULL         |    |    2 | lisi | f    |   20 | lisi@123.com |    +------+------+------+------+--------------+</code></pre><h3><span id="75-insert插入日期">7.5、insert插入日期</span></h3><pre><code>数字格式化：format    select ename,sal from emp;    +--------+---------+    | ename  | sal     |    +--------+---------+    | SMITH  |  800.00 |    | ALLEN  | 1600.00 |    | WARD   | 1250.00 |    | JONES  | 2975.00 |    | MARTIN | 1250.00 |    | BLAKE  | 2850.00 |    | CLARK  | 2450.00 |    | SCOTT  | 3000.00 |    | KING   | 5000.00 |    | TURNER | 1500.00 |    | ADAMS  | 1100.00 |    | JAMES  |  950.00 |    | FORD   | 3000.00 |    | MILLER | 1300.00 |    +--------+---------+    格式化数字：format(数字, &#39;格式&#39;)        select ename,format(sal, &#39;$999,999&#39;) as sal from emp;        +--------+-------+        | ename  | sal   |        +--------+-------+        | SMITH  | 800   |        | ALLEN  | 1,600 |        | WARD   | 1,250 |        | JONES  | 2,975 |        | MARTIN | 1,250 |        | BLAKE  | 2,850 |        | CLARK  | 2,450 |        | SCOTT  | 3,000 |        | KING   | 5,000 |        | TURNER | 1,500 |        | ADAMS  | 1,100 |        | JAMES  | 950   |        | FORD   | 3,000 |        | MILLER | 1,300 |        +--------+-------+str_to_date：将字符串varchar类型转换成date类型date_format：将date类型转换成具有一定格式的varchar字符串类型。drop table if exists t_user;create table t_user(    id int,    name varchar(32),    birth date // 生日也可以使用date日期类型);create table t_user(    id int,    name varchar(32),    birth char(10) // 生日可以使用字符串，没问题。);生日：1990-10-11 （10个字符）注意：数据库中的有一条命名规范：    所有的标识符都是全部小写，单词和单词之间使用下划线进行衔接。mysql&gt; desc t_user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(32) | YES  |     | NULL    |       || birth | date        | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+插入数据？    insert into t_user(id,name,birth) values(1, &#39;zhangsan&#39;, &#39;01-10-1990&#39;); // 1990年10月1日    出问题了：原因是类型不匹配。数据库birth是date类型，这里给了一个字符串varchar。    怎么办？可以使用str_to_date函数进行类型转换。    str_to_date函数可以将字符串转换成日期类型date？    语法格式：        str_to_date(&#39;字符串日期&#39;, &#39;日期格式&#39;)    mysql的日期格式：        %Y年        %m 月        %d 日        %h时        %i分        %s秒        insert into t_user(id,name,birth) values(1, &#39;zhangsan&#39;, str_to_date(&#39;01-10-1990&#39;,&#39;%d-%m-%Y&#39;));    str_to_date函数可以把字符串varchar转换成日期date类型数据，    通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，    需要通过该函数将字符串转换成date。好消息？    如果你提供的日期字符串是这个格式，str_to_date函数就不需要了！！！        %Y-%m-%d    insert into t_user(id,name,birth) values(2, &#39;lisi&#39;, &#39;1990-10-01&#39;);查询的时候可以以某个特定的日期格式展示吗？    date_format    这个函数可以将日期类型转换成特定格式的字符串。    select id,name,date_format(birth, &#39;%m/%d/%Y&#39;) as birth from t_user;    +------+----------+------------+    | id   | name     | birth      |    +------+----------+------------+    |    1 | zhangsan | 10/01/1990 |    |    2 | lisi     | 10/01/1990 |    +------+----------+------------+    date_format函数怎么用？        date_format(日期类型数据, &#39;日期格式&#39;)        这个函数通常使用在查询日期方面。设置展示的日期格式。        mysql&gt; select id,name,birth from t_user;    +------+----------+------------+    | id   | name     | birth      |    +------+----------+------------+    |    1 | zhangsan | 1990-10-01 |    |    2 | lisi     | 1990-10-01 |    +------+----------+------------+    以上的SQL语句实际上是进行了默认的日期格式化，    自动将数据库中的date类型转换成varchar类型。    并且采用的格式是mysql默认的日期格式：&#39;%Y-%m-%d&#39;    select id,name,date_format(birth,&#39;%Y/%m/%d&#39;) as birth from t_user;        java中的日期格式？        yyyy-MM-dd HH:mm:ss SSS</code></pre><h3><span id="76-date和datetime两个类型的区别">7.6、date和datetime两个类型的区别？</span></h3><pre><code>date是短日期：只包括年月日信息。datetime是长日期：包括年月日时分秒信息。drop table if exists t_user;create table t_user(    id int,    name varchar(32),    birth date,    create_time datetime);id是整数name是字符串birth是短日期create_time是这条记录的创建时间：长日期类型mysql短日期默认格式：%Y-%m-%dmysql长日期默认格式：%Y-%m-%d %h:%i:%sinsert into t_user(id,name,birth,create_time) values(1,&#39;zhangsan&#39;,&#39;1990-10-01&#39;,&#39;2020-03-18 15:49:50&#39;);在mysql当中怎么获取系统当前时间？    now() 函数，并且获取的时间带有：时分秒信息！！！！是datetime类型的。    insert into t_user(id,name,birth,create_time) values(2,&#39;lisi&#39;,&#39;1991-10-01&#39;,now());</code></pre><h3><span id="77-修改updatedml">7.7、修改update（DML）</span></h3><p>语法格式：<br>    update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2,字段名3&#x3D;值3… where 条件;</p><pre><code>注意：没有条件限制会导致所有数据全部更新。update t_user set name = &#39;jack&#39;, birth = &#39;2000-10-11&#39; where id = 2;+------+----------+------------+---------------------+| id   | name     | birth      | create_time         |+------+----------+------------+---------------------+|    1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 ||    2 | jack     | 2000-10-11 | 2020-03-18 15:51:23 |+------+----------+------------+---------------------+update t_user set name = &#39;jack&#39;, birth = &#39;2000-10-11&#39;, create_time = now() where id = 2;更新所有？    update t_user set name = &#39;abc&#39;;</code></pre><h3><span id="78-删除数据-delete-dml">7.8、删除数据 delete （DML）</span></h3><pre><code>语法格式？    delete from 表名 where 条件;注意：没有条件，整张表的数据会全部删除！delete from t_user where id = 2;insert into t_user(id) values(2);delete from t_user; // 删除所有！</code></pre><h1><span id="mysql-day03课堂笔记">mysql day03课堂笔记</span></h1><h2><span id="1-查询每一个员工的所在部门名称要求显示员工名和部门名">1、查询每一个员工的所在部门名称？要求显示员工名和部门名。</span></h2><pre><code>mysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+</code></pre><pre><code>mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+</code></pre><p>从emp表中取ename，从dept表中取dname，没有条件限制最终查询结果是？</p><pre><code>ENAMEDNAMESMITHACCOUNTING无效记录SMITHRESEARCH有效记录SMITHSALES无效记录SMITHOPERATIONS无效记录ALLENACCOUNTINGALLENRESEARCHALLENSALESALLENOPERATIONS.....56条记录。加个条件是为了达到4选1，也是</code></pre><p>为了数据的有效性。</p><pre><code>select     e.ename,d.dnamefrom    emp ejoin    dept don    e.deptno = d.deptno;加条件只是为了避免笛卡尔积现象，只是为了查询出有效的组合记录。匹配的次数一次都没有少，还是56次。</code></pre><h2><span id="2-insert语句可以一次插入多条记录吗掌握">2、insert语句可以一次插入多条记录吗？【掌握】</span></h2><pre><code>可以的！mysql&gt; desc t_user;+-------------+-------------+------+-----+---------+-------+| Field       | Type        | Null | Key | Default | Extra |+-------------+-------------+------+-----+---------+-------+| id          | int(11)     | YES  |     | NULL    |       || name        | varchar(32) | YES  |     | NULL    |       || birth       | date        | YES  |     | NULL    |       || create_time | datetime    | YES  |     | NULL    |       |+-------------+-------------+------+-----+---------+-------+一次可以插入多条记录：    insert into t_user(id,name,birth,create_time) values    (1,&#39;zs&#39;,&#39;1980-10-11&#39;,now()),     (2,&#39;lisi&#39;,&#39;1981-10-11&#39;,now()),    (3,&#39;wangwu&#39;,&#39;1982-10-11&#39;,now());    语法：insert into t_user(字段名1,字段名2) values(),(),(),();mysql&gt; select * from t_user;+------+--------+------------+---------------------+| id   | name   | birth      | create_time         |+------+--------+------------+---------------------+|    1 | zs     | 1980-10-11 | 2020-03-19 09:37:01 ||    2 | lisi   | 1981-10-11 | 2020-03-19 09:37:01 ||    3 | wangwu | 1982-10-11 | 2020-03-19 09:37:01 |+------+--------+------------+---------------------+</code></pre><h2><span id="3-快速创建表了解内容">3、快速创建表？【了解内容】</span></h2><pre><code>mysql&gt; create table emp2 as select * from emp;原理：    将一个查询结果当做一张表新建！！！！！    这个可以完成表的快速复制！！！！    表创建出来，同时表中的数据也存在了！！！create table mytable as select empno,ename from emp where job = &#39;MANAGER&#39;;</code></pre><h2><span id="4-x3dx3d将查询结果插入到一张表当中x3dx3dinsert相关的了解内容">4、&#x3D;&#x3D;将查询结果插入到一张表当中&#x3D;&#x3D;？insert相关的！！！【了解内容】</span></h2><pre><code>create table dept_bak as select * from dept;mysql&gt; select * from dept_bak;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+insert into dept_bak select * from dept; //很少用！mysql&gt; select * from dept_bak;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   ||     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+</code></pre><h2><span id="5-快速删除表中的数据truncate比较重要必须掌握">5、快速删除表中的数据？【truncate比较重要，必须掌握】</span></h2><pre><code>//删除dept_bak表中的数据delete from dept_bak; //这种删除数据的方式比较慢。mysql&gt; select * from dept_bak;Empty set (0.00 sec)delete语句删除数据的原理？（delete属于DML语句！！！）    表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！    这种删除缺点是：删除效率比较低。    这种删除优点是：支持回滚，后悔了可以再恢复数据！！！truncate语句删除数据的原理？    这种删除效率比较高，表被一次截断，物理删除。    这种删除缺点：不支持回滚。    这种删除优点：快速。用法：truncate table dept_bak; （这种操作属于DDL操作。）大表非常大，上亿条记录？？？？    删除的时候，使用delete，也许需要执行1个小时才能删除完！效率较低。    可以选择使用truncate删除表中的数据。只需要不到1秒钟的时间就删除结束。效率较高。    但是使用truncate之前，必须仔细询问客户是否真的要删除，并警告删除之后不可恢复！    truncate是删除表中的数据，表还在！删除表操作？    drop table 表名; // 这不是删除表中的数据，这是把表删除。</code></pre><h2><span id="6-对表结构的增删改">6、对表结构的增删改？</span></h2><p>​</p><pre><code>什么是对表结构的修改？    添加一个字段，删除一个字段，修改一个字段！！！对表结构的修改需要使用：alter属于DDL语句DDL包括：create drop alter第一：在实际的开发中，需求一旦确定之后，表一旦设计好之后，很少的进行表结构的修改。因为开发进行中的时候，修改表结构，成本比较高。修改表的结构，对应的java代码就需要进行大量的修改。成本是比较高的。这个责任应该由设计人员来承担！第二：由于修改表结构的操作很少，所以我们不需要掌握，如果有一天真的要修改表结构，你可以使用工具！！！！修改表结构的操作是不需要写到java程序中的。实际上也不是java程序员的范畴。</code></pre><h2><span id="7-约束非常重要五颗星">7、约束（非常重要，五颗星*****）</span></h2><h3><span id="71-什么是约束">7.1、什么是约束？</span></h3><pre><code>约束对应的英语单词：constraint在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！约束的作用就是为了保证：表中的数据有效！！</code></pre><h3><span id="72-约束包括哪些">7.2、约束包括哪些？</span></h3><pre><code>非空约束：not null唯一性约束: unique主键约束: primary key （简称PK）外键约束：foreign key（简称FK）检查约束：check（mysql不支持，oracle支持）我们这里重点学习四个约束：    not null    unique    primary key    foreign key</code></pre><h3><span id="73-非空约束not-null">7.3、非空约束：not null</span></h3><p>null和任何值运算得到的结果仍然是null，这点需要注意，不要在表达式中对null值进行运算。</p><pre><code>非空约束not null约束的字段不能为NULL。drop table if exists t_vip;create table t_vip(    id int,    name varchar(255) not null  // not null只有列级约束，没有表级约束！);insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);insert into t_vip(id,name) values(2,&#39;lisi&#39;);insert into t_vip(id) values(3);ERROR 1364 (HY000): Field &#39;name&#39; doesn&#39;t have a default value小插曲：    xxxx.sql这种文件被称为sql脚本文件。    sql脚本文件中编写了大量的sql语句。    我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！    批量的执行SQL语句，可以使用sql脚本文件。    在mysql当中怎么执行sql脚本呢？        mysql&gt; source D:\course\03-MySQL\document\vip.sql        你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，    你执行这个脚本文件，你电脑上的数据库数据就有了！</code></pre><h3><span id="74-唯一性约束-unique">7.4、唯一性约束: unique</span></h3><pre><code>唯一性约束unique约束的字段不能重复，但是可以为NULL。drop table if exists t_vip;create table t_vip(    id int,    name varchar(255) unique,    email varchar(255));insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);insert into t_vip(id,name,email) values(2,&#39;lisi&#39;,&#39;lisi@123.com&#39;);insert into t_vip(id,name,email) values(3,&#39;wangwu&#39;,&#39;wangwu@123.com&#39;);select * from t_vip;insert into t_vip(id,name,email) values(4,&#39;wangwu&#39;,&#39;wangwu@sina.com&#39;);ERROR 1062 (23000): Duplicate entry &#39;wangwu&#39; for key &#39;name&#39;insert into t_vip(id) values(4);insert into t_vip(id) values(5);+------+----------+------------------+| id   | name     | email            |+------+----------+------------------+|    1 | zhangsan | zhangsan@123.com ||    2 | lisi     | lisi@123.com     ||    3 | wangwu   | wangwu@123.com   ||    4 | NULL     | NULL             ||    5 | NULL     | NULL             |+------+----------+------------------+name字段虽然被unique约束了，但是可以为NULL。新需求：name和email两个字段联合起来具有唯一性！！！！    drop table if exists t_vip;    create table t_vip(        id int,        name varchar(255) unique,  // 约束直接添加到列后面的，叫做列级约束。        email varchar(255) unique    );    这张表这样创建是不符合我以上“新需求”的。    这样创建表示：name具有唯一性，email具有唯一性。各自唯一。    以下这样的数据是符合我“新需求”的。    但如果采用以上方式创建表的话，肯定创建失败，因为&#39;zhangsan&#39;和&#39;zhangsan&#39;重复了。    insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);    insert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);    怎么创建这样的表，才能符合新需求呢？        drop table if exists t_vip;        create table t_vip(            id int,            name varchar(255),            email varchar(255),            unique(name,email) // 约束没有添加在列的后面，这种约束被称为表级约束。        );        insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);        insert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);        select * from t_vip;        name和email两个字段联合起来唯一！！！        insert into t_vip(id,name,email) values(3,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);        ERROR 1062 (23000): Duplicate entry &#39;zhangsan-zhangsan@sina.com&#39; for key &#39;name&#39;    什么时候使用表级约束呢？        需要给多个字段联合起来添加某一个约束的时候，需要使用表级约束。unique 和not null可以联合吗？    drop table if exists t_vip;    create table t_vip(        id int,        name varchar(255) not null unique    );    mysql&gt; desc t_vip;    +-------+--------------+------+-----+---------+-------+    | Field | Type         | Null | Key | Default | Extra |    +-------+--------------+------+-----+---------+-------+    | id    | int(11)      | YES  |     | NULL    |       |    | name  | varchar(255) | NO   | PRI | NULL    |       |    +-------+--------------+------+-----+---------+-------+    在mysql当中，如果一个字段同时被not null和unique约束的话，    该字段自动变成主键字段。（注意：oracle中不一样！）    insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);    insert into t_vip(id,name) values(2,&#39;zhangsan&#39;); //错误了：name不能重复    insert into t_vip(id) values(2); //错误了：name不能为NULL。</code></pre><h3><span id="75-主键约束primary-key简称pk非常重要五颗星">7.5、主键约束（primary key，简称PK）非常重要五颗星*****</span></h3><pre><code>主键约束的相关术语？    主键约束：就是一种约束。    主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段    主键值：主键字段中的每一个值都叫做：主键值。什么是主键？有啥用？    主键值是每一行记录的唯一标识。    主键值是每一行记录的身份证号！！！记住：任何一张表都应该有主键，没有主键，表无效！！主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）怎么给一张表添加主键约束呢？    drop table if exists t_vip;    // 1个字段做主键，叫做：单一主键    create table t_vip(        id int primary key,  //列级约束        name varchar(255)    );    insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);    insert into t_vip(id,name) values(2,&#39;lisi&#39;);    //错误：不能重复    insert into t_vip(id,name) values(2,&#39;wangwu&#39;);    ERROR 1062 (23000): Duplicate entry &#39;2&#39; for key &#39;PRIMARY&#39;    //错误：不能为NULL    insert into t_vip(name) values(&#39;zhaoliu&#39;);    ERROR 1364 (HY000): Field &#39;id&#39; doesn&#39;t have a default value可以这样添加主键吗，使用表级约束？    drop table if exists t_vip;    create table t_vip(        id int,        name varchar(255),        primary key(id)  // 表级约束    );    insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);    //错误    insert into t_vip(id,name) values(1,&#39;lisi&#39;);    ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39;表级约束主要是给多个字段联合起来添加约束？    drop table if exists t_vip;    // id和name联合起来做主键：复合主键！！！！    create table t_vip(        id int,        name varchar(255),        email varchar(255),        primary key(id,name)    );    insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);    insert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);    //错误：不能重复    insert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);    ERROR 1062 (23000): Duplicate entry &#39;1-lisi&#39; for key &#39;PRIMARY&#39;    在实际开发中不建议使用：复合主键。建议使用单一主键！    因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。    复合主键比较复杂，不建议使用！！！一个表中主键约束能加两个吗？    drop table if exists t_vip;    create table t_vip(        id int primary key,        name varchar(255) primary key    );    ERROR 1068 (42000): Multiple primary key defined    结论：一张表，主键约束只能添加1个。（主键只能有1个。）主键值建议使用：    int    bigint    char    等类型。    不建议使用：varchar来做主键。主键值一般都是数字，一般都是定长的！主键除了：单一主键和复合主键之外，还可以这样进行分类？    自然主键：主键值是一个自然数，和业务没关系。    业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！    在实际开发中使用业务主键多，还是使用自然主键多一些？        自然主键使用比较多，因为主键只要做到不重复就行，不需要有意义。        业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候，        可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。在mysql当中，有一种机制，可以帮助我们自动维护一个主键值？    drop table if exists t_vip;    create table t_vip(        id int primary key auto_increment, //auto_increment表示自增，从1开始，以1递增！        name varchar(255)    );    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    insert into t_vip(name) values(&#39;zhangsan&#39;);    select * from t_vip;    +----+----------+    | id | name     |    +----+----------+    |  1 | zhangsan |    |  2 | zhangsan |    |  3 | zhangsan |    |  4 | zhangsan |    |  5 | zhangsan |    |  6 | zhangsan |    |  7 | zhangsan |    |  8 | zhangsan |    +----+----------+</code></pre><h3><span id="76-外键约束foreign-key简称fk非常重要五颗星">7.6、外键约束（foreign key，简称FK）非常重要五颗星*****</span></h3><pre><code>外键约束涉及到的相关术语：    外键约束：一种约束（foreign key）    外键字段：该字段上添加了外键约束    外键值：外键字段当中的每一个值。业务背景：    请设计数据库表，来描述“班级和学生”的信息？    第一种方案：班级和学生存储在一张表中？？？    t_student    no(pk)nameclassnoclassname    ----------------------------------------------------------------------------------    1jack100北京市大兴区亦庄镇第二中学高三1班    2lucy100北京市大兴区亦庄镇第二中学高三1班    3lilei100北京市大兴区亦庄镇第二中学高三1班    4hanmeimei100北京市大兴区亦庄镇第二中学高三1班    5zhangsan101北京市大兴区亦庄镇第二中学高三2班    6lisi101北京市大兴区亦庄镇第二中学高三2班    7wangwu101北京市大兴区亦庄镇第二中学高三2班    8zhaoliu101北京市大兴区亦庄镇第二中学高三2班    分析以上方案的缺点：        数据冗余，空间浪费！！！！        这个设计是比较失败的！        第二种方案：班级一张表、学生一张表？？        t_class 班级表    classno(pk)classname    ------------------------------------------------------    100北京市大兴区亦庄镇第二中学高三1班    101北京市大兴区亦庄镇第二中学高三1班    t_student 学生表    no(pk)namecno(FK引用t_class这张表的classno)    ----------------------------------------------------------------    1jack100    2lucy100    3lilei100    4hanmeimei100    5zhangsan101    6lisi101    7wangwu101    8zhaoliu101    当cno字段没有任何约束的时候，可能会导致数据无效。可能出现一个102，但是102班级不存在。    所以为了保证cno字段中的值都是100和101，需要给cno字段添加外键约束。    那么：cno字段就是外键字段。cno字段中的每一个值都是外键值。    注意：        t_class是父表        t_student是子表        删除表的顺序？            先删子，再删父。        创建表的顺序？            先创建父，再创建子。        删除数据的顺序？            先删子，再删父。        插入数据的顺序？            先插入父，再插入子。    思考：子表中的外键引用的父表中的某个字段，被引用的这个字段必须是主键吗？        不一定是主键，但至少具有unique约束。    测试：外键可以为NULL吗？        外键值可以为NULL。</code></pre><h2><span id="8-存储引擎了解内容">8、存储引擎（了解内容）</span></h2><h3><span id="81-什么是存储引擎有什么用呢">8.1、什么是存储引擎，有什么用呢？</span></h3><pre><code>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）存储引擎这个名字高端大气上档次。实际上存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。</code></pre><h3><span id="82-怎么给表添加x2f指定存储引擎呢">8.2、怎么给表添加&#x2F;指定“存储引擎”呢？</span></h3><pre><code>show create table t_student;可以在建表的时候给表指定存储引擎。CREATE TABLE `t_student` (  `no` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `cno` int(11) DEFAULT NULL,  PRIMARY KEY (`no`),  KEY `cno` (`cno`),  CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`classno`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8在建表的时候可以在最后小括号的&quot;)&quot;的右边使用：    ENGINE来指定存储引擎。    CHARSET来指定这张表的字符编码方式。    结论：        mysql默认的存储引擎是：InnoDB        mysql默认的字符编码方式是：utf8建表时指定存储引擎，以及字符编码方式。create table t_product(    id int primary key,    name varchar(255))engine=InnoDB default charset=gbk;</code></pre><h3><span id="83-怎么查看mysql支持哪些存储引擎呢">8.3、怎么查看mysql支持哪些存储引擎呢？</span></h3><p>mysql&gt; select version();<br>+———–+<br>| version() |<br>+———–+<br>| 5.5.36    |<br>+———–+</p><p>命令： show engines \G</p><p>*************************** 1. row ***************************<br>      Engine: FEDERATED<br>     Support: NO<br>     Comment: Federated MySQL storage engine<br>Transactions: NULL<br>          XA: NULL<br>  Savepoints: NULL<br>*************************** 2. row ***************************<br>      Engine: MRG_MYISAM<br>     Support: YES<br>     Comment: Collection of identical MyISAM tables<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 3. row ***************************<br>      Engine: MyISAM<br>     Support: YES<br>     Comment: MyISAM storage engine<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 4. row ***************************<br>      Engine: BLACKHOLE<br>     Support: YES<br>     Comment: &#x2F;dev&#x2F;null storage engine (anything you write to it disappears<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 5. row ***************************<br>      Engine: CSV<br>     Support: YES<br>     Comment: CSV storage engine<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 6. row ***************************<br>      Engine: MEMORY<br>     Support: YES<br>     Comment: Hash based, stored in memory, useful for temporary tables<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 7. row ***************************<br>      Engine: ARCHIVE<br>     Support: YES<br>     Comment: Archive storage engine<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO<br>*************************** 8. row ***************************<br>      Engine: InnoDB<br>     Support: DEFAULT<br>     Comment: Supports transactions, row-level locking, and foreign keys<br>Transactions: YES<br>          XA: YES<br>  Savepoints: YES<br>*************************** 9. row ***************************<br>      Engine: PERFORMANCE_SCHEMA<br>     Support: YES<br>     Comment: Performance Schema<br>Transactions: NO<br>          XA: NO<br>  Savepoints: NO</p><p>mysql支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。</p><h3><span id="84-关于mysql常用的存储引擎介绍一下">8.4、关于mysql常用的存储引擎介绍一下</span></h3><p>MyISAM存储引擎？<br>    它管理的表具有以下特征：<br>        使用三个文件表示每个表：<br>            格式文件 — 存储表结构的定义（mytable.frm）<br>            数据文件 — 存储表行的内容（mytable.MYD）<br>            索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。<br>        可被转换为压缩、只读表来节省空间</p><pre><code>    提示一下：        对于一张表来说，只要是主键，        或者加有unique约束的字段上会自动创建索引。    MyISAM存储引擎特点：        可被转换为压缩、只读表来节省空间        这是这种存储引擎的优势！！！！        MyISAM不支持事务机制，安全性低。</code></pre><p>InnoDB存储引擎？<br>    这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。<br>    InnoDB支持事务，支持数据库崩溃后自动恢复机制。<br>    InnoDB存储引擎最主要的特点是：非常安全。</p><pre><code>它管理的表具有下列主要特征：    – 每个 InnoDB 表在数据库目录中以.frm 格式文件表示    – InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）    – 提供一组用来记录事务性活动的日志文件    – 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理    – 提供全 ACID 兼容    – 在 MySQL 服务器崩溃后提供自动恢复    – 多版本（MVCC）和行级锁定    – 支持外键及引用的完整性，包括级联删除和更新InnoDB最大的特点就是支持事务：    以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，    不能很好的节省存储空间。</code></pre><p>MEMORY存储引擎？<br>    使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，<br>    这两个特点使得 MEMORY 存储引擎非常快。</p><pre><code>MEMORY 存储引擎管理的表具有下列特征：    – 在数据库目录内，每个表均以.frm 格式的文件表示。    – 表数据及索引被存储在内存中。（目的就是快，查询快！）    – 表级锁机制。    – 不能包含 TEXT 或 BLOB 字段。MEMORY 存储引擎以前被称为HEAP 引擎。MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</code></pre><h2><span id="9-事务重点五颗星必须理解必须掌握">9、事务（重点：五颗星*****，必须理解，必须掌握）</span></h2><h3><span id="91-什么是事务">9.1、什么是事务？</span></h3><pre><code>一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。什么是一个完整的业务逻辑？    假设转账，从A账户向B账户中转账10000.    将A账户的钱减去10000（update语句）    将B账户的钱加上10000（update语句）    这就是一个完整的业务逻辑。    以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。    这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</code></pre><h3><span id="92-x3dx3d只有dml语句才会有事务这一说其它语句和事务无关x3dx3d">9.2、&#x3D;&#x3D;只有DML语句才会有事务这一说，其它语句和事务无关！！！&#x3D;&#x3D;</span></h3><pre><code>insertdeleteupdate只有以上的三个语句和事务有关系，其它都没有关系。</code></pre><p>因为 只有以上的三个语句是数据库表中数据进行增、删、改的。<br>只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</p><p>数据安全第一位！！！</p><h3><span id="93-假设所有的业务只要一条dml语句就能完成还有必要存在事务机制吗">9.3、假设所有的业务，只要一条DML语句就能完成，还有必要存在事务机制吗？</span></h3><pre><code>正是因为做某件事的时候，需要多条DML语句共同联合起来才能完成，所以需要事务的存在。如果任何一件复杂的事儿都能一条DML语句搞定，那么事务则没有存在的价值了。到底什么是事务呢？    说到底，说到本质上，一个事务其实就是多条DML语句同时成功，或者同时失败！事务：就是批量的DML语句同时成功，或者同时失败！</code></pre><h3><span id="94-事务是怎么做到多条dml语句同时成功和同时失败的呢">9.4、事务是怎么做到多条DML语句同时成功和同时失败的呢？</span></h3><pre><code>InnoDB存储引擎：提供一组用来记录事务性活动的日志文件事务开启了：insertinsertinsertdeleteupdateupdateupdate事务结束了！在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。在事务的执行过程中，我们可以提交事务，也可以回滚事务。提交事务？    清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。    提交事务标志着，事务的结束。并且是一种全部成功的结束。回滚事务？    将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件    回滚事务标志着，事务的结束。并且是一种全部失败的结束。</code></pre><h3><span id="95-怎么提交事务怎么回滚事务">9.5、怎么提交事务，怎么回滚事务？</span></h3><pre><code>提交事务：commit; 语句回滚事务：rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）事务对应的英语单词是：transaction测试一下，在mysql当中默认的事务行为是怎样的？    mysql默认情况下是支持自动提交事务的。（自动提交）    什么是自动提交？        每执行一条DML语句，则提交一次！    这种自动提交实际上是不符合我们的开发习惯，因为一个业务    通常是需要多条DML语句共同执行才能完成的，为了保证数据    的安全，必须要求同时成功之后再提交，所以不能执行一条    就提交一条。怎么将mysql的自动提交机制关闭掉呢？    先执行这个命令：start transaction;演示事务：    ---------------------------------回滚事务----------------------------------------    mysql&gt; use bjpowernode;    Database changed    mysql&gt; select * from dept_bak;    Empty set (0.00 sec)    mysql&gt; start transaction;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);    Query OK, 1 row affected (0.00 sec)    mysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);    Query OK, 1 row affected (0.00 sec)    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | tj   |    |     10 | abc   | tj   |    +--------+-------+------+    2 rows in set (0.00 sec)    mysql&gt; rollback;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; select * from dept_bak;    Empty set (0.00 sec)    ---------------------------------提交事务----------------------------------------    mysql&gt; use bjpowernode;    Database changed    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | bj   |    +--------+-------+------+    1 row in set (0.00 sec)    mysql&gt; start transaction;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; insert into dept_bak values(20,&#39;abc    Query OK, 1 row affected (0.00 sec)    mysql&gt; insert into dept_bak values(20,&#39;abc    Query OK, 1 row affected (0.00 sec)    mysql&gt; insert into dept_bak values(20,&#39;abc    Query OK, 1 row affected (0.00 sec)    mysql&gt; commit;    Query OK, 0 rows affected (0.01 sec)    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | bj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    +--------+-------+------+    4 rows in set (0.00 sec)    mysql&gt; rollback;    Query OK, 0 rows affected (0.00 sec)    mysql&gt; select * from dept_bak;    +--------+-------+------+    | DEPTNO | DNAME | LOC  |    +--------+-------+------+    |     10 | abc   | bj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    |     20 | abc   | tj   |    +--------+-------+------+    4 rows in set (0.00 sec)</code></pre><h3><span id="96-事务包括4个特性">9.6、事务包括4个特性？</span></h3><pre><code>A：原子性    说明事务是最小的工作单元。不可再分。C：一致性    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，    以保证数据的一致性。I：隔离性    A事务和B事务之间具有一定的隔离。    教室A和教室B之间有一道墙，这道墙就是隔离性。    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？D：持久性    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据    保存到硬盘上！</code></pre><h3><span id="97-重点研究一下事务的隔离性">9.7、重点研究一下事务的隔离性！！！</span></h3><p>A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄。这就是事务的隔离级别。<br>这道墙越厚，表示隔离级别就越高。</p><p>事务和事务之间的隔离级别有哪些呢？4个级别</p><blockquote><p>读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》<br>        什么是读未提交？<br>            事务A可以读取到事务B未提交的数据。<br>        这种隔离级别存在的问题就是：<br>            脏读现象！(Dirty Read)<br>            我们称读到了脏数据。<br>        这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！</p></blockquote><blockquote><p>读已提交：read committed《提交之后才能读到》<br>        什么是读已提交？<br>            事务A只能读取到事务B提交之后的数据。<br>        这种隔离级别解决了什么问题？<br>            解决了脏读的现象。<br>        这种隔离级别存在什么问题？<br>            不可重复读取数据。<br>            什么是不可重复读取数据呢？<br>                在事务开启之后，第一次读到的数据是3条，当前事务还没有<br>                结束，可能第二次再读取的时候，读到的数据是4条，3不等于4<br>                称为不可重复读取。</p></blockquote><p>​这种隔离级别是比较真实的数据，&#x3D;&#x3D;每一次读到的数据是绝对的真实。&#x3D;&#x3D;<br>​oracle数据库默认的隔离级别是：read committed</p><blockquote><p>可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》<br>        什么是可重复读取？<br>            事务A开启之后，不管是多久，每一次在事务A中读取到的数据<br>            都是一致的。即使事务B将数据已经修改，并且提交了，事务A<br>            读取到的数据还是没有发生改变，这就是可重复读。<br>        可重复读解决了什么问题？<br>            解决了不可重复读取数据。<br>        可重复读存在的问题是什么？<br>            可以会出现幻影读。<br>            每一次读取到的数据都是幻象。不够真实！</p><pre><code>    早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！    读到的是假象。不够绝对的真实。</code></pre></blockquote><p>​&#x3D;&#x3D;mysql中默认的事务隔离级别就是这个！！！！！！！！！！！&#x3D;&#x3D;</p><blockquote><p>序列化&#x2F;串行化：serializable（最高的隔离级别）<br>        这是最高隔离级别，<u>效率最低。</u>解决了所有的问题。<br>        这种隔离级别表示事务排队，不能并发！<br>        synchronized，线程同步（事务同步）<br>        每一次读取到的数据都是最真实的，并且效率是最低的。</p></blockquote><h3><span id="98-验证各种隔离级别">9.8、验证各种隔离级别</span></h3><p>查看隔离级别：SELECT @@tx_isolation<br>+—————–+<br>| @@tx_isolation  |<br>+—————–+<br>| REPEATABLE-READ |<br>+—————–+<br>mysql默认的隔离级别</p><p>被测试的表t_user<br>验证：read uncommited<br>mysql&gt; set global transaction isolation level read uncommitted;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>select * from t_user;<br>                                                    start transaction;<br>                                                    insert into t_user values(‘zhangsan’);<br>select * from t_user;</p><p>验证：read commited<br>mysql&gt; set global transaction isolation level read committed;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>                                                    start transaction;<br>select * from t_user;<br>                                                    insert into t_user values(‘zhangsan’);<br>select * from t_user;<br>                                                    commit;<br>select * from t_user;</p><p>验证：repeatable read<br>mysql&gt; set global transaction isolation level repeatable read;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>                                                    start transaction;<br>select * from t_user;<br>                                                    insert into t_user values(‘lisi’);<br>                                                    insert into t_user values(‘wangwu’);<br>                                                    commit;<br>select * from t_user;</p><p>验证：serializable<br>mysql&gt; set global transaction isolation level serializable;</p><h2><span id="事务a事务b">事务A事务B</span></h2><p>use bjpowernode;<br>                                                    use bjpowernode;<br>start transaction;<br>                                                    start transaction;<br>select * from t_user;<br>insert into t_user values(‘abc’);<br>                                                    select * from t_user;</p><p>mysql day04课堂笔记</p><h1><span id="mysql-day04课堂笔记">mysql day04课堂笔记</span></h1><h2><span id="1-索引index">1、索引（index）</span></h2><h3><span id="11-什么是索引">1.1、什么是索引？</span></h3><pre><code>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。对于一本字典来说，查找某个汉字有两种方式：    第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。    效率比较低。    第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个    位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过    索引检索，效率较高。t_userid(idIndex)name(nameIndex)email(emailIndex)address  (emailAddressIndex)----------------------------------------------------------------------------------1zhangsan...2lisi3wangwu4zhaoliu5hanmeimei6jackselect * from t_user where name = &#39;jack&#39;;以上的这条SQL语句会去name字段上扫描，为什么？    因为查询条件是：name=&#39;jack&#39;如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，MySQL会进行全扫描，会将name字段上的每一个值都比对一遍。效率比较低。MySQL在查询方面主要就是两种方式：    第一种方式：全表扫描    第二种方式：根据索引检索。注意：    在实际中，汉语字典前面的目录是排序的，按照a b c d e f....排序，    为什么排序呢？因为只有排序了才会有区间查找这一说！（缩小扫描范围    其实就是扫描某个区间罢了！）    在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet    数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql    当中索引是一个B-Tree数据结构。    遵循左小又大原则存放。采用中序遍历方式遍历取数据。</code></pre><h3><span id="12-索引的实现原理">1.2、索引的实现原理？</span></h3><pre><code>假设有一张用户表：t_userid(PK)name每一行记录在硬盘上都有物理存储编号----------------------------------------------------------------------------------100zhangsan0x1111120lisi0x222299wangwu0x888888zhaoliu0x9999101jack0x666655lucy0x5555130tom0x7777提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）</code></pre><h3><span id="13-在mysql当中主键上以及unique字段上都会自动添加索引的">1.3、在mysql当中，主键上，以及unique字段上都会自动添加索引的！！！！</span></h3><p>什么条件下，我们会考虑给字段添加索引呢？<br>    条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）<br>    条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。<br>    条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</p><pre><code>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</code></pre><h3><span id="14-索引怎么创建怎么删除语法是什么">1.4、索引怎么创建？怎么删除？语法是什么？</span></h3><pre><code>创建索引：    mysql&gt; create index emp_ename_index on emp(ename);    给emp表的ename字段添加索引，起名：emp_ename_index删除索引：    mysql&gt; drop index emp_ename_index on emp;    将emp表上的emp_ename_index索引对象删除。</code></pre><h3><span id="15-在mysql当中怎么查看一个sql语句是否使用了索引进行检索">1.5、在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索？</span></h3><pre><code>mysql&gt; explain select * from emp where ename = &#39;KING&#39;;+----+-------------+-------+------+---------------+------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |+----+-------------+-------+------+---------------+------+---------+------+------+-------------+扫描14条记录：说明没有使用索引。type=ALLmysql&gt; create index emp_ename_index on emp(ename);mysql&gt; explain select * from emp where ename = &#39;KING&#39;;+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys   | key             | key_len | ref   | rows | Extra       |+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index | 33      | const |    1 | Using where |+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+</code></pre><h3><span id="16-索引有失效的时候什么时候索引失效呢">1.6、索引有失效的时候，什么时候索引失效呢？</span></h3><p>​</p><pre><code>失效的第1种情况：    select * from emp where ename like &#39;%T&#39;;    ename上即使添加了索引，也不会走索引，为什么？        原因是因为模糊匹配当中以“%”开头了！        尽量避免模糊查询的时候以“%”开始。        这是一种优化的手段/策略。    mysql&gt; explain select * from emp where ename like &#39;%T&#39;;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第2种情况：    使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有    索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个    字段上的索引也会实现。所以这就是为什么不建议使用or的原因。    mysql&gt; explain select * from emp where ename = &#39;KING&#39; or job = &#39;MANAGER&#39;;    +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys   | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+失效的第3种情况：    使用复合索引的时候，没有使用左侧的列查找，索引失效    什么是复合索引？        两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。        create index emp_job_sal_index on emp(job,sal);        mysql&gt; explain select * from emp where job = &#39;MANAGER&#39;;    +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+    | id | select_type | table | type | possible_keys     | key               | key_len | ref   | rows | Extra       |    +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+    |  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | emp_job_sal_index | 30      | const |    3 | Using where |    +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+        mysql&gt; explain select * from emp where sal = 800;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第4种情况：    在where当中索引列参加了运算，索引失效。    mysql&gt; create index emp_sal_index on emp(sal);    explain select * from emp where sal = 800;    +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+    | id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |    +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+    |  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |    +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+    mysql&gt; explain select * from emp where sal+1 = 800;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第5种情况：    在where当中索引列使用了函数    explain select * from emp where lower(ename) = &#39;smith&#39;;    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |    +----+-------------+-------+------+---------------+------+---------+------+------+-------------+失效的第6...失效的第7...</code></pre><h3><span id="17-索引是各种数据库进行优化的重要手段-优化的时候优先考虑的因素就是索引">1.7、索引是各种数据库进行优化的重要手段。优化的时候优先考虑的因素就是索引。</span></h3><p>索引在数据库当中分了很多类？<br>    单一索引：一个字段上添加索引。<br>    复合索引：两个字段或者更多的字段上添加索引。</p><pre><code>主键索引：主键上添加索引。唯一性索引：具有unique约束的字段上添加索引。.....注意：唯一性比较弱的字段上添加索引用处不大，越唯一效率越高</code></pre><h2><span id="2-视图view">2、视图(view)</span></h2><h3><span id="21-什么是视图">2.1、什么是视图？</span></h3><pre><code>view:站在不同的角度去看待同一份数据。</code></pre><h3><span id="22-怎么创建视图对象怎么删除视图对象">2.2、怎么创建视图对象？怎么删除视图对象？</span></h3><pre><code>表复制：mysql&gt; create table dept2 as select * from dept;dept2表中的数据：mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   |+--------+------------+----------+创建视图对象：    create view dept2_view as select * from dept2;删除视图对象：    drop view dept2_view;注意：只有DQL语句才能以view的形式创建。    create view view_name as 这里的语句必须是DQL语句;</code></pre><h3><span id="23-用视图做什么">2.3、用视图做什么？</span></h3><pre><code>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）//面向视图查询select * from dept2_view; // 面向视图插入insert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);// 查询原表数据mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   ||     60 | SALES      | BEIJING  |+--------+------------+----------+// 面向视图删除mysql&gt; delete from dept2_view;// 查询原表数据mysql&gt; select * from dept2;Empty set (0.00 sec)// 创建视图对象create view     emp_dept_viewas    select         e.ename,e.sal,d.dname    from        emp e    join        dept d    on        e.deptno = d.deptno;// 查询视图对象mysql&gt; select * from emp_dept_view;+--------+---------+------------+| ename  | sal     | dname      |+--------+---------+------------+| CLARK  | 2450.00 | ACCOUNTING || KING   | 5000.00 | ACCOUNTING || MILLER | 1300.00 | ACCOUNTING || SMITH  |  800.00 | RESEARCH   || JONES  | 2975.00 | RESEARCH   || SCOTT  | 3000.00 | RESEARCH   || ADAMS  | 1100.00 | RESEARCH   || FORD   | 3000.00 | RESEARCH   || ALLEN  | 1600.00 | SALES      || WARD   | 1250.00 | SALES      || MARTIN | 1250.00 | SALES      || BLAKE  | 2850.00 | SALES      || TURNER | 1500.00 | SALES      || JAMES  |  950.00 | SALES      |+--------+---------+------------+// 面向视图更新update emp_dept_view set sal = 1000 where dname = &#39;ACCOUNTING&#39;;// 原表数据被更新mysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 ||  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 ||  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 ||  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 ||  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 ||  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 ||  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     10 ||  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 ||  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     10 ||  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 ||  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 ||  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 ||  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 ||  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     10 |+-------+--------+-----------+------+------------+---------+---------+--------+</code></pre><h3><span id="24-视图对象在实际开发中到底有什么用方便简化开发利于维护">2.4、视图对象在实际开发中到底有什么用？《方便，简化开发，利于维护》</span></h3><pre><code>    create view         emp_dept_view    as        select             e.ename,e.sal,d.dname        from            emp e        join            dept d        on            e.deptno = d.deptno;</code></pre><p>​<br>​假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。<br>​每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？<br>​可以把这条复杂的SQL语句以视图对象的形式新建。<br>​在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。<br>​并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要<br>​修改视图对象所映射的SQL语句。<br>​<br>​我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。<br>​可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是<br>​存储在硬盘上的，不会消失。<br>​<br>​再提醒一下：<br>​视图对应的语句只能是DQL语句。<br>​但是视图对象创建完成之后，可以对视图进行增删改查等操作。<br>​<br>​小插曲：<br>​增删改查，又叫做：CRUD。<br>​CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。<br>​一般都说CRUD。<br>​<br>​C:Create（增）<br>​R:Retrive（查：检索）<br>​U:Update（改）<br>​D:Delete（删）</p><h2><span id="3-dba常用命令">3、DBA常用命令？</span></h2><pre><code>重点掌握：    数据的导入和导出（数据的备份）    其它命令了解一下即可。（这个培训日志文档留着，以后忘了，可以打开文档复制粘贴。）数据导出？    注意：在windows的dos命令窗口中：        mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123456        可以导出指定的表吗？        mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p123456数据导入？    注意：需要先登录到mysql数据库服务器上。    然后创建数据库：create database bjpowernode;    使用数据库：use bjpowernode    然后初始化数据库：source D:\bjpowernode.sql</code></pre><h2><span id="4-数据库设计三范式">4、数据库设计三范式</span></h2><h3><span id="41-什么是数据库设计范式">4.1、什么是数据库设计范式？</span></h3><pre><code>数据库表的设计依据。教你怎么进行数据库表的设计。</code></pre><h3><span id="42-数据库设计范式共有">4.2、数据库设计范式共有？</span></h3><blockquote><p>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</p></blockquote><blockquote><p>第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，<br>不要产生部分依赖。</p></blockquote><blockquote><p>第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，<br>不要产生传递依赖。</p></blockquote><p>声明：三范式是面试官经常问的，所以一定要熟记在心！</p><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><h3><span id="43-第一范式">4.3、第一范式</span></h3><pre><code>最核心，最重要的范式，所有表的设计都需要满足。必须有主键，并且每一个字段都是原子性不可再分。学生编号 学生姓名 联系方式------------------------------------------1001张三zs@gmail.com,13599999991002李四ls@gmail.com,136999999991001王五ww@163.net,13488888888以上是学生表，满足第一范式吗？    不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话学生编号(pk) 学生姓名邮箱地址联系电话----------------------------------------------------1001张三zs@gmail.com13599999991002李四ls@gmail.com136999999991003王五ww@163.net13488888888</code></pre><h3><span id="44-第二范式">4.4、第二范式：</span></h3><pre><code>建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。学生编号 学生姓名 教师编号 教师姓名----------------------------------------------------1001张三001王老师1002李四002赵老师1003王五001王老师1001张三002赵老师这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）这是非常典型的：多对多关系！分析以上的表是否满足第一范式？    不满足第一范式。怎么满足第一范式呢？修改学生编号+教师编号(pk)学生姓名  教师姓名----------------------------------------------------1001001张三王老师1002002李四赵老师1003001王五王老师1001002张三赵老师学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？    不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。    产生部分依赖有什么缺点？        数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。为了让以上的表满足第二范式，你需要这样设计：    使用三张表来表示多对多的关系！！！！    学生表    学生编号(pk)学生名字    ------------------------------------    1001张三    1002李四    1003王五        教师表    教师编号(pk)教师姓名    --------------------------------------    001王老师    002赵老师    学生教师关系表    id(pk)学生编号(fk)教师编号(fk)    ------------------------------------------------------    11001001    21002002    31003001    41001002背口诀：    多对多怎么设计？        多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</code></pre><h3><span id="45-第三范式">4.5、第三范式</span></h3><pre><code>第三范式建立在第二范式的基础之上要求所有非主键字典必须直接依赖主键，不要产生传递依赖。学生编号（PK） 学生姓名 班级编号  班级名称---------------------------------------------------------    1001张三01一年一班    1002李四02一年二班    1003王五03一年三班    1004赵六03一年三班以上表的设计是描述：班级和学生的关系。很显然是1对多关系！一个教室中有多个学生。分析以上表是否满足第一范式？    满足第一范式，有主键。分析以上表是否满足第二范式？    满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。分析以上表是否满足第三范式？    第三范式要求：不要产生传递依赖！    一年一班依赖01，01依赖1001，产生了传递依赖。    不符合第三范式的要求。产生了数据的冗余。那么应该怎么设计一对多呢？    班级表：一    班级编号(pk)班级名称    ----------------------------------------    01一年一班    02一年二班    03一年三班    学生表：多    学生编号（PK） 学生姓名 班级编号(fk)    -------------------------------------------    1001张三01    1002李四02    1003王五03    1004赵六03        背口诀：        一对多，两张表，多的表加外键！！！！！！！！！！！！</code></pre><h3><span id="46-总结表的设计">4.6、总结表的设计？</span></h3><pre><code>一对多：    一对多，两张表，多的表加外键！！！！！！！！！！！！多对多：    多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！一对一：    一对一放到一张表中不就行了吗？为啥还要拆分表？    在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。    一对一怎么设计？        没有拆分表之前：一张表            t_user            idlogin_namelogin_pwdreal_nameemailaddress........            ---------------------------------------------------------------------------            1zhangsan123张三zhangsan@xxx            2lisi123李四lisi@xxx            ...                这种庞大的表建议拆分为两张：            t_login 登录信息表            id(pk)login_namelogin_pwd            ---------------------------------            1zhangsan123            2lisi123            t_user 用户详细信息表            id(pk)real_nameemailaddress........login_id(fk+unique)            -----------------------------------------------------------------------------------------            100张三zhangsan@xxx1            200李四lisi@xxx2            口诀：一对一，外键唯一！！！！！！！！！！</code></pre><h3><span id="47-嘱咐一句话">4.7、嘱咐一句话：</span></h3><pre><code>数据库设计三范式是理论上的。实践和理论有的时候有偏差。最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。面试的时候把这句话说上：他就不会认为你是初级程序员了！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
